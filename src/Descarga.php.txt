<?php
defined('BASEPATH') OR exit('No direct script access allowed');
require_once(APPPATH.'/libraries/REST_Controller.php');
use Restserver\libraries\REST_Controller;

class Descarga extends REST_Controller {

public function __construct()
{

header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:PUT, GET, POST, DELETE, OPTIONS");
header("Access-Control-Allow-Headers:Content-Type, Content-Length, Accept-Encoding");


/* header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS");
header("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, Authorization"); */

  parent::__construct();
  $this->load->database();
}

/**
 * FILTRO PARA EXCLUIR RECIBOS RC DE CONSULTAS DE FACTURAS
 * 
 * Los recibos RC se almacenan en factcab por dependencias técnicas,
 * pero deben filtrarse en reportes y consultas de facturación.
 * 
 * @param string $tabla_alias Alias de la tabla (ej: 'f', 'factcab')
 */
private function aplicarFiltroSinRC($tabla_alias = '') {
    $prefix = $tabla_alias ? $tabla_alias . '.' : '';
    $this->db->where($prefix . 'tipo !=', 'RC');
}

/**
 * FILTRO PARA INCLUIR SOLO RECIBOS RC
 * 
 * Para consultas específicas de recibos RC
 * 
 * @param string $tabla_alias Alias de la tabla (ej: 'f', 'factcab')
 */
private function aplicarFiltroSoloRC($tabla_alias = '') {
    $prefix = $tabla_alias ? $tabla_alias . '.' : '';
    $this->db->where($prefix . 'tipo', 'RC');
}

public function Clisucxapp_post()//Aca se procesan los envios de clientes de la app y se los inserta en las talaba clientesapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["clientes"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='clisucapp'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA


$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

   //$this->response($this->db->insert_id());
  // $this->db->insert('prueba', $jsondata);
}
public function ClisucxappWeb_post()//Aca se procesan los envios de clientes de la app y se los inserta en las talaba clientesapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["clientes"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='clisuc';//$tabla='clisuc'.$id_vend;//ESTA ES LA QUE USABA CON VARIAS TABLAS AHORA SE CAMBIO POR UNA SOLA

// ✅ VALIDACIÓN: Verificar si el cliente ya existe (AGREGADO FASE 4 - 2025-10-07)
$id_cli = $datos['id_cli'];

$this->db->where('id_cli', $id_cli);
$query = $this->db->get($tabla);

if($query->num_rows() > 0) {
    // ❌ Cliente duplicado detectado - retornar HTTP 409 Conflict
    $respuesta = array(
        "error" => true,
        "mensaje" => "Cliente duplicado: Ya existe un cliente con id_cli = " . $id_cli,
        "codigo" => 409
    );
    $this->response($respuesta, REST_Controller::HTTP_CONFLICT);
} else {
    // ✅ Cliente no existe - proceder con INSERT
    $this->db->insert($tabla, $datos);
    $rows = $this->db->affected_rows();

    if($rows > 0) {
        // ✅ Inserción exitosa - retornar HTTP 201 Created
        $respuesta = array(
            "error" => false,
            "mensaje" => "Cliente creado exitosamente",
            "registros_insertados" => $rows,
            "id_cli" => $id_cli
        );
        $this->response($respuesta, REST_Controller::HTTP_CREATED);
    } else {
        // ❌ Error en la inserción - retornar HTTP 500
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al insertar el cliente en la base de datos"
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_ERROR);
    }
}
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}
}
public function UpdateClisucxapp_post()//Función para modificar datos de un cliente en la tabla correspondiente SE AGREGO 10/07/23
{
  $data = $this->post();
  if(isset($data) AND count($data)>0){ 
    $datos = $data['clientes']; 
    $id_vend = $data["id_vend"];
    $tabla = 'clisuc';//$tabla = 'clisuc'.$id_vend;//ESTA ES LA QUE USABA CON VARIAS TABLAS AHORA SE CAMBIO POR UNA SOLA

    if(isset($datos['idcli'])){ 
      $this->db->where('idcli', $datos['idcli']); 
      $this->db->update($tabla, $datos); 
      $rows = $this->db->affected_rows();

      $respuesta=array(
        "error"=>false,
        "mensaje"=>$rows,
		"datoscliente"=>$datos['cliente'],
		"datos"=>$datos,
		"tabla"=>$tabla
      );
      $this->response($respuesta);
    }
    else{
      $respuesta=array(
        "error"=>true,
        "mensaje"=>"No se especificó la clave de cliente"
      );
      $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
    }
  }
  else{  
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST"
    );
    $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function UpdateArtsucxapp_post()//Función para modificar los stocks de la lista de productos  SE AGREGO 26/12/23
{
  $data = $this->post();
  if(isset($data) AND count($data)>0){ 
    $idart = $data['idart']; 
    $exi = $data["exi"];
    $op = $data["op"];
    $tabla = 'artsucursal'; // exi es lo mismo que sucursal
    

    if(isset($idart)){
      $campo= 'exi'.$exi;
      if($op === '+')
      {
        $this->db->set($campo, "$campo + 1", FALSE);
      }
      else if ($op === '-')
      {
        $this->db->set($campo, "$campo - 1", FALSE);
      }
       
      $this->db->where('idart', $idart); 
      $this->db->update($tabla); 
      $rows = $this->db->affected_rows();

      $respuesta=array(
        "error"=>false,
        "mensaje"=>$rows,
		    "tabla"=>$tabla
      );
      $this->response($respuesta);
    }
    else{
      $respuesta=array(
        "error"=>true,
        "mensaje"=>"No se especificó la clave de cliente"
      );
      $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
    }
  }
  else{  
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST"
    );
    $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function UpdateArtsucxappManagedPHP_post()//Función para modificar los stocks de la lista de productos  SE AGREGO 26/12/23
{
  $data = $this->post();

  if (isset($data['result'], $data['exi']) AND is_array($data['result'])) {
    $suc = $data['exi'];
    $tabla = 'artsucursal';
    $contador = 0;
    
    foreach ($data['result'] as $item) {
      // Obtener el ID del artículo
      $id_articulo = isset($item['id_articulo']) ? $item['id_articulo'] : null;
      $cantidad = $item['cantidad']; 
      $op = $item['tipodoc'];
      $campo = "exi{$suc}";
      
      // Verificar que tenemos un ID válido
      if (empty($id_articulo) || $id_articulo == 0) {
        continue; // Saltar este item si no tiene ID válido
      }
      
      // Aumenta o disminuye el stock según el operador
      if($op === "FC" OR $op === "PR" OR $op === "ND") {
        // RESTAN STOCK: Facturas, Presupuestos y Notas de Débito
        $this->db->set($campo, "$campo - $cantidad", FALSE);
      } else if ($op === "NC" OR $op === "NV") {
        // SUMAN STOCK: Notas de Crédito y Devoluciones
        $this->db->set($campo, "$campo + $cantidad", FALSE);
      } else if ($op === "CS") {
        // NO AFECTAN STOCK: Consultas
        log_message('info', "Operación {$op} no afecta stock para id_articulo: {$id_articulo}");
        continue; // Saltar al siguiente item
      } else {
        // Operaciones desconocidas - log para debugging
        log_message('warning', "Operación desconocida {$op} para id_articulo: {$id_articulo} - no se afecta stock");
        continue; // Saltar al siguiente item
      }
      
      // Usar id_articulo como condición WHERE
      $this->db->where('id_articulo', $id_articulo);
      $this->db->update($tabla);
      $affected = $this->db->affected_rows();
      $contador += $affected;
      
      // Log para debugging si no se actualiza nada
      if ($affected == 0) {
        log_message('error', "No se pudo actualizar stock para id_articulo: {$id_articulo}, cantidad: {$cantidad}, op: {$op}");
      }
    }
    
    $respuesta = [
      "error" => false,
      "mensaje" => "Se actualizaron {$contador} registros",
      "tabla" => $tabla,
      "sucursal_exi" => $suc,
      "items_procesados" => count($data['result']),
      "registros_actualizados" => $contador
    ];
    $this->response($respuesta);
    
  } else {
    // Mensaje de error si faltan datos
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST o el formato no es correcto"
    );
    $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function eliminarCliente_post()
{
  $data = $this->post();
  if(isset($data) && count($data) > 0){
     $datos = $data['clientes'];
    $id_vend = $data["id_vend"];
    $tabla = 'clisuc'.$id_vend;

    if(isset($datos['idcli'])){ 
      
      $this->db->where('idcli', $datos['idcli']); 
      $this->db->delete($tabla); 
      $rows = $this->db->affected_rows();

      $respuesta = array(
        "error" => false,
        "mensaje" => $rows,
        "tabla" => $tabla
      );
      $this->response($respuesta);
    } else {
      $respuesta = array(
        "error" => true,
        "mensaje" => "No se especificó el ID del cliente"
      );
      $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
  } else {  
    $respuesta = array(
      "error" => true,
      "mensaje" => "Faltan datos en el POST"
    );
    $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function EliminarRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_rubro_p'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_rubro_p)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro_p'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_rubro_p', $id);
        $this->db->delete('rubro_principal');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_rubro', $id);
        $this->db->delete('rubros');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_marca'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_marca', $id);
        $this->db->delete('marcas');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la marca"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function EliminarArtIva_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_ariva'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_ariva'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_ariva', $id);
        $this->db->delete('artiva');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el iva"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_moneda'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_moneda)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_moneda'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_moneda', $id);
        $this->db->delete('tipomone');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_valor'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_valor)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_valor'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_valor', $id);
        $this->db->delete('valorcambio');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function EliminarProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_prov'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_prov'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_prov', $id);
        $this->db->delete('proveedores');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function EliminarConflista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_conflista'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_conflista)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_conflista'];

        $this->db->trans_start();

        // Delete from conflistas
        $this->db->where('id_conflista', $id);
        $this->db->delete('conf_lista');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la conflista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_articulo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_articulo)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_articulo'];

        $this->db->trans_start();

        // Delete from articulos
        $this->db->where('id_articulo', $id);
        $this->db->delete('artsucursal');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el artículo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validación
        if(!isset($data['id_caja'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_caja)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = (int)$data['id_caja'];

        $this->db->trans_start();
        $this->db->where('id_caja', $id);
        $this->db->delete('caja_lista');
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            if ($rows > 0) {
                 $respuesta = array(
                    "error" => false,
                    "mensaje" => $rows // Número de filas eliminadas
                );
                $this->response($respuesta);
            } else {
                 $respuesta = array(
                    "error" => true, // O false si prefieres indicar que no se encontró pero no es un error del servidor
                    "mensaje" => "No se encontró la caja lista con el ID proporcionado o ya fue eliminada"
                );
                $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND); // Opcional: HTTP Status
            }
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        if(!isset($data['id_concepto'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_concepto)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_concepto'];

        $this->db->trans_start();
        $this->db->where('id_concepto', $id);
        $this->db->delete('caja_conceptos');
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             if ($rows > 0) {
                 $respuesta = array(
                    "error" => false,
                    "mensaje" => $rows // Número de filas eliminadas
                 );
             } else {
                  $respuesta = array(
                    "error" => true, // Considerar si no encontrarlo es un error o no
                    "mensaje" => "No se encontró el concepto de caja con el ID proporcionado."
                 );
             }
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajamovi_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar que el ID esté presente
        if(!isset($data['id_movimiento'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_movimiento)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_movimiento'];

        $this->db->trans_start();

        $this->db->where('id_movimiento', $id);
        $this->db->delete('caja_movi'); // Nombre de la tabla

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             if ($rows > 0) {
                 $respuesta = array(
                     "error" => false,
                     "mensaje" => $rows // Filas afectadas (debería ser 1)
                 );
             } else {
                  $respuesta = array(
                     "error" => true, // Considerar error si no se encontró el ID
                     "mensaje" => "No se encontró el movimiento con el ID especificado para eliminar."
                 );
                 // Podrías usar HTTP_NOT_FOUND aquí también
                 $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
                 return;
             }
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function PedidossucxappCompleto_post() {
    $data = $this->post();
    
    // Verificar si se recibieron datos en el POST
    if (isset($data) && count($data) > 0) {
        // Extraer datos del POST
        $pedidos = isset($data["pedidos"]) ? $data["pedidos"] : null;
        $cabecera = isset($data["cabecera"]) ? $data["cabecera"] : null;
        $id_vend = isset($data["id_vend"]) ? $data["id_vend"] : null;
        $caja_movi = isset($data["caja_movi"]) ? $data["caja_movi"] : null;

        // Verificar que los datos necesarios no sean nulos
        if ($pedidos && $cabecera && $id_vend) {
            $tabla = 'psucursal' . $id_vend;
            $tabla_cabecera = 'factcab' . $id_vend;

            $this->db->trans_start(); // Iniciar transacción

            // Validar valores numéricos para evitar desbordamientos
            // Cliente, si es numérico, verificar límite
            if (isset($cabecera['cliente']) && is_numeric($cabecera['cliente']) && $cabecera['cliente'] > 999999) {
                $cabecera['cliente'] = substr($cabecera['cliente'], 0, 6); // Truncar a 6 dígitos
            }
            
            // Controlar otros campos numéricos que puedan causar problemas
            $numeric_fields_to_check = ['numero_int', 'numero_fac', 'anumero_com'];
            foreach ($numeric_fields_to_check as $field) {
                if (isset($cabecera[$field]) && is_numeric($cabecera[$field]) && $cabecera[$field] > 999999) {
                    $cabecera[$field] = 999999; // Limitar al máximo permitido
                }
            }
            
            try {
                // Insertar cabecera y obtener el id_num generado
                $this->db->set($cabecera);
                $this->db->insert($tabla_cabecera);
                if ($this->db->affected_rows() > 0) {
                    $id_num = $this->db->insert_id(); // Obtener el id_num generado
                    $contador_exitosas = $this->db->affected_rows();
                } else {
                    log_message('error', 'Error al insertar en la tabla ' . $tabla_cabecera . ': ' . json_encode($cabecera));
                    $this->db->trans_rollback();
                    $respuesta = array(
                        "error" => true,
                        "mensaje" => "Error al insertar cabecera, transacción revertida"
                    );
                    $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                    return;
                }
            } catch (Exception $e) {
                log_message('error', 'Excepción al insertar en ' . $tabla_cabecera . ': ' . $e->getMessage());
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al insertar cabecera: " . $e->getMessage()
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                return;
            }

            // Insertar pedidos
            foreach ($pedidos as &$valor) {
                $valor['id_num'] = $id_num; // Asignar el id_num de la cabecera al pedido
                $this->db->insert($tabla, $valor); // valor es un objeto
                if ($this->db->affected_rows() > 0) {
                    $contador_exitosas += $this->db->affected_rows();
                } else {
                    log_message('error', 'Error al insertar en la tabla ' . $tabla . ': ' . json_encode($valor));
                }
            }
            
            // Generar recibo automáticamente para todas las operaciones
            $this->generarReciboAutomatico($cabecera, $id_num, $id_vend);
            
            // Insertar caja_movi si está presente
            if ($caja_movi) {
                // Asignar el id_num de la cabecera al movimiento de caja
                $caja_movi['num_operacion'] = $id_num;
                
                // Limpiar campos de fecha nulos o vacíos
                foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
                    if (isset($caja_movi[$dateField]) && empty($caja_movi[$dateField])) {
                        $caja_movi[$dateField] = null;
                    }
                }
                
                // Validar campos numéricos para prevenir desbordamientos
                $numeric_limit_fields = [
                    'sucursal' => 999999,
                    'codigo_mov' => 9999999999,
                    'num_operacion' => 9999999999,
                    'banco' => 9999999999,
                    'num_cheque' => 9999999999,
                    'cuenta_mov' => 999999,
                    'cliente' => 9999999999,
                    'proveedor' => 9999999999,
                    'codigo_mbco' => 9999999999,
                    'punto_venta' => 9999,
                    'numero_comprobante' => 99999999
                ];
                
                foreach ($numeric_limit_fields as $field => $limit) {
                    if (isset($caja_movi[$field]) && !empty($caja_movi[$field])) {
                        if (is_numeric($caja_movi[$field]) && $caja_movi[$field] > $limit) {
                            $caja_movi[$field] = $limit;
                        }
                    } else {
                        $caja_movi[$field] = null;
                    }
                }
                
                // Limpiar campos de texto nulos o vacíos
                foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
                    if (isset($caja_movi[$strField]) && $caja_movi[$strField] === '') {
                        $caja_movi[$strField] = null;
                    }
                }
                
                // Generar descripción automática si tipo_movi es 'A'
                if (isset($caja_movi['tipo_movi']) && $caja_movi['tipo_movi'] === 'A') {
                    $caja_movi['descripcion_mov'] = $this->generarDescripcionAutomatica($caja_movi);
                }
                
                try {
                    $this->db->insert('caja_movi', $caja_movi);
                    if ($this->db->affected_rows() > 0) {
                        $contador_exitosas += $this->db->affected_rows();
                    } else {
                        log_message('error', 'Error al insertar en la tabla caja_movi: ' . json_encode($caja_movi));
                    }
                } catch (Exception $e) {
                    log_message('error', 'Excepción al insertar en caja_movi: ' . $e->getMessage());
                    // No hacemos rollback aquí, porque permitimos que continúe incluso si falla el insert de caja_movi
                }
            }

            $this->db->trans_complete(); // Completar transacción

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error, revertir la transacción
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al insertar datos, transacción revertida"
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Respuesta exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => $contador_exitosas
                );
                $this->response($respuesta);
            }
        } else {
            // Respuesta de error por datos incompletos
            $respuesta = array(
                "error" => true,
                "mensaje" => "Datos incompletos en el POST"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    } else {
        // Respuesta de error por falta de datos en el POST
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function Pedidossucxapp_post()//Aca se procesan los envios de pedidos de la app y se los inserta en las talaba pedidosapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["pedidos"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='psucursal'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA
$contador_exitosas = 0; // Contador de inserciones exitosas
//$jsondata=json_decode($datos);
  foreach ($datos as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto
    if ($this->db->affected_rows() > 0) { // Si la inserción fue exitosa
        $contador_exitosas += $this->db->affected_rows();
    }
  }
//$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=> $contador_exitosas//$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}

/**
 * Función auxiliar para generar recibo automáticamente
 * Se ejecuta para todas las operaciones sin importar el saldo
 */
private function generarReciboAutomatico($cabecera, $id_num, $id_vend) {
    try {
        // Generar número de recibo único
        $numero_recibo = $this->getNextReciboNumber($id_vend);
        
        // Calcular importe total
        $importe_total = floatval($cabecera['basico']) + floatval($cabecera['iva1']);
        
        // Determinar el saldo del recibo (0 para operaciones al contado)
        $recibo_saldo = isset($cabecera['saldo']) ? floatval($cabecera['saldo']) : 0;
        
        // Preparar datos del recibo
        $recibo = array(
            'recibo' => $numero_recibo,
            'c_tipo' => 'RC',
            'c_numero' => isset($cabecera['numero_fac']) ? $cabecera['numero_fac'] : 0,
            'c_cuota' => 0,
            'fecha' => isset($cabecera['emitido']) ? $cabecera['emitido'] : date('Y-m-d'),
            'importe' => $importe_total,
            'usuario' => isset($cabecera['usuario']) ? $cabecera['usuario'] : 'sistema',
            'observacion' => 0,
            'cod_lugar' => '1',
            'sesion' => 0,
            'c_tipf' => isset($cabecera['letra']) ? $cabecera['letra'] : 'B',
            'c_puntoventa' => isset($cabecera['puntoventa']) ? $cabecera['puntoventa'] : 0,
            'recibo_asoc' => $id_num,
            'recibo_saldo' => $recibo_saldo,
            'cod_sucursal' => $id_vend,
            'fec_proceso' => date('Y-m-d'),
            'bonifica' => isset($cabecera['bonifica']) ? $cabecera['bonifica'] : 0,
            'bonifica_tipo' => isset($cabecera['bonifica_tipo']) ? $cabecera['bonifica_tipo'] : 'P',
            'interes' => isset($cabecera['interes']) ? $cabecera['interes'] : 0,
            'interes_tipo' => isset($cabecera['interes_tipo']) ? $cabecera['interes_tipo'] : 'P',
            'id_fac' => $id_num
        );
        
        // Insertar recibo en la tabla correspondiente
        $tabla_recibos = 'recibos' . $id_vend;
        $this->db->insert($tabla_recibos, $recibo);
        
        // Log del recibo generado
        log_message('info', 'Recibo generado automáticamente: ' . $numero_recibo . ' para operación: ' . $id_num);
        
    } catch (Exception $e) {
        // Log del error pero no interrumpir la transacción principal
        log_message('error', 'Error al generar recibo automático: ' . $e->getMessage());
    }
}

/**
 * Función auxiliar para obtener el siguiente número de recibo
 */
private function getNextReciboNumber($id_vend) {
    try {
        // Obtener el último número de recibo de la tabla correspondiente
        $tabla_recibos = 'recibos' . $id_vend;
        $this->db->select('MAX(CAST(recibo AS INTEGER)) as max_recibo');
        $this->db->from($tabla_recibos);
        $query = $this->db->get();
        
        if ($query->num_rows() > 0) {
            $row = $query->row();
            $max_recibo = $row->max_recibo;
            return $max_recibo ? $max_recibo + 1 : 1;
        } else {
            return 1;
        }
    } catch (Exception $e) {
        log_message('error', 'Error al obtener número de recibo: ' . $e->getMessage());
        return 1;
    }
}

public function Mixto_post()
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["mixto"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='mixto'.$id_vend;


//$this->db->query("DELETE FROM $tabla");//PRUEBA

$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}

public function Articulossucxapp_post()//Aca se procesan los envios de pedidos de la app y se los inserta en las talaba pedidosapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["articulos"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='artsucapp'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA

$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}
public function PagoCabecera_post()
{
    $data = $this->post();

    // Verificar que los datos necesarios estén presentes
    if (!isset($data['sucursal']) || !isset($data['pagoCC'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos requeridos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $sucursal = $data['sucursal'];
    $pagoCC = $data['pagoCC'];

    // Verificar que todos los componentes necesarios de pagoCC estén presentes
    if (!isset($pagoCC['cabeceras']) || !isset($pagoCC['psucursal']) || !isset($pagoCC['cabecera']) || !isset($pagoCC['recibo'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan componentes en pagoCC"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // NUEVA VALIDACIÓN: Verificar que todos los documentos sean del mismo tipo
    $tiposUnicos = array();
    foreach ($pagoCC['cabeceras'] as $cabecera) {
        if (isset($cabecera['tipo']) && !in_array($cabecera['tipo'], $tiposUnicos)) {
            $tiposUnicos[] = $cabecera['tipo'];
        }
    }
    
    if (count($tiposUnicos) > 1) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se pueden procesar documentos de diferentes tipos en la misma operación"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }
    
    $tipoDocumento = $tiposUnicos[0] ?? 'FC';
    
    // Para presupuestos (PR), el frontend ya maneja la restricción de efectivo
    // La información del método de pago se almacena en 'codigo_mov' y 'caja', no en cod_tarj
    if ($tipoDocumento === 'PR') {
        // Validación manejada en frontend - PR siempre usa efectivo (codTarj = "11")
        // No se requiere lógica adicional aquí
    }

    // Iniciar transacción
    $this->db->trans_start();

    $registros_afectados = array(
        'factcab' => 0,
        'psucursal' => 0,
        'recibos' => 0,
        'caja_movi' => 0  // ✅ NUEVO
    );

    $id_num_cabecera = null;

    // 1. Actualizar cabeceras en factcab<sucursal>
    foreach ($pagoCC['cabeceras'] as $cabecera) {
        if (!isset($cabecera['id_num']) || !isset($cabecera['saldo']) || !isset($cabecera['id_aso'])) {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "Datos incompletos en una cabecera"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->where('id_num', $cabecera['id_num']);
        $this->db->update('factcab' . $sucursal, array(
            'saldo' => $cabecera['saldo'],
            'id_aso' => $cabecera['id_aso'],
			'anumero_com' => $cabecera['anumero_com'],
			'atipo' => $cabecera['atipo']
        ));
        $registros_afectados['factcab'] += $this->db->affected_rows();
    }

    // 2. Insertar en psucursal<sucursal>
    $this->db->insert('psucursal' . $sucursal, $pagoCC['psucursal']);
    $registros_afectados['psucursal'] = $this->db->affected_rows();

    // 3. Insertar en factcab<sucursal> y obtener ID
    $this->db->insert('factcab' . $sucursal, $pagoCC['cabecera']);
    $registros_afectados['factcab'] += $this->db->affected_rows();
    $id_num_cabecera = $this->db->insert_id();

    // 4. Insertar en recibos<sucursal>
    foreach ($pagoCC['recibo'] as $recibo) {
        $this->db->insert('recibos' . $sucursal, $recibo);
        $registros_afectados['recibos'] += $this->db->affected_rows();
    }

    // ✅ NUEVO: 5. Insertar caja_movi (REUTILIZANDO LÓGICA DE PedidossucxappCompleto_post)
    if (isset($pagoCC['caja_movi']) && $pagoCC['caja_movi']) {
        $caja_movi = $pagoCC['caja_movi'];

        // Asignar el id_num generado
        $caja_movi['num_operacion'] = $id_num_cabecera;

        // Limpiar campos de fecha nulos o vacíos
        foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
            if (isset($caja_movi[$dateField]) && empty($caja_movi[$dateField])) {
                $caja_movi[$dateField] = null;
            }
        }

        // Validar campos numéricos para prevenir desbordamientos
        $numeric_limit_fields = [
            'sucursal' => 999999,
            'codigo_mov' => 9999999999,
            'num_operacion' => 9999999999,
            'banco' => 9999999999,
            'num_cheque' => 9999999999,
            'cuenta_mov' => 999999,
            'cliente' => 9999999999,
            'proveedor' => 9999999999,
            'codigo_mbco' => 9999999999,
            'punto_venta' => 9999,
            'numero_comprobante' => 99999999
        ];

        foreach ($numeric_limit_fields as $field => $limit) {
            if (isset($caja_movi[$field]) && !empty($caja_movi[$field])) {
                if (is_numeric($caja_movi[$field]) && $caja_movi[$field] > $limit) {
                    $caja_movi[$field] = $limit;
                }
            } else {
                $caja_movi[$field] = null;
            }
        }

        // Limpiar campos de texto nulos o vacíos
        foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
            if (isset($caja_movi[$strField]) && $caja_movi[$strField] === '') {
                $caja_movi[$strField] = null;
            }
        }

        // Generar descripción automática si tipo_movi es 'A'
        if (isset($caja_movi['tipo_movi']) && $caja_movi['tipo_movi'] === 'A') {
            $caja_movi['descripcion_mov'] = $this->generarDescripcionAutomatica($caja_movi);
        }

        try {
            $this->db->insert('caja_movi', $caja_movi);
            $registros_afectados['caja_movi'] = $this->db->affected_rows();

            if ($registros_afectados['caja_movi'] > 0) {
                log_message('info', 'Movimiento de caja insertado para pago cabecera ID: ' . $id_num_cabecera);
            } else {
                log_message('error', 'Error al insertar movimiento de caja para pago ID: ' . $id_num_cabecera);
            }
        } catch (Exception $e) {
            log_message('error', 'Excepción al insertar en caja_movi ID ' . $id_num_cabecera . ': ' . $e->getMessage());
            // No hacer rollback, permitir que continúe
        }
    }

    // Completar transacción
    $this->db->trans_complete();

    // Verificar si la transacción fue exitosa
    if ($this->db->trans_status() === FALSE) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error en la transacción. Se ha realizado un rollback."
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    } else {
        $respuesta = array(
            "error" => false,
            "mensaje" => "Operación exitosa",
            "registros_afectados" => $registros_afectados
        );
        $this->response($respuesta);
    }
}
public function PedidoItemyCab_post() {
        $data = $this->post();
        
        if(isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacción

            // Insertar en la tabla pedidoitem y obtener el ID
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                $pedidoItem['observacion'],
                $pedidoItem['estado']
            ]);
            $result = $query->row_array();
            $id_items = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                $pedidoscb['observacion'],
                $pedidoscb['estado'],
                $id_items
            ]);
            $result = $query->row_array();
            $id_num = $result['id_num'];

            // Actualizar id_num en pedidoitem
            $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num, $id_items]);

            $this->db->trans_complete(); // Completar transacción

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacción
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido. La transacción ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacción fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado exitosamente",
                    "id_items" => $id_items,
                    "id_num" => $id_num
                );
                $this->response($respuesta);
            }
        } else {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }
	public function PedidoItemyCabId_post() {
       $data = $this->post();

        // Validar que los datos necesarios estén presentes en la solicitud
        if(isset($data['id_num']) && isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $id_num_parametro = $data['id_num'];
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacción

            // Insertar en la tabla pedidoitem y obtener el ID (sin modificar el estado por ahora)
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                $pedidoItem['observacion'],
                  $pedidoItem['estado'] // Establecer el estado inicial del nuevo pedidoItem
            ]);
            $result = $query->row_array();
            $id_items_nuevo = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?,?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                $pedidoscb['observacion'],
                $pedidoscb['estado'],
                $id_items_nuevo // Asociar con el nuevo id_items
            ]);
            $result = $query->row_array();
            $id_num_generado = $result['id_num'];

            // Actualizar id_num en el nuevo pedidoitem
                $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num_generado, $id_items_nuevo]);

            // Actualizar estado a "Solicitado-R" solo en el pedidoitem existente si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoitem SET estado = ? WHERE id_num = ? AND estado = 'Solicitado-E'", ["Solicitado-R", $id_num_parametro]);
             }
             
              // Actualizar estado a "Solicitado-R" solo en pedidoscb existentes si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoscb SET estado = ? WHERE id_num = ? AND estado = 'Solicitado-E'", ["Solicitado-R", $id_num_parametro]);
             }

            $this->db->trans_complete(); // Completar transacción

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacción
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido y actualizar estados. La transacción ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacción fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado y estados actualizados exitosamente",
                    "id_items_nuevo" => $id_items_nuevo,
                    "id_num_generado" => $id_num_generado
                );
                $this->response($respuesta);
            }
        } else {
            // Si faltan datos en la solicitud
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST. Se requieren 'id_num', 'pedidoItem' y 'pedidoscb'."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }
	
	public function PedidoItemyCabIdEnvio_post() {
       $data = $this->post();

        // Validar que los datos necesarios estén presentes en la solicitud
        if(isset($data['id_num']) && isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $id_num_parametro = $data['id_num'];
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacción

            // Insertar en la tabla pedidoitem y obtener el ID (sin modificar el estado por ahora)
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                $pedidoItem['observacion'],
                  $pedidoItem['estado'] // Establecer el estado inicial del nuevo pedidoItem
            ]);
            $result = $query->row_array();
            $id_items_nuevo = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                $pedidoscb['observacion'],
                $pedidoscb['estado'],
                $id_items_nuevo // Asociar con el nuevo id_items
            ]);
            $result = $query->row_array();
            $id_num_generado = $result['id_num'];

            // Actualizar id_num en el nuevo pedidoitem
                $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num_generado, $id_items_nuevo]);

            // Actualizar estado a "Solicitado-E" solo en el pedidoitem existente si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoitem SET estado = ? WHERE id_num = ? AND estado = 'Solicitado'", ["Solicitado-E", $id_num_parametro]);
             }
             
              // Actualizar estado a "Solicitado-E" solo en pedidoscb existentes si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoscb SET estado = ? WHERE id_num = ? AND estado = 'Solicitado'", ["Solicitado-E", $id_num_parametro]);
             }

            $this->db->trans_complete(); // Completar transacción

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacción
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido y actualizar estados. La transacción ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacción fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado y estados actualizados exitosamente",
                    "id_items_nuevo" => $id_items_nuevo,
                    "id_num_generado" => $id_num_generado
                );
                $this->response($respuesta);
            }
        } else {
            // Si faltan datos en la solicitud
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST. Se requieren 'id_num', 'pedidoItem' y 'pedidoscb'."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }

public function SubirDatosRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_rubro']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_rubro, rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('rubro_principal', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function SubirDatosArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['nomart']) || !isset($data['marca']) || !isset($data['precon'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (nomart, marca, precon)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new articulo with all fields
        $this->db->insert('artsucursal', array(
            'nomart' => $data['nomart'],
            'marca' => $data['marca'],
            'precon' => $data['precon'],
            'prefi1' => $data['prefi1'],
            'prefi2' => $data['prefi2'],
            'prefi3' => $data['prefi3'],
            'prefi4' => $data['prefi4'],
            'exi1' => $data['exi1'],
            'exi2' => $data['exi2'],
            'exi3' => $data['exi3'],
            'exi4' => $data['exi4'],
            'exi5' => $data['exi5'],
            'stkmin1' => $data['stkmin1'],
            'stkmax1' => $data['stkmax1'],
            'stkprep1' => $data['stkprep1'],
            'stkmin2' => $data['stkmin2'],
            'stkmax2' => $data['stkmax2'],
            'stkprep2' => $data['stkprep2'],
            'stkmin3' => $data['stkmin3'],
            'stkmax3' => $data['stkmax3'],
            'stkprep3' => $data['stkprep3'],
            'stkmin4' => $data['stkmin4'],
            'stkmax4' => $data['stkmax4'],
            'stkprep4' => $data['stkprep4'],
            'stkmin5' => $data['stkmin5'],
            'stkmax5' => $data['stkmax5'],
            'stkprep5' => $data['stkprep5'],
            'cd_articulo' => $data['cd_articulo'],
            'cd_proveedor' => $data['cd_proveedor'],
            'cd_barra' => $data['cd_barra'],
            'idart' => $data['idart'],
            'estado' => $data['estado'],
            'rubro' => $data['rubro'],
            'articulo' => $data['articulo'],
            'cod_iva' => $data['cod_iva'],
            'prebsiva' => $data['prebsiva'],
            'precostosi' => $data['precostosi'],
            'margen' => $data['margen'],
            'descuento' => $data['descuento'],
            'cod_deposito' => $data['cod_deposito'],
            'tipo_moneda' => $data['tipo_moneda']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el artículo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function SubirDatosTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_mone']) || !isset($data['moneda']) || !isset($data['simbolo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_mone, moneda, simbolo)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('tipomone', array(
            "cod_mone"=> $data['cod_mone'],
        "moneda"=> $data['moneda'],
        "simbolo"=> $data['simbolo'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['codmone']) || !isset($data['desvalor']) || !isset($data['vcambio'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (codmone, desvalor, vcambio)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('valorcambio', array(
            "codmone"=> $data['codmone'],
        "desvalor"=> $data['desvalor'],
        "fecdesde"=> $data['fecdesde'],
        "fechasta"=> $data['fechasta'],
        "vcambio"=> $data['vcambio'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function SubirDatosProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['nombre']) || !isset($data['cuit'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (nombre, cuit)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new provider with all fields
        $this->db->insert('proveedores', array(
            'cod_prov' => $data['cod_prov'],
            'nombre' => $data['nombre'],
            'direccion' => $data['direccion'],
            'codpos' => $data['codpos'],
            'localidad' => $data['localidad'],
            'telefono' => $data['telefono'],
            'cuit' => $data['cuit'],
            'contacto' => $data['contacto'],
            'rubro' => $data['rubro'],
            'cod_iva' => $data['cod_iva'],
            'ganancias' => $data['ganancias'],
            'ingbrutos' => $data['ingbrutos'],
            'email' => $data['email'],
            'www' => $data['www'],
            'cta_proveedores' => $data['cta_proveedores'],
            'fec_proceso' => $data['fec_proceso']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosArtIva_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_iva']) || !isset($data['descripcion'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_iva, descripcion)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new artiva record
        $this->db->insert('artiva', array(
            'cod_iva' => $data['cod_iva'],
            'descripcion' => $data['descripcion'],
            // 'desde_date' => $data['desde_date'],
           /*  'desde_date' => date('Y-m-d', strtotime($data['desde_date'])),
            'hasta_date' => $data['hasta_date'], */
    'desde' => !empty($data['desde']) ? date('Y-m-d', strtotime($data['desde'])) : null,
'hasta' => !empty($data['hasta']) ? date('Y-m-d', strtotime($data['hasta'])) : null,
            'tipo_ali_1' => $data['tipo_ali_1'],
            'alicuota1' => $data['alicuota1'],
            'tipo_ali_2' => $data['tipo_ali_2'],
            'alicuota2' => $data['alicuota2'],
            'tipo_ali_3' => $data['tipo_ali_3'],
            'alicuota3' => $data['alicuota3'],
            'cuit' => $data['cuit'] ? 't' : 'f'
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el registro de IVA"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validación básica de campos requeridos (se pueden añadir más)
        if(!isset($data['descripcion']) || !isset($data['tipo_concepto']) || !isset($data['fija']) || !isset($data['ingreso_egreso']) || !isset($data['id_caja']) || !isset($data['activo_inactivo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos para el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start();

        // Insertar nuevo concepto
        $this->db->insert('caja_conceptos', array(
            'descripcion' => $data['descripcion'],
            'tipo_concepto' => $data['tipo_concepto'],
            'fija' => $data['fija'],
            'ingreso_egreso' => $data['ingreso_egreso'],
            'id_caja' => $data['id_caja'],
            'activo_inactivo' => $data['activo_inactivo']
            // 'id_concepto' es serial y se genera automáticamente
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Indica cuántas filas se insertaron (debería ser 1)
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosCajamovi_post()
{
    $data = $this->post(); // Recibe el objeto JSON directamente del servicio Angular
    if(isset($data) && count($data) > 0) {

        // Validación básica (puedes añadir más validaciones según necesidad)
        if(!isset($data['sucursal']) || !isset($data['codigo_mov']) || !isset($data['fecha_mov']) || !isset($data['importe_mov']) || !isset($data['descripcion_mov']) || !isset($data['marca_cerrado']) || !isset($data['tipo_movi']) || !isset($data['caja'])) {
             $respuesta = array(
                 "error" => true,
                 "mensaje" => "Faltan campos requeridos para el movimiento de caja"
             );
             $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
             return;
         }

        // Limpiar datos antes de insertar (ej: convertir fechas si vienen como string)
        // Asumiendo que las fechas vienen en formato YYYY-MM-DD del form Angular
        foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
            if (isset($data[$dateField]) && empty($data[$dateField])) {
                 $data[$dateField] = null; // Convertir strings vacíos a NULL para la DB
            } elseif (isset($data[$dateField])) {
                // Podrías añadir validación de formato de fecha aquí si es necesario
                 //$date = DateTime::createFromFormat('Y-m-d', $data[$dateField]);
                 //if ($date === false || $date->format('Y-m-d') !== $data[$dateField]) {
                 //    // Error de formato
                 //}
            }
        }
         // Asegurar que los campos numéricos opcionales vacíos sean NULL
         foreach(['banco', 'num_cheque', 'cuenta_mov', 'cliente', 'proveedor', 'codigo_mbco', 'punto_venta', 'numero_comprobante'] as $numField) {
             if (isset($data[$numField]) && $data[$numField] === '') {
                  $data[$numField] = null;
             }
         }
         // Asegurar que los campos string opcionales vacíos sean NULL o string vacío según prefieras
         foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
              if (isset($data[$strField]) && $data[$strField] === '') {
                   $data[$strField] = null; // O mantener como '' si la DB lo permite/prefiere
              }
         }

        // Generar descripción automática si tipo_movi es 'A'
        if (isset($data['tipo_movi']) && $data['tipo_movi'] === 'A') {
            $data['descripcion_mov'] = $this->generarDescripcionAutomatica($data);
        }

        $this->db->trans_start(); // Iniciar transacción

        $this->db->insert('caja_movi', $data); // Insertar los datos recibidos

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Completar transacción

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Devuelve el número de filas afectadas (debería ser 1)
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}



public function SubirDatosCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validación básica (puedes añadir más según necesidad)
        if(!isset($data['descripcion']) || !isset($data['fecha_cierre']) || !isset($data['especial']) || !isset($data['fija'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (descripcion, fecha_cierre, especial, fija)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        // Preparar datos para insertar
        $insert_data = array(
            'descripcion' => trim($data['descripcion']),
            'fecha_cierre' => $data['fecha_cierre'], // Asume que el formato es compatible con 'date' de PGSQL
            'especial' => (int)$data['especial'], // Asegurar que sea entero (0 o 1)
            'fija' => (int)$data['fija']          // Asegurar que sea entero (0 o 1)
        );

        $this->db->trans_start();
        $this->db->insert('caja_lista', $insert_data);
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta, REST_Controller::HTTP_CREATED); // Opcional: HTTP Status 201
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosConflista_post()
{
    try {
        $data = $this->post();
        if (!isset($data) || count($data) === 0) {
            $respuesta = [
                "error"   => true,
                "mensaje" => "No se recibieron datos en el POST"
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
        // Validar campo obligatorio
        if (!isset($data['listap'])) {
            $respuesta = [
                "error"   => true,
                "mensaje" => "Faltan campos requeridos (listap)"
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $listap     = $data['listap'];
        $tipomone   = isset($data['tipomone'])   ? $data['tipomone']   : 0;
        $preciof21  = isset($data['preciof21'])  ? (float)$data['preciof21']  : 0;
        $preciof105 = isset($data['preciof105']) ? (float)$data['preciof105'] : 0;

        // Diagnóstico
        $diagnostico = [
            'parametros_recibidos' => [
                'listap'     => $listap,
                'tipomone'   => $tipomone,
                'preciof21'  => $preciof21,
                'preciof105' => $preciof105
            ],
            'verificaciones' => []
        ];

        // Cuántos productos hay con ese tipo de moneda
        $this->db->select('COUNT(*) as total');
        $this->db->where('tipo_moneda', $tipomone);
        $query_tipo_moneda = $this->db->get('artsucursal');
        $diagnostico['verificaciones']['productos_con_tipo_moneda']
            = $query_tipo_moneda->row()->total;

        // Resultados que devolveremos
        $resultados = [
            'conflista_creada'         => false,
            'productos_actualizados_21'  => 0,
            'productos_actualizados_105' => 0
        ];

        $this->db->trans_start();

        // Insertar la nueva conflista
        $this->db->insert('conf_lista', [
            'listap'     => $listap,
            'activa'     => isset($data['activa'])     ? $data['activa']     : false,
            'precosto21' => isset($data['precosto21']) ? $data['precosto21'] : 0,
            'precosto105'=> isset($data['precosto105'])? $data['precosto105']: 0,
            'pordcto'    => isset($data['pordcto'])    ? $data['pordcto']    : 0,
            'margen'     => isset($data['margen'])     ? $data['margen']     : 0,
            'preciof21'  => $preciof21,
            'preciof105' => $preciof105,
            'rmargen'    => isset($data['rmargen'])    ? $data['rmargen']    : false,
            'tipomone'   => $tipomone,
            'actprov'    => isset($data['actprov'])    ? $data['actprov']    : false,
            'cod_marca'  => isset($data['cod_marca'])  ? $data['cod_marca']  : '',
            'fecha'      => isset($data['fecha'])      ? $data['fecha']      : date('Y-m-d')
        ]);
        $conflista_id = $this->db->insert_id();
        $resultados['conflista_creada'] = true;
        $resultados['id_conflista']     = $conflista_id;

        // Nombre del campo de precio dinámico
        $campo_precio = 'prefi' . $listap;
        $diagnostico['verificaciones']['campo_precio'] = $campo_precio;
        // Verificar existencia del campo
        $sql_check = "
            SELECT column_name
              FROM information_schema.columns
             WHERE table_name = 'artsucursal'
               AND column_name = ?
        ";
        $query_check = $this->db->query($sql_check, [$campo_precio]);
        $campo_existe = $query_check->num_rows() > 0;
        $diagnostico['verificaciones']['campo_existe'] = $campo_existe;

        if (!$campo_existe) {
            $diagnostico['verificaciones']['advertencia']
                = "El campo {$campo_precio} no existe en artsucursal";
            $this->db->trans_complete();

            $respuesta = [
                "error"      => false,
                "mensaje"    => "Lista creada pero no se actualizaron precios porque el campo {$campo_precio} no existe",
                "resultados" => $resultados,
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta);
            return;
        }

        //
        // === BLOQUE IVA 21% ===
        //
        $diagnostico['iva21_info'] = [];

        $this->db->select('cod_iva');
        $this->db->where("ROUND(CAST(alicuota1 AS numeric),2) =", 21.00);
        $query_iva21 = $this->db->get('artiva');

        $diagnostico['iva21_info']['registros_encontrados'] = $query_iva21->num_rows();

        if ($query_iva21->num_rows() > 0) {
            $iva21_records = [];
            foreach ($query_iva21->result() as $row) {
                $iva21_records[] = $row->cod_iva;
            }
            $diagnostico['iva21_info']['cod_iva_valores'] = $iva21_records;

            if (!empty($iva21_records)) {
                $factor21 = 1 + ($preciof21 / 100);
                $diagnostico['iva21_info']['factor'] = $factor21;

                // Contar productos elegibles con idart = 0
                $this->db->where_in('cod_iva', $iva21_records);
                $this->db->where('tipo_moneda', $tipomone);
                $this->db->where('idart', 0);
                $count_query = $this->db->get('artsucursal');
                $diagnostico['iva21_info']['productos_elegibles']
                    = $count_query->num_rows();

                if ($count_query->num_rows() > 0) {
                    $rows_affected = 0;
                    foreach ($iva21_records as $iva_code) {
                        $sql_update = "
                            UPDATE artsucursal
                               SET {$campo_precio} = precon * ?
                             WHERE cod_iva     = ?
                               AND tipo_moneda = ?
                               AND idart        = 0
                        ";
                        $this->db->query($sql_update, [
                            $factor21,
                            $iva_code,
                            $tipomone
                        ]);
                        $rows_affected += $this->db->affected_rows();
                    }
                    $resultados['productos_actualizados_21'] = $rows_affected;
                    $diagnostico['iva21_info']['productos_actualizados'] = $rows_affected;
                }
            }
        }

        //
        // === BLOQUE IVA 10.5% ===
        //
        $diagnostico['iva105_info'] = [];

        $this->db->select('cod_iva');
        $this->db->where("ROUND(CAST(alicuota1 AS numeric),2) =", 10.50);
        $query_iva105 = $this->db->get('artiva');

        $diagnostico['iva105_info']['registros_encontrados'] = $query_iva105->num_rows();

        if ($query_iva105->num_rows() > 0) {
            $iva105_records = [];
            foreach ($query_iva105->result() as $row) {
                $iva105_records[] = $row->cod_iva;
            }
            $diagnostico['iva105_info']['cod_iva_valores'] = $iva105_records;

            if (!empty($iva105_records)) {
                $factor105 = 1 + ($preciof105 / 100);
                $diagnostico['iva105_info']['factor'] = $factor105;

                // Contar productos elegibles con idart = 0
                $this->db->where_in('cod_iva', $iva105_records);
                $this->db->where('tipo_moneda', $tipomone);
                $this->db->where('idart', 0);
                $count_query = $this->db->get('artsucursal');
                $diagnostico['iva105_info']['productos_elegibles']
                    = $count_query->num_rows();

                if ($count_query->num_rows() > 0) {
                    $rows_affected = 0;
                    foreach ($iva105_records as $iva_code) {
                        $sql_update = "
                            UPDATE artsucursal
                               SET {$campo_precio} = precon * ?
                             WHERE cod_iva     = ?
                               AND tipo_moneda = ?
                               AND idart        = 0
                        ";
                        $this->db->query($sql_update, [
                            $factor105,
                            $iva_code,
                            $tipomone
                        ]);
                        $rows_affected += $this->db->affected_rows();
                    }
                    $resultados['productos_actualizados_105'] = $rows_affected;
                    $diagnostico['iva105_info']['productos_actualizados'] = $rows_affected;
                }
            }
        }

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = [
                "error"      => true,
                "mensaje"    => "Error al procesar la operación",
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = [
                "error"      => false,
                "mensaje"    => "Operación completada exitosamente",
                "resultados" => $resultados,
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta);
        }
    } catch (Exception $e) {
        $respuesta = [
            "error"   => true,
            "mensaje" => "Error en el servidor: " . $e->getMessage(),
            "file"    => $e->getFile(),
            "line"    => $e->getLine()
        ];
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

public function UpdateCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validación básica
        if(!isset($data['id_caja']) || !isset($data['descripcion']) || !isset($data['fecha_cierre']) || !isset($data['especial']) || !isset($data['fija'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (id_caja, descripcion, fecha_cierre, especial, fija)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = (int)$data['id_caja'];

        // Preparar datos para actualizar
        $update_data = array(
            'descripcion' => trim($data['descripcion']),
            'fecha_cierre' => $data['fecha_cierre'],
            'especial' => (int)$data['especial'],
            'fija' => (int)$data['fija']
        );

        $this->db->trans_start();
        $this->db->where('id_caja', $id);
        $this->db->update('caja_lista', $update_data);
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             // Incluso si no se modificó nada (rows=0), la operación fue exitosa si trans_status es TRUE
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Informa cuántas filas fueron realmente cambiadas
                // "mensaje" => "Actualización completada" // Alternativa
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_rubro_p']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (id, datos)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro_p'];
        $datos = $data['rubro'];

        // Validate datos structure
        if(!isset($datos['cod_rubro']) || !isset($datos['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "El objeto datos debe contener cod_rubro y rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start();

        // Update rubro_principal
        $this->db->where('id_rubro_p', $id);
        $this->db->update('rubro_principal', array(
            'cod_rubro' => $datos['cod_rubro'],
            'rubro' => $datos['rubro']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $datos
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_prov'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_prov'];

        $this->db->trans_start();

        // Update proveedores table with all fields
        $this->db->where('id_prov', $id);
        $this->db->update('proveedores', array(
            'cod_prov' => $data['cod_prov'],
            'nombre' => $data['nombre'],
            'direccion' => $data['direccion'],
            'codpos' => $data['codpos'],
            'localidad' => $data['localidad'],
            'telefono' => $data['telefono'],
            'cuit' => $data['cuit'],
            'contacto' => $data['contacto'],
            'rubro' => $data['rubro'],
            'cod_iva' => $data['cod_iva'],
            'ganancias' => $data['ganancias'],
            'ingbrutos' => $data['ingbrutos'],
            'email' => $data['email'],
            'www' => $data['www'],
            'cta_proveedores' => $data['cta_proveedores'],
            'fec_proceso' => $data['fec_proceso']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function UpdateRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro'];

        $this->db->trans_start();

        // Update rubros table with all fields
        $this->db->where('id_rubro', $id);
        $this->db->update('rubros', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro'],
            'numerador' => $data['numerador'],
            'modiprecio' => $data['modiprecio'],
            'modidescri' => $data['modidescri'],
            'cod_depo' => $data['cod_depo'],
            'mustuni' => $data['mustuni']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_marca'];

        $this->db->trans_start();

        // Update rubros table with all fields
        $this->db->where('id_marca', $id);
        $this->db->update('marcas', array(
            'id_marca' => $data['id_marca'],
            'cod_marca' => $data['cod_marca'],
            'marca' => $data['marca'],
            
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_moneda'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_moneda'];

        $this->db->trans_start();

        // Update tipomone table with all fields
        $this->db->where('id_moneda', $id);
        $this->db->update('tipomone', array(
            'cod_mone' => $data['cod_mone'],
            'moneda' => $data['moneda'],
            'simbolo' => $data['simbolo']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_valor'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_valor'];

        $this->db->trans_start();

        // Update valorcambio table with all fields
        $this->db->where('id_valor', $id);
        $this->db->update('valorcambio', array(
            'codmone' => $data['codmone'],
            'desvalor' => $data['desvalor'],
            'fecdesde' => $data['fecdesde'],
            'fechasta' => $data['fechasta'],
            'vcambio' => $data['vcambio']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateCajamovi_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar que el ID esté presente
        if(!isset($data['id_movimiento'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del movimiento para actualizar"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_movimiento'];
        unset($data['id_movimiento']); // No se actualiza el ID

       // Limpiar datos (similar a la inserción)
       foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
           if (isset($data[$dateField]) && empty($data[$dateField])) {
                $data[$dateField] = null;
           }
       }
       foreach(['banco', 'num_cheque', 'cuenta_mov', 'cliente', 'proveedor', 'codigo_mbco', 'punto_venta', 'numero_comprobante'] as $numField) {
             if (isset($data[$numField]) && ($data[$numField] === '' || $data[$numField] === null)) {
                  $data[$numField] = null;
             }
         }
        foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
             if (isset($data[$strField]) && $data[$strField] === '') {
                  $data[$strField] = null;
             }
        }

        $this->db->trans_start();

        $this->db->where('id_movimiento', $id);
        $this->db->update('caja_movi', $data); // Actualiza con los datos recibidos

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows, // Filas afectadas (puede ser 0 si no cambió nada, o 1)
                "datos" => $this->post() // Devuelve los datos enviados para referencia
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}



public function UpdateConflista_post()
{
    try {
        $data = $this->post();
        
        // ===================================================
        // VALIDACIONES BÁSICAS PHP (OPCIONALES - PostgreSQL LAS REPETIRÁ)
        // ===================================================
        if (!isset($data['id_conflista'])) {
            $respuesta = [
                'error' => true,
                'mensaje' => 'Falta el ID de la conflista'
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
        
        // ===================================================
        // PREPARAR PARÁMETROS PARA POSTGRESQL
        // CONVERSIÓN ADECUADA DE TIPOS BOOLEAN
        // ===================================================
        
        // Convertir valores 't'/'f' a boolean para PostgreSQL
        $activa_bool = ($data['activa'] === 't' || $data['activa'] === true || $data['activa'] === 'true') ? true : false;
        $rmargen_bool = (($data['rmargen'] ?? 'f') === 't' || ($data['rmargen'] ?? false) === true) ? true : false;
        $actprov_bool = (($data['actprov'] ?? 'f') === 't' || ($data['actprov'] ?? false) === true) ? true : false;
        
        $params = [
            (int)$data['id_conflista'],                                           // p_id_conflista
            (int)$data['listap'],                                                // p_listap
            $activa_bool,                                                        // p_activa (boolean)
            (float)($data['precosto21'] ?? 0),                                   // p_precosto21
            (float)($data['precosto105'] ?? 0),                                  // p_precosto105
            (float)($data['pordcto'] ?? 0),                                      // p_pordcto
            (float)($data['margen'] ?? 0),                                       // p_margen
            (float)($data['preciof21'] ?? 0),                                    // p_preciof21
            (float)($data['preciof105'] ?? 0),                                   // p_preciof105
            $rmargen_bool,                                                       // p_rmargen (boolean)
            (int)($data['tipomone'] ?? 1),                                       // p_tipomone
            $actprov_bool,                                                       // p_actprov (boolean)
            $data['cod_marca'] ?? '',                                            // p_cod_marca
            $data['fecha'] ?? date('Y-m-d'),                                     // p_fecha
            isset($data['recalcular_21']) && $data['recalcular_21'] ? true : false,   // p_recalcular_21
            isset($data['recalcular_105']) && $data['recalcular_105'] ? true : false  // p_recalcular_105
        ];
        
        // ===================================================
        // LLAMADA ÚNICA A POSTGRESQL - TODO ATÓMICO
        // USANDO CONSULTA DIRECTA PARA EVITAR PROBLEMAS DE CODEIGNITER
        // ===================================================
        
        // Construir la consulta SQL directamente con valores escapados
        $sql = sprintf(
            "SELECT update_conflista_con_recalculo(%d,%d,%s,%s,%s,%s,%s,%s,%s,%s,%d,%s,'%s','%s',%s,%s) as resultado",
            $params[0],  // id_conflista
            $params[1],  // listap
            $params[2] ? 'true' : 'false',  // activa
            $params[3],  // precosto21
            $params[4],  // precosto105
            $params[5],  // pordcto
            $params[6],  // margen
            $params[7],  // preciof21
            $params[8],  // preciof105
            $params[9] ? 'true' : 'false',  // rmargen
            $params[10], // tipomone
            $params[11] ? 'true' : 'false', // actprov
            $params[12], // cod_marca
            $params[13], // fecha
            $params[14] ? 'true' : 'false', // recalcular_21
            $params[15] ? 'true' : 'false'  // recalcular_105
        );
        
        // Debug de la llamada
        $debug_llamada = [
            'timestamp_llamada_php' => date('Y-m-d H:i:s'),
            'funcion_postgresql' => 'update_conflista_con_recalculo',
            'sql_generado' => $sql,
            'parametros_enviados' => [
                'id_conflista' => $params[0],
                'listap' => $params[1],
                'activa' => $params[2],
                'tipomone' => $params[10],
                'preciof21' => $params[7],
                'preciof105' => $params[8],
                'recalcular_21' => $params[14],
                'recalcular_105' => $params[15]
            ]
        ];
        
        $query = $this->db->query($sql);
        
        if (!$query) {
            throw new Exception('Error ejecutando función PostgreSQL: ' . $this->db->error()['message']);
        }
        
        $result = $query->row();
        
        if (!$result || !isset($result->resultado)) {
            throw new Exception('No se recibió respuesta válida de PostgreSQL');
        }
        
        // DEBUG: Ver exactamente qué devuelve PostgreSQL
        $raw_result = $result->resultado;
        error_log("=== DEBUG POSTGRESQL RESPONSE ===");
        error_log("Raw result: " . $raw_result);
        error_log("SQL ejecutado: " . $sql);
        
        // PostgreSQL devuelve JSON, decodificarlo
        $response = json_decode($raw_result, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new Exception('Error decodificando respuesta JSON de PostgreSQL: ' . json_last_error_msg() . '. Raw response: ' . $raw_result);
        }
        
        // Agregar información de debug de PHP
        if (isset($response['debug'])) {
            $response['debug']['llamada_php'] = $debug_llamada;
            $response['debug']['timestamp_respuesta_php'] = date('Y-m-d H:i:s');
        }
        
        // ===================================================
        // ENVIAR RESPUESTA DIRECTA DE POSTGRESQL
        // ===================================================
        $http_status = $response['error'] ? REST_Controller::HTTP_INTERNAL_SERVER_ERROR : REST_Controller::HTTP_OK;
        $this->response($response, $http_status);
        
    } catch (Exception $e) {
        // ===================================================
        // MANEJO DE ERRORES PHP (ERRORES DE COMUNICACIÓN)
        // ===================================================
        $respuesta = [
            'error' => true,
            'mensaje' => 'Error en PHP al comunicarse con PostgreSQL: ' . $e->getMessage(),
            'debug' => [
                'timestamp_error_php' => date('Y-m-d H:i:s'),
                'error_php' => $e->getMessage(),
                'archivo' => $e->getFile(),
                'linea' => $e->getLine(),
                'datos_recibidos' => $data ?? null,
                'nota' => 'Este error ocurrió en PHP, no en PostgreSQL. La función PostgreSQL puede no haberse ejecutado.'
            ]
        ];
        
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

public function UpdateArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_articulo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del artículo"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_articulo'];

        $this->db->trans_start();

        // Update articulos table with all fields
        $this->db->where('id_articulo', $id);
        $this->db->update('artsucursal', array(
            'nomart' => $data['nomart'],
            'marca' => $data['marca'],
            'precon' => $data['precon'],
            'prefi1' => $data['prefi1'],
            'prefi2' => $data['prefi2'],
            'prefi3' => $data['prefi3'],
            'prefi4' => $data['prefi4'],
            'exi1' => $data['exi1'],
            'exi2' => $data['exi2'],
            'exi3' => $data['exi3'],
            'exi4' => $data['exi4'],
            'exi5' => $data['exi5'],
            'stkmin1' => $data['stkmin1'],
            'stkmax1' => $data['stkmax1'],
            'stkprep1' => $data['stkprep1'],
            'stkmin2' => $data['stkmin2'],
            'stkmax2' => $data['stkmax2'],
            'stkprep2' => $data['stkprep2'],
            'stkmin3' => $data['stkmin3'],
            'stkmax3' => $data['stkmax3'],
            'stkprep3' => $data['stkprep3'],
            'stkmin4' => $data['stkmin4'],
            'stkmax4' => $data['stkmax4'],
            'stkprep4' => $data['stkprep4'],
            'stkmin5' => $data['stkmin5'],
            'stkmax5' => $data['stkmax5'],
            'stkprep5' => $data['stkprep5'],
            'cd_articulo' => $data['cd_articulo'],
            'cd_proveedor' => $data['cd_proveedor'],
            'cd_barra' => $data['cd_barra'],
            'idart' => $data['idart'],
            'estado' => $data['estado'],
            'rubro' => $data['rubro'],
            'articulo' => $data['articulo'],
            'cod_iva' => $data['cod_iva'],
            'prebsiva' => $data['prebsiva'],
            'precostosi' => $data['precostosi'],
            'margen' => $data['margen'],
            'descuento' => $data['descuento'],
            'cod_deposito' => $data['cod_deposito'],
            'tipo_moneda' => $data['tipo_moneda']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el artículo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar ID requerido
        if(!isset($data['id_concepto'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del concepto de caja (id_concepto)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
         // Validación básica de otros campos (se pueden añadir más)
        if(!isset($data['descripcion']) || !isset($data['tipo_concepto']) || !isset($data['fija']) || !isset($data['ingreso_egreso']) || !isset($data['id_caja']) || !isset($data['activo_inactivo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos para actualizar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_concepto'];

        $this->db->trans_start();

        // Actualizar tabla cajaconceptos
        $this->db->where('id_concepto', $id);
        $this->db->update('caja_conceptos', array(
            'descripcion' => $data['descripcion'],
            'tipo_concepto' => $data['tipo_concepto'],
            'fija' => $data['fija'],
            'ingreso_egreso' => $data['ingreso_egreso'],
            'id_caja' => $data['id_caja'],
            'activo_inactivo' => $data['activo_inactivo']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             $respuesta = array(
                "error" => false,
                "mensaje" => $rows, // Número de filas afectadas
                "datos_enviados" => $data // Opcional: devolver los datos enviados para depuración
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function SubirDatosRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_rubro']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_rubro, rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro with all fields
        $this->db->insert('rubros', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro'],
            'cod_depo' => isset($data['cod_depo']) ? $data['cod_depo'] : 0,
            'modidescri' => isset($data['modidescri']) ? $data['modidescri'] : 0,
            'modiprecio' => isset($data['modiprecio']) ? $data['modiprecio'] : 0,
            'mustuni' => isset($data['mustuni']) ? $data['mustuni'] : 0,
            'numerador' => isset($data['numerador']) ? $data['numerador'] : 0,
            'id_rubro_p' => $data['id_rubro_p']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_marca']) || !isset($data['marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_marca, marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro with all fields
        $this->db->insert('marcas', array(
            'cod_marca' => $data['cod_marca'],
            'marca' => $data['marca'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar la marca"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function historialventasxsucxcli_get()
{
    // Obtener parámetros de la URL
    $sucursal = $this->get('sucursal');
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');

    // Validaciones básicas
    if (!$sucursal || !$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parámetros requeridos: sucursal e idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar límites de paginación
    $page = max(1, $page);
    $limit = max(10, min(1000, $limit));
    $offset = ($page - 1) * $limit;

    // Construir nombre de tabla
    $tabla = "psucursal" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tabla)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tabla no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Seleccionar campos específicos incluyendo descripción de tarjeta
        $this->db->select('p.tipodoc, p.puntoventa, p.idart, p.nomart, p.fecha, p.hora, p.cantidad, p.precio, p.cod_tar, p.numerocomprobante, p.id_num, p.idcli, CASE WHEN t.tarjeta IS NOT NULL THEN t.tarjeta ELSE \'Sin definir\' END as descripcion_tarjeta');
        $this->db->from($tabla . ' p');
        $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
        
        // Filtrar por cliente
        $this->db->where('p.idcli', $idcli);

        // Aplicar búsqueda global si existe
        if ($search && trim($search) !== '') {
            $searchTerm = $this->db->escape_like_str($search);
            $this->db->group_start();
            $this->db->like('p.nomart', $searchTerm);
            $this->db->or_like('p.tipodoc', $searchTerm);
            $this->db->or_like('p.numerocomprobante', $searchTerm);
            $this->db->or_like('t.tarjeta', $searchTerm);
            $this->db->group_end();
        }

        // Aplicar filtros de columna si existen
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray)) {
                foreach ($filtersArray as $field => $filter) {
                    if (isset($filter['value']) && $filter['value'] !== '') {
                        $value = $filter['value'];
                        $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                        
                        // Mapear campos al alias correcto
                        $dbField = $field;
                        if ($field === 'descripcion_tarjeta') {
                            $dbField = 't.tarjeta';
                        } elseif (in_array($field, ['tipodoc', 'puntoventa', 'idart', 'nomart', 'fecha', 'hora', 'cantidad', 'precio', 'cod_tar', 'numerocomprobante', 'id_num', 'idcli'])) {
                            $dbField = 'p.' . $field;
                        }
                        
                        switch ($matchMode) {
                            case 'startsWith':
                                $this->db->like($dbField, $value, 'after');
                                break;
                            case 'contains':
                                $this->db->like($dbField, $value);
                                break;
                            case 'equals':
                                $this->db->where($dbField, $value);
                                break;
                            case 'gt':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'gte':
                                $this->db->where($dbField . ' >=', $value);
                                break;
                            case 'lt':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            case 'lte':
                                $this->db->where($dbField . ' <=', $value);
                                break;
                            case 'dateIs':
                                $this->db->where($dbField, $value);
                                break;
                            case 'dateAfter':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'dateBefore':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            default:
                                $this->db->like($dbField, $value);
                                break;
                        }
                    }
                }
            }
        }

        // Contar total de registros antes de aplicar límites
        $totalQuery = clone $this->db;
        $totalRegistros = $totalQuery->count_all_results('', false);

        // Aplicar ordenamiento
        if ($sortField && trim($sortField) !== '') {
            $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
            
            // Mapear campo de ordenamiento al alias correcto
            $dbSortField = $sortField;
            if ($sortField === 'descripcion_tarjeta') {
                $dbSortField = 't.tarjeta';
            } elseif (in_array($sortField, ['tipodoc', 'puntoventa', 'idart', 'nomart', 'fecha', 'hora', 'cantidad', 'precio', 'cod_tar', 'numerocomprobante', 'id_num', 'idcli'])) {
                $dbSortField = 'p.' . $sortField;
            }
            
            $this->db->order_by($dbSortField, $sortDirection);
        } else {
            // Ordenamiento por defecto: fecha y hora más recientes primero
            $this->db->order_by('p.fecha', 'DESC');
            $this->db->order_by('p.hora', 'DESC');
        }

        // Aplicar paginación
        $this->db->limit($limit, $offset);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->result_array();

        // Calcular metadatos de paginación
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros)
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene los datos completos del recibo basándose en el id_num de la venta
 * Relaciona las tablas psucursal y recibos para mostrar información completa
 */
public function obtenerDatosRecibo_get()
{
    // Obtener parámetros de la URL
    $sucursal = $this->get('sucursal');
    $idNum = $this->get('id_num');

    // Validaciones básicas
    if (!$sucursal || !$idNum) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parámetros requeridos: sucursal e id_num"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaPsucursal = "psucursal" . $sucursal;
    $tablaRecibos = "recibos" . $sucursal;

    // Verificar si las tablas existen
    if (!$this->db->table_exists($tablaPsucursal) || !$this->db->table_exists($tablaRecibos)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Las tablas requeridas no existen para la sucursal $sucursal"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Consulta para obtener datos combinados de psucursal y recibos
        $this->db->select('
            p.id_num,
            p.numerocomprobante,
            p.puntoventa,
            p.fecha as fecha_venta,
            p.hora,
            p.nomart,
            p.precio,
            p.cantidad,
            p.tipodoc,
            p.idcli,
            p.idven,
            p.cod_tar,
            p.estado,
            r.recibo,
            r.c_tipo,
            r.c_cuota,
            r.fecha as fecha_recibo,
            r.importe,
            r.usuario,
            r.observacion,
            r.cod_lugar,
            r.sesion,
            r.c_tipf,
            r.recibo_saldo,
            r.cod_sucursal,
            r.fec_proceso,
            r.bonifica,
            r.bonifica_tipo,
            r.interes,
            r.interes_tipo,
            r.recibo_asoc,
            CASE WHEN t.tarjeta IS NOT NULL THEN t.tarjeta ELSE \'Sin definir\' END as descripcion_tarjeta
        ');
        
        $this->db->from($tablaPsucursal . ' p');
        $this->db->join($tablaRecibos . ' r', 'p.id_num = r.id_fac', 'left');
        $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
        $this->db->where('p.id_num', $idNum);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->row_array();

        if (!$datos) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron datos para el id_num: $idNum"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => "Datos del recibo obtenidos exitosamente",
            "data" => $datos
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos del recibo: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene historial de ventas de la tabla factcabx (historialventas2)
 * con paginación, filtros, búsqueda y ordenamiento
 */
public function historialventas2xcli_get()
{
    // Obtener parámetros de la URL
    $sucursal = $this->get('sucursal');
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');

    // Validaciones básicas
    if (!$sucursal || !$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parámetros requeridos: sucursal e idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar límites de paginación
    $page = max(1, $page);
    $limit = max(10, min(1000, $limit));
    $offset = ($page - 1) * $limit;

    // Construir nombre de tabla
    $tabla = "factcab" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tabla)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tabla no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Seleccionar campos específicos de factcabx
        $this->db->select('
            f.cod_sucursal as sucursal,
            f.tipo,
            f.puntoventa,
            f.letra,
            f.numero_int,
            f.numero_fac,
            f.emitido,
            f.vencimiento,
            f.exento,
            f.basico,
            f.iva1,
            f.iva2,
            f.iva3,
            (f.exento + f.basico + f.iva1 + f.iva2 + f.iva3) as importe,
            COALESCE(MAX(r.bonifica), f.bonifica) as bonifica,
            COALESCE(MAX(r.bonifica_tipo), f.bonifica_tipo) as bonifica_tipo,
            COALESCE(MAX(r.interes), f.interes) as interes,
            COALESCE(MAX(r.interes_tipo), f.interes_tipo) as interes_tipo,
            f.saldo,
            f.usuario,
            f.id_num as id,
            f.cliente
        ');
        $this->db->from($tabla . ' f');
        // CORREGIDO: JOIN mejorado para evitar mezcla de datos entre clientes
        $this->db->join($tabla . ' rc', 'f.numero_fac = rc.numero_fac AND rc.tipo = \'RC\' AND f.cliente = rc.cliente', 'left');
        $this->db->join('recibos' . substr($tabla, -1) . ' r', 'rc.id_num = r.id_fac', 'left');
        $this->db->group_by('f.cod_sucursal, f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, f.saldo, f.usuario, f.id_num, f.cliente, f.bonifica, f.bonifica_tipo, f.interes, f.interes_tipo');
        
        // Filtrar por cliente
        $this->db->where('f.cliente', $idcli);
        
        // FILTRO IMPORTANTE: Excluir recibos RC de historial de ventas
        $this->aplicarFiltroSinRC('f');

        // Aplicar filtro de rango de fechas si se proporciona
        if ($fecha_desde && $fecha_hasta) {
            // Validar formato de fechas (YYYY-MM-DD)
            if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
                $this->db->where('f.emitido >=', $fecha_desde);
                $this->db->where('f.emitido <=', $fecha_hasta);
            }
        }

        // Aplicar búsqueda global si existe
        if ($search && trim($search) !== '') {
            $searchTerm = $this->db->escape_like_str($search);
            $this->db->group_start();
            $this->db->like('f.tipo', $searchTerm);
            $this->db->or_like('f.letra', $searchTerm);
            $this->db->or_like('f.numero_fac', $searchTerm);
            $this->db->or_like('f.usuario', $searchTerm);
            $this->db->group_end();
        }

        // Aplicar filtros de columna si existen
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray)) {
                foreach ($filtersArray as $field => $filter) {
                    if (isset($filter['value']) && $filter['value'] !== '') {
                        $value = $filter['value'];
                        $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                        
                        // Mapear campos al alias correcto
                        $dbField = 'f.' . $field;
                        
                        switch ($matchMode) {
                            case 'startsWith':
                                $this->db->like($dbField, $value, 'after');
                                break;
                            case 'contains':
                                $this->db->like($dbField, $value);
                                break;
                            case 'equals':
                                $this->db->where($dbField, $value);
                                break;
                            case 'gt':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'gte':
                                $this->db->where($dbField . ' >=', $value);
                                break;
                            case 'lt':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            case 'lte':
                                $this->db->where($dbField . ' <=', $value);
                                break;
                            case 'dateIs':
                                $this->db->where($dbField, $value);
                                break;
                            case 'dateAfter':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'dateBefore':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            default:
                                $this->db->like($dbField, $value);
                                break;
                        }
                    }
                }
            }
        }

        // Contar total de registros antes de aplicar límites
        $totalQuery = clone $this->db;
        $totalRegistros = $totalQuery->count_all_results('', false);

        // Aplicar ordenamiento
        if ($sortField && trim($sortField) !== '') {
            $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
            $dbSortField = 'f.' . $sortField;
            $this->db->order_by($dbSortField, $sortDirection);
        } else {
            // Ordenamiento por defecto: fecha de emisión más reciente primero
            $this->db->order_by('f.emitido', 'DESC');
        }

        // Aplicar paginación
        $this->db->limit($limit, $offset);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->result_array();

        // Calcular metadatos de paginación
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros)
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas2: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene historial de ventas GLOBAL de todas las sucursales (factcabx)
 * Solo para usuarios con rol ADMIN o SUPER
 * con paginación, filtros, búsqueda y ordenamiento
 */
public function historialventas2global_get()
{
    // Obtener parámetros de la URL
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');
    $user_role = $this->get('user_role'); // Se debe enviar desde el frontend

    // Validaciones básicas
    if (!$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Falta parámetro requerido: idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar permisos - Solo ADMIN y SUPER pueden acceder
    if (!$user_role || ($user_role !== 'admin' && $user_role !== 'super')) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Acceso denegado: Se requiere rol ADMIN o SUPER para vista global"
        );
        $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
        return;
    }

    // Validar límites de paginación
    $page = max(1, $page);
    $limit = max(10, min(500, $limit)); // Límite más conservador para vista global
    $offset = ($page - 1) * $limit;

    try {
        // Obtener lista de sucursales disponibles
        $sucursales = $this->obtenerSucursalesDisponibles();
        
        // Log para debug
        error_log("Sucursales disponibles encontradas: " . print_r($sucursales, true));
        
        if (empty($sucursales)) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron sucursales disponibles"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Construir consulta UNION manualmente para evitar problemas con CodeIgniter
        $unionQueries = array();
        foreach ($sucursales as $sucursal) {
            $tabla = "factcab" . $sucursal;
            
            // Log para debug
            error_log("Verificando tabla: " . $tabla);
            
            // Verificar si la tabla existe
            if ($this->db->table_exists($tabla)) {
                error_log("Tabla {$tabla} existe - construyendo subconsulta");
                $subQuery = $this->construirSubConsultaGlobalManual($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters);
                if ($subQuery) {
                    $unionQueries[] = $subQuery;
                    error_log("Subconsulta agregada para {$tabla}: " . substr($subQuery, 0, 100) . "...");
                }
            } else {
                error_log("Tabla {$tabla} NO existe");
            }
        }

        if (empty($unionQueries)) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron tablas de facturas disponibles"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Construir consulta final con UNION
        $unionQuery = implode(' UNION ALL ', $unionQueries);
        
        // Log de la consulta final
        error_log("Número de subconsultas UNION: " . count($unionQueries));
        error_log("Consulta UNION completa: " . $unionQuery);
        
        // Aplicar filtro de sucursal DESPUÉS del UNION si existe
        $whereClause = '';
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray) && isset($filtersArray['sucursal'])) {
                $sucursalFilter = $filtersArray['sucursal'];
                if (isset($sucursalFilter['value']) && $sucursalFilter['value'] !== '') {
                    $value = $sucursalFilter['value'];
                    $matchMode = isset($sucursalFilter['matchMode']) ? $sucursalFilter['matchMode'] : 'contains';
                    $value_escaped = $this->db->escape($value);
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape($value . '%');
                            break;
                        case 'contains':
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                        case 'equals':
                            $whereClause = " WHERE sucursal = {$value_escaped}";
                            break;
                        default:
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                    }
                    
                    error_log("Filtro de sucursal aplicado después del UNION: " . $whereClause);
                }
            }
        }
        
        // Agregar ordenamiento y paginación
        $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
        $orderField = $sortField ? $sortField : 'emitido';
        
        $finalQuery = "SELECT * FROM ({$unionQuery}) AS combined_results{$whereClause} ORDER BY {$orderField} {$sortDirection} LIMIT {$limit} OFFSET {$offset}";
        
        // Log de la consulta final
        error_log("Consulta final con paginación: " . $finalQuery);
        
        // Contar total de registros
        $countQuery = "SELECT COUNT(*) as total FROM ({$unionQuery}) AS combined_results{$whereClause}";
        $countResult = $this->db->query($countQuery)->row_array();
        $totalRegistros = $countResult['total'];

        // Log del conteo
        error_log("Total de registros encontrados: " . $totalRegistros);

        // Ejecutar consulta principal
        $query = $this->db->query($finalQuery);
        $datos = $query->result_array();
        
        // Log de resultados
        error_log("Registros devueltos: " . count($datos));

        // Calcular metadatos de paginación
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros),
                "sucursales_consultadas" => $sucursales,
                "vista" => "global"
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas global: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Construye una subconsulta para una sucursal específica
 */
private function construirSubConsultaGlobal($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters)
{
    $this->db->select('
        \'' . $sucursal . '\' as sucursal,
        tipo,
        puntoventa,
        letra,
        numero_fac,
        emitido,
        vencimiento,
        exento,
        basico,
        iva1,
        iva2,
        iva3,
        (exento + basico + iva1 + iva2 + iva3) as importe,
        saldo,
        usuario,
        id_num as id,
        cliente
    ');
    $this->db->from($tabla);
    $this->db->where('cliente', $idcli);

    // Aplicar filtro de rango de fechas si se proporciona
    if ($fecha_desde && $fecha_hasta) {
        if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
            $this->db->where('emitido >=', $fecha_desde);
            $this->db->where('emitido <=', $fecha_hasta);
        }
    }

    // Aplicar búsqueda global si existe
    if ($search && trim($search) !== '') {
        $searchTerm = $this->db->escape_like_str($search);
        $this->db->group_start();
        $this->db->like('tipo', $searchTerm);
        $this->db->or_like('letra', $searchTerm);
        $this->db->or_like('numero_fac', $searchTerm);
        $this->db->or_like('usuario', $searchTerm);
        $this->db->group_end();
    }

    // Aplicar filtros de columna si existen
    if ($filters && trim($filters) !== '') {
        $filtersArray = json_decode($filters, true);
        if ($filtersArray && is_array($filtersArray)) {
            foreach ($filtersArray as $field => $filter) {
                if (isset($filter['value']) && $filter['value'] !== '') {
                    $value = $filter['value'];
                    $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $this->db->like($field, $value, 'after');
                            break;
                        case 'contains':
                            $this->db->like($field, $value);
                            break;
                        case 'equals':
                            $this->db->where($field, $value);
                            break;
                        case 'gt':
                            $this->db->where($field . ' >', $value);
                            break;
                        case 'gte':
                            $this->db->where($field . ' >=', $value);
                            break;
                        case 'lt':
                            $this->db->where($field . ' <', $value);
                            break;
                        case 'lte':
                            $this->db->where($field . ' <=', $value);
                            break;
                        case 'dateIs':
                            $this->db->where($field, $value);
                            break;
                        case 'dateAfter':
                            $this->db->where($field . ' >', $value);
                            break;
                        case 'dateBefore':
                            $this->db->where($field . ' <', $value);
                            break;
                        default:
                            $this->db->like($field, $value);
                            break;
                    }
                }
            }
        }
    }

    return $this->db->get_compiled_select();
}

/**
 * Construye una subconsulta manual para una sucursal específica (evita problemas con CodeIgniter)
 */
private function construirSubConsultaGlobalManual($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters)
{
    // Escapar valores
    $idcli_escaped = $this->db->escape($idcli);
    $sucursal_escaped = $this->db->escape($sucursal);
    $tabla_escaped = $this->db->escape_identifiers($tabla);
    
    // Log para debug
    error_log("Construyendo subconsulta para tabla: {$tabla}, sucursal: {$sucursal}, cliente: {$idcli}");
    
    // Construir SELECT base - CORREGIDO: Agregado filtro por cliente en el JOIN
    $select = "SELECT {$sucursal_escaped} as sucursal, f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, (f.exento + f.basico + f.iva1 + f.iva2 + f.iva3) as importe, COALESCE(MAX(r.bonifica), f.bonifica) as bonifica, COALESCE(MAX(r.bonifica_tipo), f.bonifica_tipo) as bonifica_tipo, COALESCE(MAX(r.interes), f.interes) as interes, COALESCE(MAX(r.interes_tipo), f.interes_tipo) as interes_tipo, f.saldo, f.usuario, f.id_num as id, f.cliente FROM {$tabla_escaped} f LEFT JOIN {$tabla_escaped} rc ON f.numero_fac = rc.numero_fac AND rc.tipo = 'RC' AND f.cliente = rc.cliente LEFT JOIN recibos" . substr($tabla, -1) . " r ON rc.id_num = r.id_fac GROUP BY f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, f.saldo, f.usuario, f.id_num, f.cliente, f.bonifica, f.bonifica_tipo, f.interes, f.interes_tipo";
    
    // Construir WHERE
    $where = "WHERE f.cliente = {$idcli_escaped} AND f.tipo != 'RC'";
    
    // Log de la consulta base
    error_log("Consulta base para {$tabla}: {$select} {$where}");
    
    // Aplicar filtro de rango de fechas si se proporciona
    if ($fecha_desde && $fecha_hasta) {
        if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
            $fecha_desde_escaped = $this->db->escape($fecha_desde);
            $fecha_hasta_escaped = $this->db->escape($fecha_hasta);
            $where .= " AND f.emitido >= {$fecha_desde_escaped} AND f.emitido <= {$fecha_hasta_escaped}";
        }
    }
    
    // Aplicar búsqueda global si existe
    if ($search && trim($search) !== '') {
        $search_escaped = $this->db->escape('%' . $search . '%');
        $where .= " AND (f.tipo LIKE {$search_escaped} OR f.letra LIKE {$search_escaped} OR f.numero_fac::text LIKE {$search_escaped} OR f.usuario LIKE {$search_escaped})";
    }
    
    // Aplicar filtros de columna si existen (EXCLUYENDO el filtro de sucursal)
    if ($filters && trim($filters) !== '') {
        $filtersArray = json_decode($filters, true);
        if ($filtersArray && is_array($filtersArray)) {
            foreach ($filtersArray as $field => $filter) {
                // EXCLUIR el filtro de sucursal ya que es una columna virtual
                if ($field === 'sucursal') {
                    error_log("Filtro de sucursal excluido de subconsulta - se aplicará después del UNION");
                    continue;
                }
                
                if (isset($filter['value']) && $filter['value'] !== '') {
                    $value = $filter['value'];
                    $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                    $value_escaped = $this->db->escape($value);
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $where .= " AND f.{$field} LIKE " . $this->db->escape($value . '%');
                            break;
                        case 'contains':
                            $where .= " AND f.{$field} LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                        case 'equals':
                            $where .= " AND f.{$field} = {$value_escaped}";
                            break;
                        case 'gt':
                            $where .= " AND f.{$field} > {$value_escaped}";
                            break;
                        case 'gte':
                            $where .= " AND f.{$field} >= {$value_escaped}";
                            break;
                        case 'lt':
                            $where .= " AND f.{$field} < {$value_escaped}";
                            break;
                        case 'lte':
                            $where .= " AND f.{$field} <= {$value_escaped}";
                            break;
                        case 'dateIs':
                            $where .= " AND f.{$field} = {$value_escaped}";
                            break;
                        case 'dateAfter':
                            $where .= " AND f.{$field} > {$value_escaped}";
                            break;
                        case 'dateBefore':
                            $where .= " AND f.{$field} < {$value_escaped}";
                            break;
                        default:
                            $where .= " AND f.{$field} LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                    }
                }
            }
        }
    }
    
    return $select . ' ' . $where;
}

/**
 * Obtiene lista de sucursales disponibles
 */
private function obtenerSucursalesDisponibles()
{
    // Buscar tablas factcab* en la base de datos
    $tables = $this->db->list_tables();
    $sucursales = array();
    
    error_log("Todas las tablas en la base de datos: " . print_r($tables, true));
    
    foreach ($tables as $table) {
        if (strpos($table, 'factcab') === 0 && strlen($table) > 7) {
            $sucursal = substr($table, 7); // Extraer número de sucursal
            if (is_numeric($sucursal)) {
                $sucursales[] = $sucursal;
                error_log("Sucursal detectada: " . $sucursal . " de tabla: " . $table);
            }
        }
    }
    
    // También intentar con un rango fijo para asegurar cobertura
    for ($i = 1; $i <= 10; $i++) {
        $tabla = "factcab" . $i;
        if ($this->db->table_exists($tabla) && !in_array($i, $sucursales)) {
            $sucursales[] = $i;
            error_log("Sucursal adicional detectada: " . $i);
        }
    }
    
    sort($sucursales); // Ordenar sucursales
    error_log("Sucursales finales: " . print_r($sucursales, true));
    return $sucursales;
}

/**
 * Endpoint de prueba para verificar sucursales disponibles
 */
public function test_sucursales_disponibles_get()
{
    $sucursales = $this->obtenerSucursalesDisponibles();
    
    $respuesta = array(
        "error" => false,
        "mensaje" => array(
            "sucursales_detectadas" => $sucursales,
            "total_sucursales" => count($sucursales)
        )
    );
    
    $this->response($respuesta);
}

/**
 * Endpoint de prueba para verificar datos por sucursal
 */
public function test_datos_por_sucursal_get()
{
    $idcli = $this->get('idcli');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');
    
    if (!$idcli || !$fecha_desde || !$fecha_hasta) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parámetros: idcli, fecha_desde, fecha_hasta"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }
    
    $sucursales = $this->obtenerSucursalesDisponibles();
    $resultados = array();
    
    foreach ($sucursales as $sucursal) {
        $tabla = "factcab" . $sucursal;
        
        if ($this->db->table_exists($tabla)) {
            $query = "SELECT COUNT(*) as total FROM {$tabla} WHERE cliente = {$this->db->escape($idcli)} AND emitido >= {$this->db->escape($fecha_desde)} AND emitido <= {$this->db->escape($fecha_hasta)}";
            $result = $this->db->query($query)->row_array();
            
            $resultados[] = array(
                "sucursal" => $sucursal,
                "tabla" => $tabla,
                "registros" => $result['total']
            );
        }
    }
    
    $respuesta = array(
        "error" => false,
        "mensaje" => array(
            "cliente" => $idcli,
            "fecha_desde" => $fecha_desde,
            "fecha_hasta" => $fecha_hasta,
            "resultados_por_sucursal" => $resultados
        )
    );
    
    $this->response($respuesta);
}

/**
 * Obtiene los datos completos del recibo basándose en el id de factcabx
 * para historialventas2
 */
public function obtenerDatosRecibo2_get()
{
    // Obtener parámetros de la URL
    $sucursal = $this->get('sucursal');
    $id = $this->get('id');

    // Validaciones básicas
    if (!$sucursal || !$id) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parámetros requeridos: sucursal e id"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaFactcab = "factcab" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tablaFactcab)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tablaFactcab no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Consultar datos completos de factcabx
        $this->db->select('*');
        $this->db->from($tablaFactcab);
        $this->db->where('id', $id);
        $query = $this->db->get();
        
        if ($query->num_rows() > 0) {
            $datos = $query->row_array();
            
            // Calcular importe total
            $excento = floatval($datos['excento']) ?: 0;
            $basico = floatval($datos['basico']) ?: 0;
            $iva1 = floatval($datos['iva1']) ?: 0;
            $iva2 = floatval($datos['iva2']) ?: 0;
            $iva3 = floatval($datos['iva3']) ?: 0;
            $datos['importe_total'] = $excento + $basico + $iva1 + $iva2 + $iva3;
            
            $respuesta = array(
                "error" => false,
                "mensaje" => "Datos del recibo obtenidos exitosamente",
                "data" => $datos
            );
        } else {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron datos para el recibo con ID: $id"
            );
        }

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos del recibo2: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene datos expandidos (recibos y psucursal) para una factura específica
 * según las relaciones definidas en el diagrama DBML
 */
public function obtenerDatosExpandidos_get()
{
    // Obtener parámetros de la URL
    $sucursal = $this->get('sucursal');
    $id_factura = $this->get('id_factura');

    // Validaciones básicas
    if (!$sucursal || !$id_factura) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parámetros requeridos: sucursal e id_factura"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaFactcab = "factcab" . $sucursal;
    $tablaRecibos = "recibos" . $sucursal;
    $tablaPsucursal = "psucursal" . $sucursal;

    // Verificar si las tablas existen
    if (!$this->db->table_exists($tablaFactcab) || !$this->db->table_exists($tablaRecibos) || !$this->db->table_exists($tablaPsucursal)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Una o más tablas no existen para la sucursal: $sucursal"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Obtener datos de recibos asociados a la factura
        // CORREGIDO: Usar cliente en lugar de numero_fac para evitar mezcla de datos
        
        // Primero obtener la factura para conseguir cliente y numero_fac
        $this->db->select('numero_fac, cliente');
        $this->db->from($tablaFactcab);
        $this->db->where('id_num', $id_factura);
        $queryFactura = $this->db->get();
        $factura = $queryFactura->row_array();
        
        if (!$factura) {
            throw new Exception("Factura no encontrada con id_num: $id_factura");
        }
        
        $numero_fac = $factura['numero_fac'];
        $cliente_id = $factura['cliente'];
        
        // Consulta UNION CORREGIDA para obtener recibos directos + recibos RC relacionados
        // CAMBIO CRÍTICO: Agregado filtro por cliente para evitar mezcla de datos entre clientes
        $query = "
            (
                SELECT 
                    r.recibo, r.c_tipo, r.c_numero, r.c_cuota, r.fecha, r.importe, 
                    r.usuario, r.observacion, r.cod_lugar, r.sesion, r.c_tipf, 
                    r.c_puntoventa, r.recibo_asoc, r.recibo_saldo, r.cod_sucursal,
                    r.fec_proceso, r.bonifica, r.bonifica_tipo, r.interes, r.interes_tipo, 
                    r.id_fac, 'DIRECTO' as origen
                FROM {$tablaRecibos} r
                WHERE r.id_fac = {$id_factura}
            )
            UNION ALL
            (
                SELECT 
                    r.recibo, r.c_tipo, r.c_numero, r.c_cuota, r.fecha, r.importe, 
                    r.usuario, r.observacion, r.cod_lugar, r.sesion, r.c_tipf, 
                    r.c_puntoventa, r.recibo_asoc, r.recibo_saldo, r.cod_sucursal,
                    r.fec_proceso, r.bonifica, r.bonifica_tipo, r.interes, r.interes_tipo, 
                    r.id_fac, 'RC' as origen
                FROM {$tablaRecibos} r
                INNER JOIN {$tablaFactcab} f ON r.id_fac = f.id_num
                WHERE r.recibo_asoc = {$id_factura} AND f.tipo = 'RC'
            )
            ORDER BY fecha DESC
        ";
        
        $queryRecibos = $this->db->query($query);
        $recibos = $queryRecibos->result_array();

        // NUEVO: Obtener historial de pagos de la factura (solo pagos reales RC)
        // CORREGIDO: Agregado filtro por cliente para evitar mezcla de datos
        $this->db->select('
            r.recibo,
            r.c_tipo,
            r.c_numero,
            r.fecha,
            r.importe,
            r.usuario,
            r.c_puntoventa,
            f.tipo as tipo_documento
        ');
        $this->db->from($tablaRecibos . ' r');
        $this->db->join($tablaFactcab . ' f', 'r.id_fac = f.id_num', 'left');
        $this->db->where('r.recibo_asoc', $id_factura);
        $this->db->where('f.tipo', 'RC');  // Filtrar solo pagos reales (Recibos de Cobro)
        $this->db->where('f.cliente', $cliente_id);  // CRÍTICO: Filtrar por cliente del documento original
        $this->db->order_by('r.fecha', 'ASC');
        $queryPagos = $this->db->get();
        $pagos = $queryPagos->result_array();

        // Calcular total pagado
        $total_pagado = 0;
        foreach ($pagos as $pago) {
            $total_pagado += (float)$pago['importe'];
        }

        // ELIMINADO: Consulta duplicada ya no necesaria - el cliente_id se obtiene al principio

        // Para cada recibo, obtener sus productos específicos
        foreach ($recibos as $index => $recibo) {
            // Debug: log de los valores que estamos buscando
            error_log("Buscando productos para recibo: " . $recibo['recibo'] . 
                     " - recibo_asoc: " . $recibo['recibo_asoc'] . 
                     " - cliente_id: " . $cliente_id);
            $this->db->select('
                p.idart,
                p.cantidad,
                p.precio,
                p.idcli,
                p.idven,
                p.fecha,
                p.hora,
                p.tipoprecio,
                p.cod_tar,
                t.tarjeta,
                p.titulartar,
                p.numerotar,
                p.cod_mov,
                p.suc_destino,
                p.nomart,
                p.nautotar,
                p.dni_tar,
                p.banco,
                p.ncuenta,
                p.ncheque,
                p.nombre,
                p.plaza,
                p.importeimputar,
                p.importecheque,
                p.fechacheque,
                p.emailop,
                p.tipodoc,
                p.puntoventa,
                p.numerocomprobante,
                p.estado,
                p.id_num
            ');
            $this->db->from($tablaPsucursal . ' p');
            $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
            $this->db->where('p.id_num', $recibo['recibo_asoc']);
            if ($cliente_id) {
                $this->db->where('p.idcli', trim($cliente_id));
            }
            $this->db->order_by('p.fecha', 'DESC');
            $this->db->order_by('p.hora', 'DESC');
            
            $queryProductos = $this->db->get();
            $productos = $queryProductos->result_array();
            
            // Debug: log del resultado
            error_log("Productos encontrados para recibo " . $recibo['recibo'] . ": " . count($productos));
            if (count($productos) > 0) {
                error_log("Primer producto: " . json_encode($productos[0]));
            }
            
            // Agregar productos al recibo
            $recibos[$index]['productos'] = $productos;
        }

        // Preparar respuesta con datos expandidos incluyendo historial de pagos
        $datosExpandidos = array(
            'recibos' => $recibos,
            'historialPagos' => $pagos,
            'totalPagado' => $total_pagado
        );

        $respuesta = array(
            "error" => false,
            "mensaje" => "Datos expandidos obtenidos exitosamente",
            "data" => $datosExpandidos
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos expandidos: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Genera una descripción automática para movimientos de caja tipo 'A'
 * basada en el patrón: tipo_comprobante + numero_comprobante + Rec. Nº + numero_recibo
 */
private function generarDescripcionAutomatica($data) {
    $tipo_comprobante = isset($data['tipo_comprobante']) ? $data['tipo_comprobante'] : '';
    $numero_comprobante = isset($data['numero_comprobante']) ? $data['numero_comprobante'] : '';
    $num_operacion = isset($data['num_operacion']) ? $data['num_operacion'] : '';
    
    // Si no hay datos suficientes, usar descripción por defecto
    if (empty($tipo_comprobante) && empty($numero_comprobante)) {
        return 'Movimiento automático';
    }
    
    // Formato: "FC     21 Rec. Nº 100000"
    $descripcion = '';
    
    if (!empty($tipo_comprobante)) {
        $descripcion .= $tipo_comprobante;
    }
    
    if (!empty($numero_comprobante)) {
        // Agregar espacios para formato consistente (ajustar según necesidad)
        $descripcion .= str_repeat(' ', max(1, 6 - strlen($tipo_comprobante))) . $numero_comprobante;
    }
    
    if (!empty($num_operacion)) {
        $descripcion .= ' Rec. Nº ' . $num_operacion;
    }
    
    // Asegurar que la descripción no exceda 80 caracteres (límite del campo)
    return substr($descripcion, 0, 80);
}

/**
 * Valida que una fecha tenga el formato YYYY-MM-DD
 */
private function validarFormatoFecha($fecha) {
    // Verificar formato básico con regex
    if (!preg_match('/^\d{4}-\d{2}-\d{2}$/', $fecha)) {
        return false;
    }
    
    // Verificar que sea una fecha válida
    $parts = explode('-', $fecha);
    return checkdate((int)$parts[1], (int)$parts[2], (int)$parts[0]);
}

// ==================== MÉTODO PARA CAMBIO MASIVO DE PRECIOS ====================

public function PriceUpdate_post()
{
    try {
        $data = $this->post();
        
        // Validar datos requeridos
        if (!isset($data['tipo_modificacion']) || !isset($data['porcentaje'])) {
            $this->response([
                'error' => true,
                'mensaje' => 'Faltan parámetros requeridos: tipo_modificacion, porcentaje'
            ], 400);
            return;
        }
        
        // Preparar parámetros
        $marca = isset($data['marca']) ? $data['marca'] : null;
        $cd_proveedor = isset($data['cd_proveedor']) ? intval($data['cd_proveedor']) : null;
        $rubro = isset($data['rubro']) ? $data['rubro'] : null;
        $cod_iva = isset($data['cod_iva']) ? intval($data['cod_iva']) : null;
        $tipo_modificacion = $data['tipo_modificacion'];
        $porcentaje = floatval($data['porcentaje']);
        $sucursal = isset($data['sucursal']) ? intval($data['sucursal']) : 1;
        $observacion = isset($data['observacion']) ? $data['observacion'] : 'Cambio masivo desde aplicación web';
        $usuario = isset($data['usuario']) && !empty($data['usuario']) 
            ? $data['usuario'] 
            : 'usuario_desconocido';
        
        // Construir descripción inteligente para auditoría
        $tipo_descriptivo = "ACTUALIZACIÓN POR ";
        
        if (!empty($marca)) {
            $tipo_descriptivo .= "MARCA (" . trim($marca) . ") Y ";
        } elseif (!empty($rubro)) {
            $tipo_descriptivo .= "RUBRO (" . trim($rubro) . ") Y ";
        } elseif (!empty($cd_proveedor)) {
            $tipo_descriptivo .= "PROVEEDOR (" . $cd_proveedor . ") Y ";
        } elseif (!empty($cod_iva)) {
            $tipo_descriptivo .= "TIPO IVA (" . $cod_iva . ") Y ";
        } else {
            $tipo_descriptivo .= "FILTRO MÚLTIPLE Y ";
        }
        
        $tipo_descriptivo .= strtoupper($tipo_modificacion);
        
        // Iniciar transacción
        $this->db->trans_begin();
        
        // ✅ NUEVO: Detectar si usar función atómica o clásica
        $use_atomic = isset($data['atomic']) && $data['atomic'] === true;
        
        if ($use_atomic) {
            // Llamar a la función ATÓMICA que actualiza precios Y conflistas
            $sql = "SELECT update_precios_masivo_atomico(?, ?, ?, ?, ?, ?, ?, ?) as result";
            $params = array(
                $marca, 
                $cd_proveedor, 
                $rubro, 
                $cod_iva, 
                $tipo_descriptivo,  // Descripción inteligente incluyendo "ATOMICO"
                $porcentaje, 
                $sucursal, 
                $usuario
            );
        } else {
            // Llamar a la función CLÁSICA (compatibilidad legacy)
            $sql = "SELECT update_precios_masivo(?, ?, ?, ?, ?, ?, ?, ?) as result";
            $params = array(
                $marca, 
                $cd_proveedor, 
                $rubro, 
                $cod_iva, 
                $tipo_descriptivo,  // Descripción inteligente en lugar de tipo_modificacion
                $porcentaje, 
                $sucursal, 
                $usuario            // Sin observacion - ahora posición 8
            );
        }
        
        $query = $this->db->query($sql, $params);
        
        if ($query && $query->num_rows() > 0) {
            $row = $query->row();
            $result_json = $row->result;
            $result = json_decode($result_json, true);
            
            if ($result && $result['success']) {
                // Commit la transacción
                $this->db->trans_commit();
                
                // ✅ MEJORADO: Agregar información específica de operación atómica
                $response_data = [
                    'error' => false,
                    'result' => $result_json,
                    'atomic_operation' => $use_atomic,  // Indicar si fue operación atómica
                    'function_used' => $use_atomic ? 'update_precios_masivo_atomico' : 'update_precios_masivo'
                ];
                
                // Si fue operación atómica, agregar detalles adicionales
                if ($use_atomic && isset($result['conflistas_actualizadas'])) {
                    $response_data['conflistas_actualizadas'] = $result['conflistas_actualizadas'];
                }
                
                $this->response($response_data);
            } else {
                // Rollback en caso de error
                $this->db->trans_rollback();
                
                $error_message = isset($result['message']) ? $result['message'] : 'Error desconocido en la actualización';
                
                // ✅ MEJORADO: Respuesta de error con contexto atómico
                $error_response = [
                    'error' => true,
                    'mensaje' => $error_message,
                    'atomic_operation' => $use_atomic,
                    'rollback_executed' => true
                ];
                
                // Si fue error atómico, incluir información específica
                if ($use_atomic && isset($result['rollback_completo'])) {
                    $error_response['rollback_completo'] = $result['rollback_completo'];
                    $error_response['sqlstate'] = $result['sqlstate'] ?? null;
                }
                
                $this->response($error_response, 500);
            }
        } else {
            // Rollback en caso de error
            $this->db->trans_rollback();
            
            $this->response([
                'error' => true,
                'mensaje' => 'No se pudo ejecutar la actualización masiva de precios'
            ], 500);
        }
        
    } catch (Exception $e) {
        // Rollback en caso de excepción
        $this->db->trans_rollback();
        
        $this->response([
            'error' => true,
            'mensaje' => 'Error interno: ' . $e->getMessage()
        ], 500);
    }
}

}

