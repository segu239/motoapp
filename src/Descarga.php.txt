<?php
defined('BASEPATH') OR exit('No direct script access allowed');
require_once(APPPATH.'/libraries/REST_Controller.php');
use Restserver\libraries\REST_Controller;

class Descarga extends REST_Controller {

public function __construct()
{

header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:PUT, GET, POST, DELETE, OPTIONS");
header("Access-Control-Allow-Headers:Content-Type, Content-Length, Accept-Encoding");


/* header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS");
header("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, Authorization"); */

  parent::__construct();
  $this->load->database();
}

/**
 * FILTRO PARA EXCLUIR RECIBOS RC DE CONSULTAS DE FACTURAS
 * 
 * Los recibos RC se almacenan en factcab por dependencias tÃ©cnicas,
 * pero deben filtrarse en reportes y consultas de facturaciÃ³n.
 * 
 * @param string $tabla_alias Alias de la tabla (ej: 'f', 'factcab')
 */
private function aplicarFiltroSinRC($tabla_alias = '') {
    $prefix = $tabla_alias ? $tabla_alias . '.' : '';
    $this->db->where($prefix . 'tipo !=', 'RC');
}

/**
 * FILTRO PARA INCLUIR SOLO RECIBOS RC
 * 
 * Para consultas especÃ­ficas de recibos RC
 * 
 * @param string $tabla_alias Alias de la tabla (ej: 'f', 'factcab')
 */
private function aplicarFiltroSoloRC($tabla_alias = '') {
    $prefix = $tabla_alias ? $tabla_alias . '.' : '';
    $this->db->where($prefix . 'tipo', 'RC');
}

public function Clisucxapp_post()//Aca se procesan los envios de clientes de la app y se los inserta en las talaba clientesapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["clientes"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='clisucapp'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA


$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

   //$this->response($this->db->insert_id());
  // $this->db->insert('prueba', $jsondata);
}
public function ClisucxappWeb_post()//Aca se procesan los envios de clientes de la app y se los inserta en las talaba clientesapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["clientes"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='clisuc';//$tabla='clisuc'.$id_vend;//ESTA ES LA QUE USABA CON VARIAS TABLAS AHORA SE CAMBIO POR UNA SOLA

// âœ… VALIDACIÃ“N: Verificar si el cliente ya existe (AGREGADO FASE 4 - 2025-10-07)
$id_cli = $datos['id_cli'];

$this->db->where('id_cli', $id_cli);
$query = $this->db->get($tabla);

if($query->num_rows() > 0) {
    // âŒ Cliente duplicado detectado - retornar HTTP 409 Conflict
    $respuesta = array(
        "error" => true,
        "mensaje" => "Cliente duplicado: Ya existe un cliente con id_cli = " . $id_cli,
        "codigo" => 409
    );
    $this->response($respuesta, REST_Controller::HTTP_CONFLICT);
} else {
    // âœ… Cliente no existe - proceder con INSERT
    $this->db->insert($tabla, $datos);
    $rows = $this->db->affected_rows();

    if($rows > 0) {
        // âœ… InserciÃ³n exitosa - retornar HTTP 201 Created
        $respuesta = array(
            "error" => false,
            "mensaje" => "Cliente creado exitosamente",
            "registros_insertados" => $rows,
            "id_cli" => $id_cli
        );
        $this->response($respuesta, REST_Controller::HTTP_CREATED);
    } else {
        // âŒ Error en la inserciÃ³n - retornar HTTP 500
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al insertar el cliente en la base de datos"
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_ERROR);
    }
}
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}
}
public function UpdateClisucxapp_post()//FunciÃ³n para modificar datos de un cliente en la tabla correspondiente SE AGREGO 10/07/23
{
  $data = $this->post();
  if(isset($data) AND count($data)>0){ 
    $datos = $data['clientes']; 
    $id_vend = $data["id_vend"];
    $tabla = 'clisuc';//$tabla = 'clisuc'.$id_vend;//ESTA ES LA QUE USABA CON VARIAS TABLAS AHORA SE CAMBIO POR UNA SOLA

    if(isset($datos['idcli'])){ 
      $this->db->where('idcli', $datos['idcli']); 
      $this->db->update($tabla, $datos); 
      $rows = $this->db->affected_rows();

      $respuesta=array(
        "error"=>false,
        "mensaje"=>$rows,
		"datoscliente"=>$datos['cliente'],
		"datos"=>$datos,
		"tabla"=>$tabla
      );
      $this->response($respuesta);
    }
    else{
      $respuesta=array(
        "error"=>true,
        "mensaje"=>"No se especificÃ³ la clave de cliente"
      );
      $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
    }
  }
  else{  
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST"
    );
    $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function UpdateArtsucxapp_post()//FunciÃ³n para modificar los stocks de la lista de productos  SE AGREGO 26/12/23
{
  $data = $this->post();
  if(isset($data) AND count($data)>0){ 
    $idart = $data['idart']; 
    $exi = $data["exi"];
    $op = $data["op"];
    $tabla = 'artsucursal'; // exi es lo mismo que sucursal
    

    if(isset($idart)){
      $campo= 'exi'.$exi;
      if($op === '+')
      {
        $this->db->set($campo, "$campo + 1", FALSE);
      }
      else if ($op === '-')
      {
        $this->db->set($campo, "$campo - 1", FALSE);
      }
       
      $this->db->where('idart', $idart); 
      $this->db->update($tabla); 
      $rows = $this->db->affected_rows();

      $respuesta=array(
        "error"=>false,
        "mensaje"=>$rows,
		    "tabla"=>$tabla
      );
      $this->response($respuesta);
    }
    else{
      $respuesta=array(
        "error"=>true,
        "mensaje"=>"No se especificÃ³ la clave de cliente"
      );
      $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
    }
  }
  else{  
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST"
    );
    $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function UpdateArtsucxappManagedPHP_post()//FunciÃ³n para modificar los stocks de la lista de productos  SE AGREGO 26/12/23
{
  $data = $this->post();

  if (isset($data['result'], $data['exi']) AND is_array($data['result'])) {
    $suc = $data['exi'];
    $tabla = 'artsucursal';
    $contador = 0;
    
    foreach ($data['result'] as $item) {
      // Obtener el ID del artÃ­culo
      $id_articulo = isset($item['id_articulo']) ? $item['id_articulo'] : null;
      $cantidad = $item['cantidad']; 
      $op = $item['tipodoc'];
      $campo = "exi{$suc}";
      
      // Verificar que tenemos un ID vÃ¡lido
      if (empty($id_articulo) || $id_articulo == 0) {
        continue; // Saltar este item si no tiene ID vÃ¡lido
      }
      
      // Aumenta o disminuye el stock segÃºn el operador
      if($op === "FC" OR $op === "PR" OR $op === "ND") {
        // RESTAN STOCK: Facturas, Presupuestos y Notas de DÃ©bito
        $this->db->set($campo, "$campo - $cantidad", FALSE);
      } else if ($op === "NC" OR $op === "NV") {
        // SUMAN STOCK: Notas de CrÃ©dito y Devoluciones
        $this->db->set($campo, "$campo + $cantidad", FALSE);
      } else if ($op === "CS") {
        // NO AFECTAN STOCK: Consultas
        log_message('info', "OperaciÃ³n {$op} no afecta stock para id_articulo: {$id_articulo}");
        continue; // Saltar al siguiente item
      } else {
        // Operaciones desconocidas - log para debugging
        log_message('warning', "OperaciÃ³n desconocida {$op} para id_articulo: {$id_articulo} - no se afecta stock");
        continue; // Saltar al siguiente item
      }
      
      // Usar id_articulo como condiciÃ³n WHERE
      $this->db->where('id_articulo', $id_articulo);
      $this->db->update($tabla);
      $affected = $this->db->affected_rows();
      $contador += $affected;
      
      // Log para debugging si no se actualiza nada
      if ($affected == 0) {
        log_message('error', "No se pudo actualizar stock para id_articulo: {$id_articulo}, cantidad: {$cantidad}, op: {$op}");
      }
    }
    
    $respuesta = [
      "error" => false,
      "mensaje" => "Se actualizaron {$contador} registros",
      "tabla" => $tabla,
      "sucursal_exi" => $suc,
      "items_procesados" => count($data['result']),
      "registros_actualizados" => $contador
    ];
    $this->response($respuesta);
    
  } else {
    // Mensaje de error si faltan datos
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST o el formato no es correcto"
    );
    $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function eliminarCliente_post()
{
  $data = $this->post();
  if(isset($data) && count($data) > 0){
     $datos = $data['clientes'];
    $id_vend = $data["id_vend"];
    $tabla = 'clisuc'.$id_vend;

    if(isset($datos['idcli'])){ 
      
      $this->db->where('idcli', $datos['idcli']); 
      $this->db->delete($tabla); 
      $rows = $this->db->affected_rows();

      $respuesta = array(
        "error" => false,
        "mensaje" => $rows,
        "tabla" => $tabla
      );
      $this->response($respuesta);
    } else {
      $respuesta = array(
        "error" => true,
        "mensaje" => "No se especificÃ³ el ID del cliente"
      );
      $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
  } else {  
    $respuesta = array(
      "error" => true,
      "mensaje" => "Faltan datos en el POST"
    );
    $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function EliminarRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_rubro_p'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_rubro_p)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro_p'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_rubro_p', $id);
        $this->db->delete('rubro_principal');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_rubro', $id);
        $this->db->delete('rubros');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_marca'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_marca', $id);
        $this->db->delete('marcas');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la marca"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function EliminarArtIva_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_ariva'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_ariva'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_ariva', $id);
        $this->db->delete('artiva');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el iva"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_moneda'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_moneda)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_moneda'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_moneda', $id);
        $this->db->delete('tipomone');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_valor'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_valor)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_valor'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_valor', $id);
        $this->db->delete('valorcambio');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function EliminarProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_prov'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_prov'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_prov', $id);
        $this->db->delete('proveedores');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function EliminarConflista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_conflista'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_conflista)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_conflista'];

        $this->db->trans_start();

        // Delete from conflistas
        $this->db->where('id_conflista', $id);
        $this->db->delete('conf_lista');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la conflista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_articulo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_articulo)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_articulo'];

        $this->db->trans_start();

        // Delete from articulos
        $this->db->where('id_articulo', $id);
        $this->db->delete('artsucursal');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n
        if(!isset($data['id_caja'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_caja)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = (int)$data['id_caja'];

        $this->db->trans_start();
        $this->db->where('id_caja', $id);
        $this->db->delete('caja_lista');
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            if ($rows > 0) {
                 $respuesta = array(
                    "error" => false,
                    "mensaje" => $rows // NÃºmero de filas eliminadas
                );
                $this->response($respuesta);
            } else {
                 $respuesta = array(
                    "error" => true, // O false si prefieres indicar que no se encontrÃ³ pero no es un error del servidor
                    "mensaje" => "No se encontrÃ³ la caja lista con el ID proporcionado o ya fue eliminada"
                );
                $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND); // Opcional: HTTP Status
            }
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        if(!isset($data['id_concepto'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_concepto)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_concepto'];

        $this->db->trans_start();
        $this->db->where('id_concepto', $id);
        $this->db->delete('caja_conceptos');
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             if ($rows > 0) {
                 $respuesta = array(
                    "error" => false,
                    "mensaje" => $rows // NÃºmero de filas eliminadas
                 );
             } else {
                  $respuesta = array(
                    "error" => true, // Considerar si no encontrarlo es un error o no
                    "mensaje" => "No se encontrÃ³ el concepto de caja con el ID proporcionado."
                 );
             }
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajamovi_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar que el ID estÃ© presente
        if(!isset($data['id_movimiento'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_movimiento)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_movimiento'];

        $this->db->trans_start();

        $this->db->where('id_movimiento', $id);
        $this->db->delete('caja_movi'); // Nombre de la tabla

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             if ($rows > 0) {
                 $respuesta = array(
                     "error" => false,
                     "mensaje" => $rows // Filas afectadas (deberÃ­a ser 1)
                 );
             } else {
                  $respuesta = array(
                     "error" => true, // Considerar error si no se encontrÃ³ el ID
                     "mensaje" => "No se encontrÃ³ el movimiento con el ID especificado para eliminar."
                 );
                 // PodrÃ­as usar HTTP_NOT_FOUND aquÃ­ tambiÃ©n
                 $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
                 return;
             }
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function PedidossucxappCompleto_post() {
    $data = $this->post();
    
    // Verificar si se recibieron datos en el POST
    if (isset($data) && count($data) > 0) {
        // Extraer datos del POST
        $pedidos = isset($data["pedidos"]) ? $data["pedidos"] : null;
        $cabecera = isset($data["cabecera"]) ? $data["cabecera"] : null;
        $id_vend = isset($data["id_vend"]) ? $data["id_vend"] : null;
        $caja_movi = isset($data["caja_movi"]) ? $data["caja_movi"] : null;
        $subtotales_metodos_pago = isset($data["subtotales_metodos_pago"]) ? $data["subtotales_metodos_pago"] : null;

        // Verificar que los datos necesarios no sean nulos
        if ($pedidos && $cabecera && $id_vend) {
            $tabla = 'psucursal' . $id_vend;
            $tabla_cabecera = 'factcab' . $id_vend;

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // Validar valores numÃ©ricos para evitar desbordamientos
            // Cliente, si es numÃ©rico, verificar lÃ­mite
            if (isset($cabecera['cliente']) && is_numeric($cabecera['cliente']) && $cabecera['cliente'] > 999999) {
                $cabecera['cliente'] = substr($cabecera['cliente'], 0, 6); // Truncar a 6 dÃ­gitos
            }
            
            // Controlar otros campos numÃ©ricos que puedan causar problemas
            $numeric_fields_to_check = ['numero_int', 'numero_fac', 'anumero_com'];
            foreach ($numeric_fields_to_check as $field) {
                if (isset($cabecera[$field]) && is_numeric($cabecera[$field]) && $cabecera[$field] > 999999) {
                    $cabecera[$field] = 999999; // Limitar al mÃ¡ximo permitido
                }
            }
            
            try {
                // Insertar cabecera y obtener el id_num generado
                $this->db->set($cabecera);
                $this->db->insert($tabla_cabecera);
                if ($this->db->affected_rows() > 0) {
                    $id_num = $this->db->insert_id(); // Obtener el id_num generado
                    $contador_exitosas = $this->db->affected_rows();
                } else {
                    log_message('error', 'Error al insertar en la tabla ' . $tabla_cabecera . ': ' . json_encode($cabecera));
                    $this->db->trans_rollback();
                    $respuesta = array(
                        "error" => true,
                        "mensaje" => "Error al insertar cabecera, transacciÃ³n revertida"
                    );
                    $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                    return;
                }
            } catch (Exception $e) {
                log_message('error', 'ExcepciÃ³n al insertar en ' . $tabla_cabecera . ': ' . $e->getMessage());
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al insertar cabecera: " . $e->getMessage()
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                return;
            }

            // Insertar pedidos
            foreach ($pedidos as &$valor) {
                $valor['id_num'] = $id_num; // Asignar el id_num de la cabecera al pedido
                $this->db->insert($tabla, $valor); // valor es un objeto
                if ($this->db->affected_rows() > 0) {
                    $contador_exitosas += $this->db->affected_rows();
                } else {
                    log_message('error', 'Error al insertar en la tabla ' . $tabla . ': ' . json_encode($valor));
                }
            }
            
            // Generar recibo automÃ¡ticamente para todas las operaciones
            $this->generarReciboAutomatico($cabecera, $id_num, $id_vend);
            
            // ====================================================================
            // SOLUCIÃ“N MÃšLTIPLES CAJAS: Insertar caja_movi (soporta array o Ãºnico)
            // ====================================================================
            if ($caja_movi) {
                // Detectar si es array de movimientos o movimiento Ãºnico
                $movimientos_caja = [];

                // Verificar si es array asociativo (movimiento Ãºnico) o array indexado (mÃºltiples)
                if (isset($caja_movi[0]) && is_array($caja_movi[0])) {
                    // Es un array de movimientos
                    $movimientos_caja = $caja_movi;
                    log_message('info', 'âœ… MÃºltiples movimientos detectados: ' . count($movimientos_caja));
                } else {
                    // Es un movimiento Ãºnico (compatibilidad hacia atrÃ¡s)
                    $movimientos_caja = [$caja_movi];
                    log_message('info', 'âœ… Movimiento Ãºnico detectado (compatibilidad)');
                }

                // Array para almacenar los IDs de movimientos creados
                $ids_movimientos = [];

                // Procesar cada movimiento de caja
                foreach ($movimientos_caja as $index => $movimiento) {
                    // Asignar el id_num de la cabecera al movimiento de caja
                    $movimiento['num_operacion'] = $id_num;

                    // Limpiar campos de fecha nulos o vacÃ­os
                    foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
                        if (isset($movimiento[$dateField]) && empty($movimiento[$dateField])) {
                            $movimiento[$dateField] = null;
                        }
                    }

                    // Validar campos numÃ©ricos para prevenir desbordamientos
                    $numeric_limit_fields = [
                        'sucursal' => 999999,
                        'codigo_mov' => 9999999999,
                        'num_operacion' => 9999999999,
                        'banco' => 9999999999,
                        'num_cheque' => 9999999999,
                        'cuenta_mov' => 999999,
                        'cliente' => 9999999999,
                        'proveedor' => 9999999999,
                        'codigo_mbco' => 9999999999,
                        'punto_venta' => 9999,
                        'numero_comprobante' => 99999999
                    ];

                    foreach ($numeric_limit_fields as $field => $limit) {
                        if (isset($movimiento[$field]) && !empty($movimiento[$field])) {
                            if (is_numeric($movimiento[$field]) && $movimiento[$field] > $limit) {
                                $movimiento[$field] = $limit;
                            }
                        } else {
                            $movimiento[$field] = null;
                        }
                    }

                    // Limpiar campos de texto nulos o vacÃ­os
                    foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
                        if (isset($movimiento[$strField]) && $movimiento[$strField] === '') {
                            $movimiento[$strField] = null;
                        }
                    }

                    // Generar descripciÃ³n automÃ¡tica si tipo_movi es 'A'
                    if (isset($movimiento['tipo_movi']) && $movimiento['tipo_movi'] === 'A') {
                        $movimiento['descripcion_mov'] = $this->generarDescripcionAutomatica($movimiento);
                    }

                    try {
                        $this->db->insert('caja_movi', $movimiento);
                        if ($this->db->affected_rows() > 0) {
                            $contador_exitosas += $this->db->affected_rows();
                            $id_movimiento = $this->db->insert_id();
                            $ids_movimientos[] = $id_movimiento;

                            log_message('info', "âœ… Movimiento #{$index} insertado con ID: {$id_movimiento}, Caja: {$movimiento['caja']}, Importe: {$movimiento['importe_mov']}");
                        } else {
                            log_message('error', 'âŒ Error al insertar movimiento #' . $index . ': ' . json_encode($movimiento));
                        }
                    } catch (Exception $e) {
                        log_message('error', 'âŒ ExcepciÃ³n al insertar movimiento #' . $index . ': ' . $e->getMessage());
                    }
                }

                // ====================================================================
                // âš ï¸ FASE 2: CÃ“DIGO COMENTADO - NO SE INSERTAN DETALLES EN caja_movi_detalle
                // ====================================================================
                // MOTIVO: La tabla caja_movi_detalle es redundante con la nueva implementaciÃ³n
                // que crea movimientos separados por mÃ©todo de pago.
                // Fecha: 2025-10-21
                // Ver: eliminacion_caja_movi_detalle.md para mÃ¡s informaciÃ³n
                // ====================================================================

                log_message('info', 'âœ… FASE 2: Nueva implementaciÃ³n activa - No se insertan detalles en caja_movi_detalle');

                /*
                // ALTERNATIVA C MEJORADA: Insertar detalles vinculados a cada movimiento
                if ($subtotales_metodos_pago !== null && !empty($ids_movimientos)) {
                    try {
                        // Si hay mÃºltiples movimientos, cada uno tiene su detalle
                        if (count($ids_movimientos) > 1) {
                            log_message('info', 'ğŸ“Š Insertando detalles para ' . count($ids_movimientos) . ' movimientos');

                            // Procesar subtotales para obtener array [cod_tarj => importe]
                            $subtotales_finales = $this->procesarSubtotalesHibrido(
                                $subtotales_metodos_pago,
                                $pedidos,
                                array_sum(array_column($movimientos_caja, 'importe_mov')), // Total general
                                $ids_movimientos[0] // ID del primer movimiento (para logs)
                            );

                            // Cada movimiento corresponde a un mÃ©todo de pago
                            $index_detalle = 0;
                            foreach ($subtotales_finales as $cod_tarj => $importe_detalle) {
                                if (isset($ids_movimientos[$index_detalle])) {
                                    $id_mov = $ids_movimientos[$index_detalle];

                                    // Insertar detalle con porcentaje = 100 (cada movimiento es 100% de ese mÃ©todo)
                                    $this->insertarDetallesMetodosPago(
                                        $id_mov,
                                        [$cod_tarj => $importe_detalle],
                                        $importe_detalle // El total del movimiento es el importe del detalle
                                    );

                                    log_message('info', "âœ… Detalle insertado: Movimiento {$id_mov} â†’ cod_tarj={$cod_tarj}, importe={$importe_detalle}");
                                }
                                $index_detalle++;
                            }
                        } else {
                            // Movimiento Ãºnico: comportamiento original
                            $id_movimiento = $ids_movimientos[0];
                            $total_movimiento = isset($movimientos_caja[0]['importe_mov']) ? floatval($movimientos_caja[0]['importe_mov']) : 0;

                            $subtotales_finales = $this->procesarSubtotalesHibrido(
                                $subtotales_metodos_pago,
                                $pedidos,
                                $total_movimiento,
                                $id_movimiento
                            );

                            if (!empty($subtotales_finales)) {
                                $this->insertarDetallesMetodosPago(
                                    $id_movimiento,
                                    $subtotales_finales,
                                    $total_movimiento
                                );

                                log_message('info', "Movimiento {$id_movimiento}: Detalles de mÃ©todos de pago insertados correctamente");
                            } else {
                                log_message('warning', "Movimiento {$id_movimiento}: No se pudieron procesar los subtotales");
                            }
                        }
                    } catch (Exception $e) {
                        log_message('error', "âŒ Error al insertar detalles de movimientos: " . $e->getMessage());
                    }
                }
                */
                // ====================================================================
            }

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error, revertir la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al insertar datos, transacciÃ³n revertida"
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Respuesta exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => $contador_exitosas
                );
                $this->response($respuesta);
            }
        } else {
            // Respuesta de error por datos incompletos
            $respuesta = array(
                "error" => true,
                "mensaje" => "Datos incompletos en el POST"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    } else {
        // Respuesta de error por falta de datos en el POST
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function Pedidossucxapp_post()//Aca se procesan los envios de pedidos de la app y se los inserta en las talaba pedidosapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["pedidos"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='psucursal'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA
$contador_exitosas = 0; // Contador de inserciones exitosas
//$jsondata=json_decode($datos);
  foreach ($datos as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto
    if ($this->db->affected_rows() > 0) { // Si la inserciÃ³n fue exitosa
        $contador_exitosas += $this->db->affected_rows();
    }
  }
//$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=> $contador_exitosas//$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}

/**
 * FunciÃ³n auxiliar para generar recibo automÃ¡ticamente
 * Se ejecuta para todas las operaciones sin importar el saldo
 */
private function generarReciboAutomatico($cabecera, $id_num, $id_vend) {
    try {
        // Generar nÃºmero de recibo Ãºnico
        $numero_recibo = $this->getNextReciboNumber($id_vend);
        
        // Calcular importe total
        $importe_total = floatval($cabecera['basico']) + floatval($cabecera['iva1']);
        
        // Determinar el saldo del recibo (0 para operaciones al contado)
        $recibo_saldo = isset($cabecera['saldo']) ? floatval($cabecera['saldo']) : 0;
        
        // Preparar datos del recibo
        $recibo = array(
            'recibo' => $numero_recibo,
            'c_tipo' => 'RC',
            'c_numero' => isset($cabecera['numero_fac']) ? $cabecera['numero_fac'] : 0,
            'c_cuota' => 0,
            'fecha' => isset($cabecera['emitido']) ? $cabecera['emitido'] : date('Y-m-d'),
            'importe' => $importe_total,
            'usuario' => isset($cabecera['usuario']) ? $cabecera['usuario'] : 'sistema',
            'observacion' => 0,
            'cod_lugar' => '1',
            'sesion' => 0,
            'c_tipf' => isset($cabecera['letra']) ? $cabecera['letra'] : 'B',
            'c_puntoventa' => isset($cabecera['puntoventa']) ? $cabecera['puntoventa'] : 0,
            'recibo_asoc' => $id_num,
            'recibo_saldo' => $recibo_saldo,
            'cod_sucursal' => $id_vend,
            'fec_proceso' => date('Y-m-d'),
            'bonifica' => isset($cabecera['bonifica']) ? $cabecera['bonifica'] : 0,
            'bonifica_tipo' => isset($cabecera['bonifica_tipo']) ? $cabecera['bonifica_tipo'] : 'P',
            'interes' => isset($cabecera['interes']) ? $cabecera['interes'] : 0,
            'interes_tipo' => isset($cabecera['interes_tipo']) ? $cabecera['interes_tipo'] : 'P',
            'id_fac' => $id_num
        );
        
        // Insertar recibo en la tabla correspondiente
        $tabla_recibos = 'recibos' . $id_vend;
        $this->db->insert($tabla_recibos, $recibo);
        
        // Log del recibo generado
        log_message('info', 'Recibo generado automÃ¡ticamente: ' . $numero_recibo . ' para operaciÃ³n: ' . $id_num);
        
    } catch (Exception $e) {
        // Log del error pero no interrumpir la transacciÃ³n principal
        log_message('error', 'Error al generar recibo automÃ¡tico: ' . $e->getMessage());
    }
}

/**
 * FunciÃ³n auxiliar para obtener el siguiente nÃºmero de recibo
 */
private function getNextReciboNumber($id_vend) {
    try {
        // Obtener el Ãºltimo nÃºmero de recibo de la tabla correspondiente
        $tabla_recibos = 'recibos' . $id_vend;
        $this->db->select('MAX(CAST(recibo AS INTEGER)) as max_recibo');
        $this->db->from($tabla_recibos);
        $query = $this->db->get();
        
        if ($query->num_rows() > 0) {
            $row = $query->row();
            $max_recibo = $row->max_recibo;
            return $max_recibo ? $max_recibo + 1 : 1;
        } else {
            return 1;
        }
    } catch (Exception $e) {
        log_message('error', 'Error al obtener nÃºmero de recibo: ' . $e->getMessage());
        return 1;
    }
}

public function Mixto_post()
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["mixto"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='mixto'.$id_vend;


//$this->db->query("DELETE FROM $tabla");//PRUEBA

$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}

public function Articulossucxapp_post()//Aca se procesan los envios de pedidos de la app y se los inserta en las talaba pedidosapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["articulos"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='artsucapp'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA

$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}
public function PagoCabecera_post()
{
    $data = $this->post();

    // Verificar que los datos necesarios estÃ©n presentes
    if (!isset($data['sucursal']) || !isset($data['pagoCC'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos requeridos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $sucursal = $data['sucursal'];
    $pagoCC = $data['pagoCC'];

    // Verificar que todos los componentes necesarios de pagoCC estÃ©n presentes
    if (!isset($pagoCC['cabeceras']) || !isset($pagoCC['psucursal']) || !isset($pagoCC['cabecera']) || !isset($pagoCC['recibo'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan componentes en pagoCC"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // NUEVA VALIDACIÃ“N: Verificar que todos los documentos sean del mismo tipo
    $tiposUnicos = array();
    foreach ($pagoCC['cabeceras'] as $cabecera) {
        if (isset($cabecera['tipo']) && !in_array($cabecera['tipo'], $tiposUnicos)) {
            $tiposUnicos[] = $cabecera['tipo'];
        }
    }
    
    if (count($tiposUnicos) > 1) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se pueden procesar documentos de diferentes tipos en la misma operaciÃ³n"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }
    
    $tipoDocumento = $tiposUnicos[0] ?? 'FC';
    
    // Para presupuestos (PR), el frontend ya maneja la restricciÃ³n de efectivo
    // La informaciÃ³n del mÃ©todo de pago se almacena en 'codigo_mov' y 'caja', no en cod_tarj
    if ($tipoDocumento === 'PR') {
        // ValidaciÃ³n manejada en frontend - PR siempre usa efectivo (codTarj = "11")
        // No se requiere lÃ³gica adicional aquÃ­
    }

    // Iniciar transacciÃ³n
    $this->db->trans_start();

    $registros_afectados = array(
        'factcab' => 0,
        'psucursal' => 0,
        'recibos' => 0,
        'caja_movi' => 0  // âœ… NUEVO
    );

    $id_num_cabecera = null;

    // 1. Actualizar cabeceras en factcab<sucursal>
    foreach ($pagoCC['cabeceras'] as $cabecera) {
        if (!isset($cabecera['id_num']) || !isset($cabecera['saldo']) || !isset($cabecera['id_aso'])) {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "Datos incompletos en una cabecera"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->where('id_num', $cabecera['id_num']);
        $this->db->update('factcab' . $sucursal, array(
            'saldo' => $cabecera['saldo'],
            'id_aso' => $cabecera['id_aso'],
			'anumero_com' => $cabecera['anumero_com'],
			'atipo' => $cabecera['atipo']
        ));
        $registros_afectados['factcab'] += $this->db->affected_rows();
    }

    // 2. Insertar en psucursal<sucursal>
    $this->db->insert('psucursal' . $sucursal, $pagoCC['psucursal']);
    $registros_afectados['psucursal'] = $this->db->affected_rows();

    // 3. Insertar en factcab<sucursal> y obtener ID
    $this->db->insert('factcab' . $sucursal, $pagoCC['cabecera']);
    $registros_afectados['factcab'] += $this->db->affected_rows();
    $id_num_cabecera = $this->db->insert_id();

    // 4. Insertar en recibos<sucursal>
    foreach ($pagoCC['recibo'] as $recibo) {
        $this->db->insert('recibos' . $sucursal, $recibo);
        $registros_afectados['recibos'] += $this->db->affected_rows();
    }

    // âœ… NUEVO: 5. Insertar caja_movi (REUTILIZANDO LÃ“GICA DE PedidossucxappCompleto_post)
    if (isset($pagoCC['caja_movi']) && $pagoCC['caja_movi']) {
        $caja_movi = $pagoCC['caja_movi'];

        // Asignar el id_num generado
        $caja_movi['num_operacion'] = $id_num_cabecera;

        // Limpiar campos de fecha nulos o vacÃ­os
        foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
            if (isset($caja_movi[$dateField]) && empty($caja_movi[$dateField])) {
                $caja_movi[$dateField] = null;
            }
        }

        // Validar campos numÃ©ricos para prevenir desbordamientos
        $numeric_limit_fields = [
            'sucursal' => 999999,
            'codigo_mov' => 9999999999,
            'num_operacion' => 9999999999,
            'banco' => 9999999999,
            'num_cheque' => 9999999999,
            'cuenta_mov' => 999999,
            'cliente' => 9999999999,
            'proveedor' => 9999999999,
            'codigo_mbco' => 9999999999,
            'punto_venta' => 9999,
            'numero_comprobante' => 99999999
        ];

        foreach ($numeric_limit_fields as $field => $limit) {
            if (isset($caja_movi[$field]) && !empty($caja_movi[$field])) {
                if (is_numeric($caja_movi[$field]) && $caja_movi[$field] > $limit) {
                    $caja_movi[$field] = $limit;
                }
            } else {
                $caja_movi[$field] = null;
            }
        }

        // Limpiar campos de texto nulos o vacÃ­os
        foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
            if (isset($caja_movi[$strField]) && $caja_movi[$strField] === '') {
                $caja_movi[$strField] = null;
            }
        }

        // Generar descripciÃ³n automÃ¡tica si tipo_movi es 'A'
        if (isset($caja_movi['tipo_movi']) && $caja_movi['tipo_movi'] === 'A') {
            $caja_movi['descripcion_mov'] = $this->generarDescripcionAutomatica($caja_movi);
        }

        try {
            $this->db->insert('caja_movi', $caja_movi);
            $registros_afectados['caja_movi'] = $this->db->affected_rows();

            if ($registros_afectados['caja_movi'] > 0) {
                log_message('info', 'Movimiento de caja insertado para pago cabecera ID: ' . $id_num_cabecera);
            } else {
                log_message('error', 'Error al insertar movimiento de caja para pago ID: ' . $id_num_cabecera);
            }
        } catch (Exception $e) {
            log_message('error', 'ExcepciÃ³n al insertar en caja_movi ID ' . $id_num_cabecera . ': ' . $e->getMessage());
            // No hacer rollback, permitir que continÃºe
        }
    }

    // Completar transacciÃ³n
    $this->db->trans_complete();

    // Verificar si la transacciÃ³n fue exitosa
    if ($this->db->trans_status() === FALSE) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error en la transacciÃ³n. Se ha realizado un rollback."
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    } else {
        $respuesta = array(
            "error" => false,
            "mensaje" => "OperaciÃ³n exitosa",
            "registros_afectados" => $registros_afectados
        );
        $this->response($respuesta);
    }
}
public function PedidoItemyCab_post() {
        $data = $this->post();
        
        if(isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // ============================================================================
            // VALIDACIÃ“N DE ID_ART VÃLIDO
            // ============================================================================
            // Verificar que el id_art no sea 0 (artÃ­culo invÃ¡lido)
            if ($pedidoItem['id_art'] == 0 || $pedidoItem['id_art'] === '0' || empty($pedidoItem['id_art'])) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: ID de artÃ­culo invÃ¡lido (id_art = 0 o vacÃ­o). No se puede crear el pedido. Contacte al administrador del sistema."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            // ============================================================================
            // OBTENER TIPO DE TRANSFERENCIA (NUEVA FUNCIONALIDAD 15-NOV-2025)
            // ============================================================================
            // Tipo de transferencia:
            // - 'PULL': Solicitud de stock (sucursald solicita a sucursalh)
            // - 'PUSH': Oferta de stock (sucursald ofrece a sucursalh)
            // - NULL: Transferencias legacy (anterior a mejora 15-Nov-2025)
            $tipo_transferencia = isset($pedidoItem['tipo_transferencia']) ? $pedidoItem['tipo_transferencia'] : null;

            // Insertar en la tabla pedidoitem y obtener el ID
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado, tipo_transferencia) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                isset($pedidoItem['observacion']) ? $pedidoItem['observacion'] : '',
                $pedidoItem['estado'],
                $tipo_transferencia
            ]);
            $result = $query->row_array();
            $id_items = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso, tipo_transferencia) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : '',
                $pedidoscb['estado'],
                $id_items,
                $tipo_transferencia
            ]);
            $result = $query->row_array();
            $id_num = $result['id_num'];

            // Actualizar id_num en pedidoitem
            $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num, $id_items]);

            // ============================================================================
            // ACTUALIZACIÃ“N DE STOCK - DESHABILITADA (CORRECCIÃ“N 15-NOV-2025)
            // ============================================================================
            // âš ï¸ IMPORTANTE: EL STOCK NO SE ACTUALIZA EN ESTA FUNCIÃ“N
            //
            // PROBLEMA ORIGINAL:
            // Esta funciÃ³n se usaba tanto para SOLICITUDES como para ENVÃOS DIRECTOS,
            // causando que el stock se moviera PREMATURAMENTE al crear solicitudes.
            //
            // FLUJO CORRECTO IMPLEMENTADO:
            // 1. SOLICITUD (estado "Solicitado") - Esta funciÃ³n
            //    â””â”€> Stock: SIN CAMBIOS âœ“ (solo se crea el registro)
            //
            // 2. ENVÃO (estado "Solicitado-E") - FunciÃ³n PedidoItemyCabIdEnvio_post()
            //    â””â”€> Stock: SE MUEVE AQUÃ âœ“ (cuando el depÃ³sito envÃ­a)
            //
            // 3. RECEPCIÃ“N (estado "Recibido") - FunciÃ³n PedidoItemyCabId_post()
            //    â””â”€> Stock: SIN CAMBIOS âœ“ (solo confirma recepciÃ³n fÃ­sica)
            //
            // RAZÃ“N DE LA CORRECCIÃ“N:
            // - Las solicitudes creadas con estado "Solicitado" NO deben mover stock
            // - Solo deben registrar la solicitud para que el depÃ³sito la procese
            // - El movimiento de stock debe ocurrir SOLO cuando el depÃ³sito ENVÃA
            //
            // CÃ“DIGO ELIMINADO:
            // - Mapeo de sucursales (lÃ­neas 1632-1638)
            // - ActualizaciÃ³n de stock en destino (lÃ­neas 1644-1660)
            // - ActualizaciÃ³n de stock en origen (lÃ­neas 1662-1679)
            //
            // FUNCIONES QUE SÃ MUEVEN STOCK:
            // - PedidoItemyCabIdEnvio_post(): Mueve stock al ENVIAR (correcto)
            // - CancelarPedidoStock_post(): Revierte stock al CANCELAR enviados (correcto)
            //
            // DOCUMENTACIÃ“N:
            // Ver: estado_actual_movstock.md
            // Ver: REPARACIONES_STOCK_14NOV2025.md
            // ============================================================================

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido. La transacciÃ³n ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacciÃ³n fue exitosa
                // Mensaje dinÃ¡mico segÃºn tipo de transferencia
                $mensaje = "";
                if ($tipo_transferencia === 'PULL') {
                    $mensaje = "Solicitud creada exitosamente. Pendiente de aprobaciÃ³n.";
                } elseif ($tipo_transferencia === 'PUSH') {
                    $mensaje = "Oferta creada exitosamente. Pendiente de aceptaciÃ³n.";
                } else {
                    $mensaje = "Pedido creado exitosamente.";
                }

                $respuesta = array(
                    "error" => false,
                    "mensaje" => $mensaje,
                    "id_items" => $id_items,
                    "id_num" => $id_num,
                    "tipo_transferencia" => $tipo_transferencia
                );
                $this->response($respuesta);
            }
        } else {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }
	public function PedidoItemyCabId_post() {
       $data = $this->post();

        // Validar que los datos necesarios estÃ©n presentes en la solicitud
        if(isset($data['id_num']) && isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $id_num_parametro = $data['id_num'];
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // ============================================================================
            // VALIDACIÃ“N DE ID_ART VÃLIDO
            // ============================================================================
            // Verificar que el id_art no sea 0 (artÃ­culo invÃ¡lido)
            if ($pedidoItem['id_art'] == 0 || $pedidoItem['id_art'] === '0' || empty($pedidoItem['id_art'])) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: ID de artÃ­culo invÃ¡lido (id_art = 0 o vacÃ­o). No se puede recibir el pedido. Contacte al administrador del sistema."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            // Insertar en la tabla pedidoitem y obtener el ID (sin modificar el estado por ahora)
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                isset($pedidoItem['observacion']) ? $pedidoItem['observacion'] : '',
                  $pedidoItem['estado'] // Establecer el estado inicial del nuevo pedidoItem
            ]);
            $result = $query->row_array();
            $id_items_nuevo = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?,?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : '',
                $pedidoscb['estado'],
                $id_items_nuevo // Asociar con el nuevo id_items
            ]);
            $result = $query->row_array();
            $id_num_generado = $result['id_num'];

            // Actualizar id_num en el nuevo pedidoitem
                $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num_generado, $id_items_nuevo]);

            // ============================================================================
            // VALIDACIÃ“N DE ESTADO Y BLOQUEO PESIMISTA (PrevenciÃ³n de duplicados)
            // ============================================================================
            // Actualizar estado a "Recibido" solo en el pedidoitem existente si se proporciona id_num
            if ($id_num_parametro) {
                // SELECT FOR UPDATE NOWAIT para prevenir race conditions
                $sql_check = "SELECT id_num, estado, cantidad, id_art
                              FROM pedidoitem
                              WHERE id_num = ?
                              FOR UPDATE NOWAIT";

                try {
                    $query_check = $this->db->query($sql_check, [$id_num_parametro]);

                    if ($query_check->num_rows() === 0) {
                        $this->db->trans_rollback();
                        $respuesta = array(
                            "error" => true,
                            "mensaje" => "Pedido no encontrado",
                            "codigo" => "NOT_FOUND"
                        );
                        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
                        return;
                    }

                    $pedido_actual = $query_check->row();
                    $estado_actual = trim($pedido_actual->estado);

                    // Validar que el estado sea el esperado
                    if ($estado_actual !== 'Solicitado-E') {
                        if ($estado_actual === 'Recibido') {
                            // Ya fue recibido - operaciÃ³n duplicada
                            $this->db->trans_rollback();
                            $respuesta = array(
                                "error" => true,
                                "mensaje" => "Este pedido ya fue recibido anteriormente",
                                "codigo" => "DUPLICATE_OPERATION",
                                "estado_actual" => $estado_actual
                            );
                            $this->response($respuesta, REST_Controller::HTTP_CONFLICT); // 409
                            return;
                        } else {
                            // Estado inesperado
                            $this->db->trans_rollback();
                            $respuesta = array(
                                "error" => true,
                                "mensaje" => "El pedido no estÃ¡ en estado 'Solicitado-E'. Estado actual: " . $estado_actual,
                                "codigo" => "INVALID_STATE",
                                "estado_actual" => $estado_actual
                            );
                            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                            return;
                        }
                    }

                    // Estado vÃ¡lido - proceder con la actualizaciÃ³n
                    $this->db->query("UPDATE pedidoitem SET estado = ? WHERE id_num = ? AND estado = 'Solicitado-E'", ["Recibido", $id_num_parametro]);

                } catch (Exception $e) {
                    $this->db->trans_rollback();

                    // Verificar si es error de bloqueo
                    if (strpos($e->getMessage(), 'could not obtain lock') !== false) {
                        $respuesta = array(
                            "error" => true,
                            "mensaje" => "El pedido estÃ¡ siendo procesado por otro usuario. Por favor espere e intente nuevamente.",
                            "codigo" => "LOCK_TIMEOUT"
                        );
                        $this->response($respuesta, REST_Controller::HTTP_CONFLICT); // 409
                    } else {
                        $respuesta = array(
                            "error" => true,
                            "mensaje" => "Error al validar el pedido: " . $e->getMessage()
                        );
                        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                    }
                    return;
                }
             }

              // Actualizar estado a "Recibido" solo en pedidoscb existentes si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoscb SET estado = ? WHERE id_num = ? AND estado = 'Solicitado-E'", ["Recibido", $id_num_parametro]);
             }
            // ============================================================================

            // ============================================================================
            // ACTUALIZACIÃ“N DE STOCK EN RECEPCIÃ“N - DESHABILITADA
            // ============================================================================
            // âš ï¸ IMPORTANTE: NO SE ACTUALIZA EL STOCK AQUÃ
            //
            // RAZÃ“N: El stock YA fue actualizado en PedidoItemyCabIdEnvio_post cuando
            // la sucursal origen realizÃ³ el envÃ­o (cambiÃ³ estado a "Solicitado-E").
            //
            // Actualizar el stock nuevamente aquÃ­ causarÃ­a DUPLICACIÃ“N:
            // - Al enviar: Sucursal B pierde stock, Sucursal A gana stock âœ“
            // - Al recibir: Si actualizÃ¡ramos aquÃ­, se restarÃ­a/sumarÃ­a NUEVAMENTE âœ—
            //
            // FLUJO CORRECTO:
            // 1. Sucursal A solicita (Solicitado) - SIN cambio de stock
            // 2. Sucursal B envÃ­a (Solicitado-E) - CON cambio de stock âœ“
            // 3. Sucursal A recibe (Recibido) - SIN cambio de stock (solo confirma)
            //
            // La funciÃ³n de recepciÃ³n solo cambia el estado a "Recibido" para confirmar
            // que la mercaderÃ­a llegÃ³ fÃ­sicamente, pero el stock ya fue transferido.
            //
            // Modificado: 14/11/2025 - CorrecciÃ³n de duplicaciÃ³n de stock
            // ============================================================================

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido y actualizar estados. La transacciÃ³n ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacciÃ³n fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado y estados actualizados exitosamente",
                    "id_items_nuevo" => $id_items_nuevo,
                    "id_num_generado" => $id_num_generado
                );
                $this->response($respuesta);
            }
        } else {
            // Si faltan datos en la solicitud
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST. Se requieren 'id_num', 'pedidoItem' y 'pedidoscb'."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }
	
	public function PedidoItemyCabIdEnvio_post() {
       $data = $this->post();

        // Validar que los datos necesarios estÃ©n presentes en la solicitud
        if(isset($data['id_num']) && isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $id_num_parametro = $data['id_num'];
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // ============================================================================
            // VALIDACIÃ“N DE ID_ART VÃLIDO
            // ============================================================================
            // Verificar que el id_art no sea 0 (artÃ­culo invÃ¡lido)
            if ($pedidoItem['id_art'] == 0 || $pedidoItem['id_art'] === '0' || empty($pedidoItem['id_art'])) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: ID de artÃ­culo invÃ¡lido (id_art = 0 o vacÃ­o). No se puede procesar el envÃ­o. Contacte al administrador del sistema."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            // ============================================================================
            // VALIDACIÃ“N DE STOCK DISPONIBLE ANTES DE ENVIAR
            // ============================================================================
            // MAPEO DE FIREBASE VALUE A CAMPOS EXI
            // Firebase almacena un campo 'value' para cada sucursal que NO corresponde
            // directamente al nÃºmero del campo exi. Este mapeo traduce correctamente:
            // value 1 (Casa Central) â†’ exi2
            // value 2 (Valle Viejo)  â†’ exi3
            // value 3 (GÃ¼emes)       â†’ exi4
            // value 4 (Deposito)     â†’ exi1
            // value 5 (Mayorista)    â†’ exi5
            $mapeo_sucursal_exi = [
                1 => 'exi2', // Casa Central
                2 => 'exi3', // Valle Viejo
                3 => 'exi4', // GÃ¼emes
                4 => 'exi1', // Deposito
                5 => 'exi5'  // Mayorista
            ];

            $sucursal_origen = $pedidoscb['sucursald']; // Sucursal que envÃ­a (ORIGEN en esta funciÃ³n)
            $campo_stock_origen = isset($mapeo_sucursal_exi[$sucursal_origen])
                ? $mapeo_sucursal_exi[$sucursal_origen]
                : 'exi' . $sucursal_origen; // Fallback por seguridad

            // Consultar stock actual de la sucursal que envÃ­a
            $sql_check_stock = "SELECT $campo_stock_origen as stock_actual
                                FROM artsucursal
                                WHERE id_articulo = ?";
            $query_stock = $this->db->query($sql_check_stock, [$pedidoItem['id_art']]);

            if ($query_stock->num_rows() === 0) {
                // El artÃ­culo no existe en artsucursal
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: El artÃ­culo no existe en el catÃ¡logo."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            $row_stock = $query_stock->row_array();
            $stock_actual = $row_stock['stock_actual'];

            // NOTA: Se permite enviar stock incluso con valores negativos
            // El sistema debe permitir stocks negativos para reflejar deudas de stock
            // Por ejemplo: Si sucursal tiene -80 y envÃ­a 1, quedarÃ¡ -81
            /* VALIDACIÃ“N DESHABILITADA - Se permite stock negativo
            if ($stock_actual < $pedidoItem['cantidad']) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: Stock insuficiente en sucursal origen. Disponible: " . $stock_actual . ", Solicitado: " . $pedidoItem['cantidad']
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }
            */
            // ============================================================================

            // Insertar en la tabla pedidoitem y obtener el ID (sin modificar el estado por ahora)
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                isset($pedidoItem['observacion']) ? $pedidoItem['observacion'] : '',
                  $pedidoItem['estado'] // Establecer el estado inicial del nuevo pedidoItem
            ]);
            $result = $query->row_array();
            $id_items_nuevo = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : '',
                $pedidoscb['estado'],
                $id_items_nuevo // Asociar con el nuevo id_items
            ]);
            $result = $query->row_array();
            $id_num_generado = $result['id_num'];

            // Actualizar id_num en el nuevo pedidoitem
                $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num_generado, $id_items_nuevo]);

            // ============================================================================
            // VALIDACIÃ“N DE ESTADO Y BLOQUEO PESIMISTA (PrevenciÃ³n de duplicados)
            // ============================================================================
            // Actualizar estado a "Solicitado-E" solo en el pedidoitem existente si se proporciona id_num
            if ($id_num_parametro) {
                // SELECT FOR UPDATE NOWAIT para prevenir race conditions
                $sql_check = "SELECT id_num, estado, cantidad, id_art
                              FROM pedidoitem
                              WHERE id_num = ?
                              FOR UPDATE NOWAIT";

                try {
                    $query_check = $this->db->query($sql_check, [$id_num_parametro]);

                    if ($query_check->num_rows() === 0) {
                        $this->db->trans_rollback();
                        $respuesta = array(
                            "error" => true,
                            "mensaje" => "Pedido no encontrado",
                            "codigo" => "NOT_FOUND"
                        );
                        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
                        return;
                    }

                    $pedido_actual = $query_check->row();
                    $estado_actual = trim($pedido_actual->estado);

                    // Validar que el estado sea el esperado
                    if ($estado_actual !== 'Solicitado') {
                        if ($estado_actual === 'Solicitado-E' || $estado_actual === 'Enviado') {
                            // Ya fue enviado - operaciÃ³n duplicada
                            $this->db->trans_rollback();
                            $respuesta = array(
                                "error" => true,
                                "mensaje" => "Este pedido ya fue enviado anteriormente",
                                "codigo" => "DUPLICATE_OPERATION",
                                "estado_actual" => $estado_actual
                            );
                            $this->response($respuesta, REST_Controller::HTTP_CONFLICT); // 409
                            return;
                        } else {
                            // Estado inesperado
                            $this->db->trans_rollback();
                            $respuesta = array(
                                "error" => true,
                                "mensaje" => "El pedido no estÃ¡ en estado 'Solicitado'. Estado actual: " . $estado_actual,
                                "codigo" => "INVALID_STATE",
                                "estado_actual" => $estado_actual
                            );
                            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                            return;
                        }
                    }

                    // Estado vÃ¡lido - proceder con la actualizaciÃ³n
                    $this->db->query("UPDATE pedidoitem SET estado = ? WHERE id_num = ? AND estado = 'Solicitado'", ["Solicitado-E", $id_num_parametro]);

                } catch (Exception $e) {
                    $this->db->trans_rollback();

                    // Verificar si es error de bloqueo
                    if (strpos($e->getMessage(), 'could not obtain lock') !== false) {
                        $respuesta = array(
                            "error" => true,
                            "mensaje" => "El pedido estÃ¡ siendo procesado por otro usuario. Por favor espere e intente nuevamente.",
                            "codigo" => "LOCK_TIMEOUT"
                        );
                        $this->response($respuesta, REST_Controller::HTTP_CONFLICT); // 409
                    } else {
                        $respuesta = array(
                            "error" => true,
                            "mensaje" => "Error al validar el pedido: " . $e->getMessage()
                        );
                        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                    }
                    return;
                }
             }

              // Actualizar estado a "Solicitado-E" solo en pedidoscb existentes si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoscb SET estado = ? WHERE id_num = ? AND estado = 'Solicitado'", ["Solicitado-E", $id_num_parametro]);
             }
            // ============================================================================

            // ============================================================================
            // ACTUALIZACIÃ“N AUTOMÃTICA DE STOCK EN ENVÃO DIRECTO
            // ============================================================================
            // IMPORTANTE: En esta funciÃ³n, la semÃ¡ntica es DIFERENTE a PedidoItemyCabId_post:
            // - sucursald = ORIGEN (quien envÃ­a)
            // - sucursalh = DESTINO (quien recibe)

            // Actualizar stock en sucursal DESTINO (la que recibe - SUMA stock)
            $sucursal_destino = $pedidoscb['sucursalh']; // DESTINO en esta funciÃ³n
            $campo_stock_destino = isset($mapeo_sucursal_exi[$sucursal_destino])
                ? $mapeo_sucursal_exi[$sucursal_destino]
                : 'exi' . $sucursal_destino; // Fallback por seguridad

            $sql_update_destino = "UPDATE artsucursal
                                   SET $campo_stock_destino = $campo_stock_destino + ?
                                   WHERE id_articulo = ?";
            $this->db->query($sql_update_destino, [
                $pedidoItem['cantidad'],
                $pedidoItem['id_art']
            ]);

            // Actualizar stock en sucursal ORIGEN (la que envÃ­a - RESTA stock)
            // Nota: $sucursal_origen y $campo_stock_origen ya definidos en lÃ­neas 1853-1856
            // IMPORTANTE: Se permite stock negativo, NO validamos si hay suficiente
            $sql_update_origen = "UPDATE artsucursal
                                  SET $campo_stock_origen = $campo_stock_origen - ?
                                  WHERE id_articulo = ?";
            $this->db->query($sql_update_origen, [
                $pedidoItem['cantidad'],
                $pedidoItem['id_art']
            ]);
            // ============================================================================

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido y actualizar estados. La transacciÃ³n ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacciÃ³n fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado y estados actualizados exitosamente",
                    "id_items_nuevo" => $id_items_nuevo,
                    "id_num_generado" => $id_num_generado
                );
                $this->response($respuesta);
            }
        } else {
            // Si faltan datos en la solicitud
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST. Se requieren 'id_num', 'pedidoItem' y 'pedidoscb'."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }

/**
 * Cancela un pedido de stock (ACTUALIZADO 15-NOV-2025)
 *
 * Estados permitidos para cancelaciÃ³n:
 * - 'Solicitado': Solicitud no aceptada (PULL) - NO revierte stock
 * - 'Ofrecido': Oferta no aceptada (PUSH) - NO revierte stock
 * - 'Solicitado-E': Solicitud enviada (LEGACY) - SÃ revierte stock
 *
 * Estados NO permitidos:
 * - 'Aceptado': Usar RechazarTransferencia_post() en su lugar
 * - 'Recibido': Transferencia completada, no cancelable
 * - 'Rechazado': Ya estÃ¡ cerrado
 *
 * @param int id_num - ID del pedido a cancelar
 * @param string usuario - Usuario que cancela
 * @param string motivo_cancelacion - Motivo de la cancelaciÃ³n
 * @param date fecha_cancelacion - Fecha de cancelaciÃ³n (opcional, default: hoy)
 *
 * @return array Respuesta con resultado de la operaciÃ³n
 */
public function CancelarPedidoStock_post() {
    $data = $this->post();

    // Validar que los datos necesarios estÃ©n presentes
    if(!isset($data['id_num'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Falta el campo id_num"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    if(!isset($data['usuario']) || !isset($data['motivo_cancelacion'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos requeridos (usuario, motivo_cancelacion)"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $id_num = $data['id_num'];
    $usuario = $data['usuario'];
    $motivo_cancelacion = $data['motivo_cancelacion'];
    $fecha_cancelacion = isset($data['fecha_cancelacion']) ? $data['fecha_cancelacion'] : date('Y-m-d');

    $this->db->trans_start(); // Iniciar transacciÃ³n

    // ============================================================================
    // PASO 1: Obtener informaciÃ³n del pedido ANTES de cancelar
    // ============================================================================
    // Necesitamos saber el estado actual para determinar si hay que revertir stock
    $sql_get_pedido = "SELECT
                        pi.estado,
                        pi.id_art,
                        pi.cantidad,
                        pc.sucursald,
                        pc.sucursalh
                       FROM pedidoitem pi
                       JOIN pedidoscb pc ON pi.id_num = pc.id_num
                       WHERE pi.id_num = ?
                       FOR UPDATE"; // Bloqueo para evitar race conditions

    $query_pedido = $this->db->query($sql_get_pedido, [$id_num]);

    if ($query_pedido->num_rows() === 0) {
        $this->db->trans_rollback();
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se encontrÃ³ el pedido especificado"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    $pedido_info = $query_pedido->row();
    $estado_actual = trim($pedido_info->estado);
    $id_art = $pedido_info->id_art;
    $cantidad = $pedido_info->cantidad;
    $sucursald = $pedido_info->sucursald;
    $sucursalh = $pedido_info->sucursalh;

    // ============================================================================
    // VALIDAR ESTADO PERMITIDO PARA CANCELACIÃ“N (ACTUALIZADO 15-NOV-2025)
    // ============================================================================
    // Estados permitidos:
    // - 'Solicitado': Solicitud no aceptada aÃºn (PULL) - NO requiere reversiÃ³n de stock
    // - 'Ofrecido': Oferta no aceptada aÃºn (PUSH) - NO requiere reversiÃ³n de stock
    // - 'Solicitado-E': Solicitud enviada (LEGACY) - SÃ requiere reversiÃ³n de stock
    //
    // Estados NO permitidos:
    // - 'Aceptado': Ya se moviÃ³ el stock, usar RechazarTransferencia en su lugar
    // - 'Recibido': Transferencia completada, no se puede cancelar
    // - 'Rechazado': Ya estÃ¡ cerrado
    // - 'Cancelado': Ya estÃ¡ cancelado
    if (!in_array($estado_actual, ['Solicitado', 'Ofrecido', 'Solicitado-E'])) {
        $this->db->trans_rollback();
        $respuesta = array(
            "error" => true,
            "mensaje" => "Solo se pueden cancelar pedidos en estado 'Solicitado', 'Ofrecido' o 'Solicitado-E'. Estado actual: " . $estado_actual
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // ============================================================================
    // PASO 2: REVERSIÃ“N DE STOCK (solo si estado = "Solicitado-E")
    // ============================================================================
    // Si el pedido estÃ¡ en "Solicitado-E", significa que YA FUE ENVIADO y el stock
    // ya fue modificado en PedidoItemyCabIdEnvio_post. Debemos REVERTIR esos cambios.
    //
    // En PedidoItemyCabIdEnvio_post se hizo:
    // - RESTA stock en sucursalh (quien enviÃ³)
    // - SUMA stock en sucursald (quien iba a recibir)
    //
    // Para revertir, hacemos lo opuesto:
    // - SUMA stock en sucursalh (recupera lo que enviÃ³)
    // - RESTA stock en sucursald (pierde lo que iba a recibir)

    if ($estado_actual === 'Solicitado-E') {
        // Mapeo de sucursales a campos exi
        $mapeo_sucursal_exi = [
            1 => 'exi2', // Casa Central
            2 => 'exi3', // Valle Viejo
            3 => 'exi4', // GÃ¼emes
            4 => 'exi1', // Deposito
            5 => 'exi5'  // Mayorista
        ];

        // REVERSIÃ“N 1: SUMAR stock a sucursalh (quien enviÃ³, ahora recupera)
        $campo_stock_origen = isset($mapeo_sucursal_exi[$sucursalh])
            ? $mapeo_sucursal_exi[$sucursalh]
            : 'exi' . $sucursalh;

        $sql_revertir_origen = "UPDATE artsucursal
                                SET $campo_stock_origen = $campo_stock_origen + ?
                                WHERE id_articulo = ?";
        $this->db->query($sql_revertir_origen, [$cantidad, $id_art]);

        // REVERSIÃ“N 2: RESTAR stock a sucursald (quien iba a recibir, ahora pierde)
        $campo_stock_destino = isset($mapeo_sucursal_exi[$sucursald])
            ? $mapeo_sucursal_exi[$sucursald]
            : 'exi' . $sucursald;

        $sql_revertir_destino = "UPDATE artsucursal
                                 SET $campo_stock_destino = $campo_stock_destino - ?
                                 WHERE id_articulo = ?";
        $this->db->query($sql_revertir_destino, [$cantidad, $id_art]);

        // Log para auditorÃ­a
        error_log("REVERSIÃ“N DE STOCK - Pedido $id_num cancelado en estado Solicitado-E");
        error_log("ArtÃ­culo: $id_art, Cantidad: $cantidad");
        error_log("Sucursal origen (recupera): $sucursalh (+$cantidad)");
        error_log("Sucursal destino (pierde): $sucursald (-$cantidad)");
    }
    // Si estado = "Solicitado", NO se revierte stock porque nunca se modificÃ³

    // ============================================================================
    // PASO 3: Actualizar estado a Cancelado
    // ============================================================================

    // Actualizar estado en pedidoitem
    $this->db->query(
        "UPDATE pedidoitem
         SET estado = 'Cancelado',
             motivo_cancelacion = ?,
             fecha_cancelacion = ?,
             usuario_cancelacion = ?
         WHERE id_num = ?",
        [$motivo_cancelacion, $fecha_cancelacion, $usuario, $id_num]
    );

    $affected_rows_item = $this->db->affected_rows();

    // Actualizar estado en pedidoscb
    $this->db->query(
        "UPDATE pedidoscb
         SET estado = 'Cancelado',
             motivo_cancelacion = ?,
             fecha_cancelacion = ?,
             usuario_cancelacion = ?
         WHERE id_num = ?",
        [$motivo_cancelacion, $fecha_cancelacion, $usuario, $id_num]
    );

    $affected_rows_cb = $this->db->affected_rows();

    $this->db->trans_complete();

    if ($this->db->trans_status() === FALSE) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al cancelar el pedido. La transacciÃ³n ha sido revertida."
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    } else {
        if($affected_rows_item === 0) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se pudo cancelar el pedido. Verifique que exista y estÃ© en estado vÃ¡lido."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        } else {
            // Mensaje personalizado segÃºn si se revirtiÃ³ stock o no
            $mensaje = "Pedido cancelado exitosamente";
            if ($estado_actual === 'Solicitado-E') {
                $mensaje .= ". El stock ha sido revertido automÃ¡ticamente.";
            }

            $respuesta = array(
                "error" => false,
                "mensaje" => $mensaje,
                "estado_original" => $estado_actual,
                "stock_revertido" => ($estado_actual === 'Solicitado-E'),
                "registros_actualizados" => $affected_rows_item
            );
            $this->response($respuesta, REST_Controller::HTTP_OK);
        }
    }
}

public function SubirDatosRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_rubro']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_rubro, rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('rubro_principal', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function SubirDatosArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['nomart']) || !isset($data['marca']) || !isset($data['precon'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (nomart, marca, precon)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new articulo with all fields
        $this->db->insert('artsucursal', array(
            'nomart' => $data['nomart'],
            'marca' => $data['marca'],
            'precon' => $data['precon'],
            'prefi1' => $data['prefi1'],
            'prefi2' => $data['prefi2'],
            'prefi3' => $data['prefi3'],
            'prefi4' => $data['prefi4'],
            'exi1' => $data['exi1'],
            'exi2' => $data['exi2'],
            'exi3' => $data['exi3'],
            'exi4' => $data['exi4'],
            'exi5' => $data['exi5'],
            'stkmin1' => $data['stkmin1'],
            'stkmax1' => $data['stkmax1'],
            'stkprep1' => $data['stkprep1'],
            'stkmin2' => $data['stkmin2'],
            'stkmax2' => $data['stkmax2'],
            'stkprep2' => $data['stkprep2'],
            'stkmin3' => $data['stkmin3'],
            'stkmax3' => $data['stkmax3'],
            'stkprep3' => $data['stkprep3'],
            'stkmin4' => $data['stkmin4'],
            'stkmax4' => $data['stkmax4'],
            'stkprep4' => $data['stkprep4'],
            'stkmin5' => $data['stkmin5'],
            'stkmax5' => $data['stkmax5'],
            'stkprep5' => $data['stkprep5'],
            'cd_articulo' => $data['cd_articulo'],
            'cd_proveedor' => $data['cd_proveedor'],
            'cd_barra' => $data['cd_barra'],
            'idart' => $data['idart'],
            'estado' => $data['estado'],
            'rubro' => $data['rubro'],
            'articulo' => $data['articulo'],
            'cod_iva' => $data['cod_iva'],
            'prebsiva' => $data['prebsiva'],
            'precostosi' => $data['precostosi'],
            'margen' => $data['margen'],
            'descuento' => $data['descuento'],
            'cod_deposito' => $data['cod_deposito'],
            'tipo_moneda' => $data['tipo_moneda']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function SubirDatosTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_mone']) || !isset($data['moneda']) || !isset($data['simbolo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_mone, moneda, simbolo)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('tipomone', array(
            "cod_mone"=> $data['cod_mone'],
        "moneda"=> $data['moneda'],
        "simbolo"=> $data['simbolo'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['codmone']) || !isset($data['desvalor']) || !isset($data['vcambio'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (codmone, desvalor, vcambio)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('valorcambio', array(
            "codmone"=> $data['codmone'],
        "desvalor"=> $data['desvalor'],
        "fecdesde"=> $data['fecdesde'],
        "fechasta"=> $data['fechasta'],
        "vcambio"=> $data['vcambio'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function SubirDatosProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['nombre']) || !isset($data['cuit'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (nombre, cuit)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new provider with all fields
        $this->db->insert('proveedores', array(
            'cod_prov' => $data['cod_prov'],
            'nombre' => $data['nombre'],
            'direccion' => $data['direccion'],
            'codpos' => $data['codpos'],
            'localidad' => $data['localidad'],
            'telefono' => $data['telefono'],
            'cuit' => $data['cuit'],
            'contacto' => $data['contacto'],
            'rubro' => $data['rubro'],
            'cod_iva' => $data['cod_iva'],
            'ganancias' => $data['ganancias'],
            'ingbrutos' => $data['ingbrutos'],
            'email' => $data['email'],
            'www' => $data['www'],
            'cta_proveedores' => $data['cta_proveedores'],
            'fec_proceso' => $data['fec_proceso']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosArtIva_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_iva']) || !isset($data['descripcion'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_iva, descripcion)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new artiva record
        $this->db->insert('artiva', array(
            'cod_iva' => $data['cod_iva'],
            'descripcion' => $data['descripcion'],
            // 'desde_date' => $data['desde_date'],
           /*  'desde_date' => date('Y-m-d', strtotime($data['desde_date'])),
            'hasta_date' => $data['hasta_date'], */
    'desde' => !empty($data['desde']) ? date('Y-m-d', strtotime($data['desde'])) : null,
'hasta' => !empty($data['hasta']) ? date('Y-m-d', strtotime($data['hasta'])) : null,
            'tipo_ali_1' => $data['tipo_ali_1'],
            'alicuota1' => $data['alicuota1'],
            'tipo_ali_2' => $data['tipo_ali_2'],
            'alicuota2' => $data['alicuota2'],
            'tipo_ali_3' => $data['tipo_ali_3'],
            'alicuota3' => $data['alicuota3'],
            'cuit' => $data['cuit'] ? 't' : 'f'
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el registro de IVA"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n bÃ¡sica de campos requeridos (se pueden aÃ±adir mÃ¡s)
        if(!isset($data['descripcion']) || !isset($data['tipo_concepto']) || !isset($data['fija']) || !isset($data['ingreso_egreso']) || !isset($data['id_caja']) || !isset($data['activo_inactivo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos para el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start();

        // Insertar nuevo concepto
        $this->db->insert('caja_conceptos', array(
            'descripcion' => $data['descripcion'],
            'tipo_concepto' => $data['tipo_concepto'],
            'fija' => $data['fija'],
            'ingreso_egreso' => $data['ingreso_egreso'],
            'id_caja' => $data['id_caja'],
            'activo_inactivo' => $data['activo_inactivo']
            // 'id_concepto' es serial y se genera automÃ¡ticamente
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Indica cuÃ¡ntas filas se insertaron (deberÃ­a ser 1)
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosCajamovi_post()
{
    $data = $this->post(); // Recibe el objeto JSON directamente del servicio Angular
    if(isset($data) && count($data) > 0) {

        // ValidaciÃ³n bÃ¡sica (puedes aÃ±adir mÃ¡s validaciones segÃºn necesidad)
        if(!isset($data['sucursal']) || !isset($data['codigo_mov']) || !isset($data['fecha_mov']) || !isset($data['importe_mov']) || !isset($data['descripcion_mov']) || !isset($data['marca_cerrado']) || !isset($data['tipo_movi']) || !isset($data['caja'])) {
             $respuesta = array(
                 "error" => true,
                 "mensaje" => "Faltan campos requeridos para el movimiento de caja"
             );
             $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
             return;
         }

        // Limpiar datos antes de insertar (ej: convertir fechas si vienen como string)
        // Asumiendo que las fechas vienen en formato YYYY-MM-DD del form Angular
        foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
            if (isset($data[$dateField]) && empty($data[$dateField])) {
                 $data[$dateField] = null; // Convertir strings vacÃ­os a NULL para la DB
            } elseif (isset($data[$dateField])) {
                // PodrÃ­as aÃ±adir validaciÃ³n de formato de fecha aquÃ­ si es necesario
                 //$date = DateTime::createFromFormat('Y-m-d', $data[$dateField]);
                 //if ($date === false || $date->format('Y-m-d') !== $data[$dateField]) {
                 //    // Error de formato
                 //}
            }
        }
         // Asegurar que los campos numÃ©ricos opcionales vacÃ­os sean NULL
         foreach(['banco', 'num_cheque', 'cuenta_mov', 'cliente', 'proveedor', 'codigo_mbco', 'punto_venta', 'numero_comprobante'] as $numField) {
             if (isset($data[$numField]) && $data[$numField] === '') {
                  $data[$numField] = null;
             }
         }
         // Asegurar que los campos string opcionales vacÃ­os sean NULL o string vacÃ­o segÃºn prefieras
         foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
              if (isset($data[$strField]) && $data[$strField] === '') {
                   $data[$strField] = null; // O mantener como '' si la DB lo permite/prefiere
              }
         }

        // Generar descripciÃ³n automÃ¡tica si tipo_movi es 'A'
        if (isset($data['tipo_movi']) && $data['tipo_movi'] === 'A') {
            $data['descripcion_mov'] = $this->generarDescripcionAutomatica($data);
        }

        $this->db->trans_start(); // Iniciar transacciÃ³n

        $this->db->insert('caja_movi', $data); // Insertar los datos recibidos

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Completar transacciÃ³n

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Devuelve el nÃºmero de filas afectadas (deberÃ­a ser 1)
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}



public function SubirDatosCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n bÃ¡sica (puedes aÃ±adir mÃ¡s segÃºn necesidad)
        if(!isset($data['descripcion']) || !isset($data['fecha_cierre']) || !isset($data['especial']) || !isset($data['fija'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (descripcion, fecha_cierre, especial, fija)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        // Preparar datos para insertar
        $insert_data = array(
            'descripcion' => trim($data['descripcion']),
            'fecha_cierre' => $data['fecha_cierre'], // Asume que el formato es compatible con 'date' de PGSQL
            'especial' => (int)$data['especial'], // Asegurar que sea entero (0 o 1)
            'fija' => (int)$data['fija']          // Asegurar que sea entero (0 o 1)
        );

        $this->db->trans_start();
        $this->db->insert('caja_lista', $insert_data);
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta, REST_Controller::HTTP_CREATED); // Opcional: HTTP Status 201
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosConflista_post()
{
    try {
        $data = $this->post();
        if (!isset($data) || count($data) === 0) {
            $respuesta = [
                "error"   => true,
                "mensaje" => "No se recibieron datos en el POST"
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
        // Validar campo obligatorio
        if (!isset($data['listap'])) {
            $respuesta = [
                "error"   => true,
                "mensaje" => "Faltan campos requeridos (listap)"
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $listap     = $data['listap'];
        $tipomone   = isset($data['tipomone'])   ? $data['tipomone']   : 0;
        $preciof21  = isset($data['preciof21'])  ? (float)$data['preciof21']  : 0;
        $preciof105 = isset($data['preciof105']) ? (float)$data['preciof105'] : 0;

        // DiagnÃ³stico
        $diagnostico = [
            'parametros_recibidos' => [
                'listap'     => $listap,
                'tipomone'   => $tipomone,
                'preciof21'  => $preciof21,
                'preciof105' => $preciof105
            ],
            'verificaciones' => []
        ];

        // CuÃ¡ntos productos hay con ese tipo de moneda
        $this->db->select('COUNT(*) as total');
        $this->db->where('tipo_moneda', $tipomone);
        $query_tipo_moneda = $this->db->get('artsucursal');
        $diagnostico['verificaciones']['productos_con_tipo_moneda']
            = $query_tipo_moneda->row()->total;

        // Resultados que devolveremos
        $resultados = [
            'conflista_creada'         => false,
            'productos_actualizados_21'  => 0,
            'productos_actualizados_105' => 0
        ];

        $this->db->trans_start();

        // Insertar la nueva conflista
        $this->db->insert('conf_lista', [
            'listap'     => $listap,
            'activa'     => isset($data['activa'])     ? $data['activa']     : false,
            'precosto21' => isset($data['precosto21']) ? $data['precosto21'] : 0,
            'precosto105'=> isset($data['precosto105'])? $data['precosto105']: 0,
            'pordcto'    => isset($data['pordcto'])    ? $data['pordcto']    : 0,
            'margen'     => isset($data['margen'])     ? $data['margen']     : 0,
            'preciof21'  => $preciof21,
            'preciof105' => $preciof105,
            'rmargen'    => isset($data['rmargen'])    ? $data['rmargen']    : false,
            'tipomone'   => $tipomone,
            'actprov'    => isset($data['actprov'])    ? $data['actprov']    : false,
            'cod_marca'  => isset($data['cod_marca'])  ? $data['cod_marca']  : '',
            'fecha'      => isset($data['fecha'])      ? $data['fecha']      : date('Y-m-d')
        ]);
        $conflista_id = $this->db->insert_id();
        $resultados['conflista_creada'] = true;
        $resultados['id_conflista']     = $conflista_id;

        // Nombre del campo de precio dinÃ¡mico
        $campo_precio = 'prefi' . $listap;
        $diagnostico['verificaciones']['campo_precio'] = $campo_precio;
        // Verificar existencia del campo
        $sql_check = "
            SELECT column_name
              FROM information_schema.columns
             WHERE table_name = 'artsucursal'
               AND column_name = ?
        ";
        $query_check = $this->db->query($sql_check, [$campo_precio]);
        $campo_existe = $query_check->num_rows() > 0;
        $diagnostico['verificaciones']['campo_existe'] = $campo_existe;

        if (!$campo_existe) {
            $diagnostico['verificaciones']['advertencia']
                = "El campo {$campo_precio} no existe en artsucursal";
            $this->db->trans_complete();

            $respuesta = [
                "error"      => false,
                "mensaje"    => "Lista creada pero no se actualizaron precios porque el campo {$campo_precio} no existe",
                "resultados" => $resultados,
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta);
            return;
        }

        //
        // === BLOQUE IVA 21% ===
        //
        $diagnostico['iva21_info'] = [];

        $this->db->select('cod_iva');
        $this->db->where("ROUND(CAST(alicuota1 AS numeric),2) =", 21.00);
        $query_iva21 = $this->db->get('artiva');

        $diagnostico['iva21_info']['registros_encontrados'] = $query_iva21->num_rows();

        if ($query_iva21->num_rows() > 0) {
            $iva21_records = [];
            foreach ($query_iva21->result() as $row) {
                $iva21_records[] = $row->cod_iva;
            }
            $diagnostico['iva21_info']['cod_iva_valores'] = $iva21_records;

            if (!empty($iva21_records)) {
                $factor21 = 1 + ($preciof21 / 100);
                $diagnostico['iva21_info']['factor'] = $factor21;

                // Contar productos elegibles con idart = 0
                $this->db->where_in('cod_iva', $iva21_records);
                $this->db->where('tipo_moneda', $tipomone);
                $this->db->where('idart', 0);
                $count_query = $this->db->get('artsucursal');
                $diagnostico['iva21_info']['productos_elegibles']
                    = $count_query->num_rows();

                if ($count_query->num_rows() > 0) {
                    $rows_affected = 0;
                    foreach ($iva21_records as $iva_code) {
                        $sql_update = "
                            UPDATE artsucursal
                               SET {$campo_precio} = precon * ?
                             WHERE cod_iva     = ?
                               AND tipo_moneda = ?
                               AND idart        = 0
                        ";
                        $this->db->query($sql_update, [
                            $factor21,
                            $iva_code,
                            $tipomone
                        ]);
                        $rows_affected += $this->db->affected_rows();
                    }
                    $resultados['productos_actualizados_21'] = $rows_affected;
                    $diagnostico['iva21_info']['productos_actualizados'] = $rows_affected;
                }
            }
        }

        //
        // === BLOQUE IVA 10.5% ===
        //
        $diagnostico['iva105_info'] = [];

        $this->db->select('cod_iva');
        $this->db->where("ROUND(CAST(alicuota1 AS numeric),2) =", 10.50);
        $query_iva105 = $this->db->get('artiva');

        $diagnostico['iva105_info']['registros_encontrados'] = $query_iva105->num_rows();

        if ($query_iva105->num_rows() > 0) {
            $iva105_records = [];
            foreach ($query_iva105->result() as $row) {
                $iva105_records[] = $row->cod_iva;
            }
            $diagnostico['iva105_info']['cod_iva_valores'] = $iva105_records;

            if (!empty($iva105_records)) {
                $factor105 = 1 + ($preciof105 / 100);
                $diagnostico['iva105_info']['factor'] = $factor105;

                // Contar productos elegibles con idart = 0
                $this->db->where_in('cod_iva', $iva105_records);
                $this->db->where('tipo_moneda', $tipomone);
                $this->db->where('idart', 0);
                $count_query = $this->db->get('artsucursal');
                $diagnostico['iva105_info']['productos_elegibles']
                    = $count_query->num_rows();

                if ($count_query->num_rows() > 0) {
                    $rows_affected = 0;
                    foreach ($iva105_records as $iva_code) {
                        $sql_update = "
                            UPDATE artsucursal
                               SET {$campo_precio} = precon * ?
                             WHERE cod_iva     = ?
                               AND tipo_moneda = ?
                               AND idart        = 0
                        ";
                        $this->db->query($sql_update, [
                            $factor105,
                            $iva_code,
                            $tipomone
                        ]);
                        $rows_affected += $this->db->affected_rows();
                    }
                    $resultados['productos_actualizados_105'] = $rows_affected;
                    $diagnostico['iva105_info']['productos_actualizados'] = $rows_affected;
                }
            }
        }

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = [
                "error"      => true,
                "mensaje"    => "Error al procesar la operaciÃ³n",
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = [
                "error"      => false,
                "mensaje"    => "OperaciÃ³n completada exitosamente",
                "resultados" => $resultados,
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta);
        }
    } catch (Exception $e) {
        $respuesta = [
            "error"   => true,
            "mensaje" => "Error en el servidor: " . $e->getMessage(),
            "file"    => $e->getFile(),
            "line"    => $e->getLine()
        ];
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

public function UpdateCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n bÃ¡sica
        if(!isset($data['id_caja']) || !isset($data['descripcion']) || !isset($data['fecha_cierre']) || !isset($data['especial']) || !isset($data['fija'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (id_caja, descripcion, fecha_cierre, especial, fija)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = (int)$data['id_caja'];

        // Preparar datos para actualizar
        $update_data = array(
            'descripcion' => trim($data['descripcion']),
            'fecha_cierre' => $data['fecha_cierre'],
            'especial' => (int)$data['especial'],
            'fija' => (int)$data['fija']
        );

        $this->db->trans_start();
        $this->db->where('id_caja', $id);
        $this->db->update('caja_lista', $update_data);
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             // Incluso si no se modificÃ³ nada (rows=0), la operaciÃ³n fue exitosa si trans_status es TRUE
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Informa cuÃ¡ntas filas fueron realmente cambiadas
                // "mensaje" => "ActualizaciÃ³n completada" // Alternativa
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_rubro_p']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (id, datos)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro_p'];
        $datos = $data['rubro'];

        // Validate datos structure
        if(!isset($datos['cod_rubro']) || !isset($datos['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "El objeto datos debe contener cod_rubro y rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start();

        // Update rubro_principal
        $this->db->where('id_rubro_p', $id);
        $this->db->update('rubro_principal', array(
            'cod_rubro' => $datos['cod_rubro'],
            'rubro' => $datos['rubro']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $datos
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_prov'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_prov'];

        $this->db->trans_start();

        // Update proveedores table with all fields
        $this->db->where('id_prov', $id);
        $this->db->update('proveedores', array(
            'cod_prov' => $data['cod_prov'],
            'nombre' => $data['nombre'],
            'direccion' => $data['direccion'],
            'codpos' => $data['codpos'],
            'localidad' => $data['localidad'],
            'telefono' => $data['telefono'],
            'cuit' => $data['cuit'],
            'contacto' => $data['contacto'],
            'rubro' => $data['rubro'],
            'cod_iva' => $data['cod_iva'],
            'ganancias' => $data['ganancias'],
            'ingbrutos' => $data['ingbrutos'],
            'email' => $data['email'],
            'www' => $data['www'],
            'cta_proveedores' => $data['cta_proveedores'],
            'fec_proceso' => $data['fec_proceso']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function UpdateRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro'];

        $this->db->trans_start();

        // Update rubros table with all fields
        $this->db->where('id_rubro', $id);
        $this->db->update('rubros', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro'],
            'numerador' => $data['numerador'],
            'modiprecio' => $data['modiprecio'],
            'modidescri' => $data['modidescri'],
            'cod_depo' => $data['cod_depo'],
            'mustuni' => $data['mustuni']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_marca'];

        $this->db->trans_start();

        // Update rubros table with all fields
        $this->db->where('id_marca', $id);
        $this->db->update('marcas', array(
            'id_marca' => $data['id_marca'],
            'cod_marca' => $data['cod_marca'],
            'marca' => $data['marca'],
            
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_moneda'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_moneda'];

        $this->db->trans_start();

        // Update tipomone table with all fields
        $this->db->where('id_moneda', $id);
        $this->db->update('tipomone', array(
            'cod_mone' => $data['cod_mone'],
            'moneda' => $data['moneda'],
            'simbolo' => $data['simbolo']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_valor'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_valor'];

        $this->db->trans_start();

        // Update valorcambio table with all fields
        $this->db->where('id_valor', $id);
        $this->db->update('valorcambio', array(
            'codmone' => $data['codmone'],
            'desvalor' => $data['desvalor'],
            'fecdesde' => $data['fecdesde'],
            'fechasta' => $data['fechasta'],
            'vcambio' => $data['vcambio']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateCajamovi_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar que el ID estÃ© presente
        if(!isset($data['id_movimiento'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del movimiento para actualizar"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_movimiento'];
        unset($data['id_movimiento']); // No se actualiza el ID

        // ===========================================================================
        // FASE 7: POLÃTICA DE EDICIÃ“N - Verificar si el movimiento tiene desglose
        // Si tiene desglose de mÃ©todos de pago, denegar la ediciÃ³n para mantener
        // la integridad de los datos histÃ³ricos
        // ===========================================================================
        $sql_verificar = "SELECT COUNT(*) as tiene_desglose FROM caja_movi_detalle WHERE id_movimiento = ?";
        $query_verificar = $this->db->query($sql_verificar, array($id));

        if ($query_verificar && $query_verificar->num_rows() > 0) {
            $resultado = $query_verificar->row();
            if ($resultado->tiene_desglose > 0) {
                // El movimiento tiene desglose, denegar ediciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "No se puede editar este movimiento porque tiene desglose de mÃ©todos de pago registrado. Los movimientos con desglose son de solo lectura para mantener la integridad de los datos histÃ³ricos.",
                    "codigo" => "MOVIMIENTO_CON_DESGLOSE_NO_EDITABLE"
                );
                $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
                return;
            }
        }
        // ===========================================================================

       // Limpiar datos (similar a la inserciÃ³n)
       foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
           if (isset($data[$dateField]) && empty($data[$dateField])) {
                $data[$dateField] = null;
           }
       }
       foreach(['banco', 'num_cheque', 'cuenta_mov', 'cliente', 'proveedor', 'codigo_mbco', 'punto_venta', 'numero_comprobante'] as $numField) {
             if (isset($data[$numField]) && ($data[$numField] === '' || $data[$numField] === null)) {
                  $data[$numField] = null;
             }
         }
        foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
             if (isset($data[$strField]) && $data[$strField] === '') {
                  $data[$strField] = null;
             }
        }

        $this->db->trans_start();

        $this->db->where('id_movimiento', $id);
        $this->db->update('caja_movi', $data); // Actualiza con los datos recibidos

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows, // Filas afectadas (puede ser 0 si no cambiÃ³ nada, o 1)
                "datos" => $this->post() // Devuelve los datos enviados para referencia
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}



public function UpdateConflista_post()
{
    try {
        $data = $this->post();
        
        // ===================================================
        // VALIDACIONES BÃSICAS PHP (OPCIONALES - PostgreSQL LAS REPETIRÃ)
        // ===================================================
        if (!isset($data['id_conflista'])) {
            $respuesta = [
                'error' => true,
                'mensaje' => 'Falta el ID de la conflista'
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
        
        // ===================================================
        // PREPARAR PARÃMETROS PARA POSTGRESQL
        // CONVERSIÃ“N ADECUADA DE TIPOS BOOLEAN
        // ===================================================
        
        // Convertir valores 't'/'f' a boolean para PostgreSQL
        $activa_bool = ($data['activa'] === 't' || $data['activa'] === true || $data['activa'] === 'true') ? true : false;
        $rmargen_bool = (($data['rmargen'] ?? 'f') === 't' || ($data['rmargen'] ?? false) === true) ? true : false;
        $actprov_bool = (($data['actprov'] ?? 'f') === 't' || ($data['actprov'] ?? false) === true) ? true : false;
        
        $params = [
            (int)$data['id_conflista'],                                           // p_id_conflista
            (int)$data['listap'],                                                // p_listap
            $activa_bool,                                                        // p_activa (boolean)
            (float)($data['precosto21'] ?? 0),                                   // p_precosto21
            (float)($data['precosto105'] ?? 0),                                  // p_precosto105
            (float)($data['pordcto'] ?? 0),                                      // p_pordcto
            (float)($data['margen'] ?? 0),                                       // p_margen
            (float)($data['preciof21'] ?? 0),                                    // p_preciof21
            (float)($data['preciof105'] ?? 0),                                   // p_preciof105
            $rmargen_bool,                                                       // p_rmargen (boolean)
            (int)($data['tipomone'] ?? 1),                                       // p_tipomone
            $actprov_bool,                                                       // p_actprov (boolean)
            $data['cod_marca'] ?? '',                                            // p_cod_marca
            $data['fecha'] ?? date('Y-m-d'),                                     // p_fecha
            isset($data['recalcular_21']) && $data['recalcular_21'] ? true : false,   // p_recalcular_21
            isset($data['recalcular_105']) && $data['recalcular_105'] ? true : false  // p_recalcular_105
        ];
        
        // ===================================================
        // LLAMADA ÃšNICA A POSTGRESQL - TODO ATÃ“MICO
        // USANDO CONSULTA DIRECTA PARA EVITAR PROBLEMAS DE CODEIGNITER
        // ===================================================
        
        // Construir la consulta SQL directamente con valores escapados
        $sql = sprintf(
            "SELECT update_conflista_con_recalculo(%d,%d,%s,%s,%s,%s,%s,%s,%s,%s,%d,%s,'%s','%s',%s,%s) as resultado",
            $params[0],  // id_conflista
            $params[1],  // listap
            $params[2] ? 'true' : 'false',  // activa
            $params[3],  // precosto21
            $params[4],  // precosto105
            $params[5],  // pordcto
            $params[6],  // margen
            $params[7],  // preciof21
            $params[8],  // preciof105
            $params[9] ? 'true' : 'false',  // rmargen
            $params[10], // tipomone
            $params[11] ? 'true' : 'false', // actprov
            $params[12], // cod_marca
            $params[13], // fecha
            $params[14] ? 'true' : 'false', // recalcular_21
            $params[15] ? 'true' : 'false'  // recalcular_105
        );
        
        // Debug de la llamada
        $debug_llamada = [
            'timestamp_llamada_php' => date('Y-m-d H:i:s'),
            'funcion_postgresql' => 'update_conflista_con_recalculo',
            'sql_generado' => $sql,
            'parametros_enviados' => [
                'id_conflista' => $params[0],
                'listap' => $params[1],
                'activa' => $params[2],
                'tipomone' => $params[10],
                'preciof21' => $params[7],
                'preciof105' => $params[8],
                'recalcular_21' => $params[14],
                'recalcular_105' => $params[15]
            ]
        ];
        
        $query = $this->db->query($sql);
        
        if (!$query) {
            throw new Exception('Error ejecutando funciÃ³n PostgreSQL: ' . $this->db->error()['message']);
        }
        
        $result = $query->row();
        
        if (!$result || !isset($result->resultado)) {
            throw new Exception('No se recibiÃ³ respuesta vÃ¡lida de PostgreSQL');
        }
        
        // DEBUG: Ver exactamente quÃ© devuelve PostgreSQL
        $raw_result = $result->resultado;
        error_log("=== DEBUG POSTGRESQL RESPONSE ===");
        error_log("Raw result: " . $raw_result);
        error_log("SQL ejecutado: " . $sql);
        
        // PostgreSQL devuelve JSON, decodificarlo
        $response = json_decode($raw_result, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new Exception('Error decodificando respuesta JSON de PostgreSQL: ' . json_last_error_msg() . '. Raw response: ' . $raw_result);
        }
        
        // Agregar informaciÃ³n de debug de PHP
        if (isset($response['debug'])) {
            $response['debug']['llamada_php'] = $debug_llamada;
            $response['debug']['timestamp_respuesta_php'] = date('Y-m-d H:i:s');
        }
        
        // ===================================================
        // ENVIAR RESPUESTA DIRECTA DE POSTGRESQL
        // ===================================================
        $http_status = $response['error'] ? REST_Controller::HTTP_INTERNAL_SERVER_ERROR : REST_Controller::HTTP_OK;
        $this->response($response, $http_status);
        
    } catch (Exception $e) {
        // ===================================================
        // MANEJO DE ERRORES PHP (ERRORES DE COMUNICACIÃ“N)
        // ===================================================
        $respuesta = [
            'error' => true,
            'mensaje' => 'Error en PHP al comunicarse con PostgreSQL: ' . $e->getMessage(),
            'debug' => [
                'timestamp_error_php' => date('Y-m-d H:i:s'),
                'error_php' => $e->getMessage(),
                'archivo' => $e->getFile(),
                'linea' => $e->getLine(),
                'datos_recibidos' => $data ?? null,
                'nota' => 'Este error ocurriÃ³ en PHP, no en PostgreSQL. La funciÃ³n PostgreSQL puede no haberse ejecutado.'
            ]
        ];
        
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

public function UpdateArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_articulo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_articulo'];

        $this->db->trans_start();

        // Update articulos table with all fields
        $this->db->where('id_articulo', $id);
        $this->db->update('artsucursal', array(
            'nomart' => $data['nomart'],
            'marca' => $data['marca'],
            'precon' => $data['precon'],
            'prefi1' => $data['prefi1'],
            'prefi2' => $data['prefi2'],
            'prefi3' => $data['prefi3'],
            'prefi4' => $data['prefi4'],
            'exi1' => $data['exi1'],
            'exi2' => $data['exi2'],
            'exi3' => $data['exi3'],
            'exi4' => $data['exi4'],
            'exi5' => $data['exi5'],
            'stkmin1' => $data['stkmin1'],
            'stkmax1' => $data['stkmax1'],
            'stkprep1' => $data['stkprep1'],
            'stkmin2' => $data['stkmin2'],
            'stkmax2' => $data['stkmax2'],
            'stkprep2' => $data['stkprep2'],
            'stkmin3' => $data['stkmin3'],
            'stkmax3' => $data['stkmax3'],
            'stkprep3' => $data['stkprep3'],
            'stkmin4' => $data['stkmin4'],
            'stkmax4' => $data['stkmax4'],
            'stkprep4' => $data['stkprep4'],
            'stkmin5' => $data['stkmin5'],
            'stkmax5' => $data['stkmax5'],
            'stkprep5' => $data['stkprep5'],
            'cd_articulo' => $data['cd_articulo'],
            'cd_proveedor' => $data['cd_proveedor'],
            'cd_barra' => $data['cd_barra'],
            'idart' => $data['idart'],
            'estado' => $data['estado'],
            'rubro' => $data['rubro'],
            'articulo' => $data['articulo'],
            'cod_iva' => $data['cod_iva'],
            'prebsiva' => $data['prebsiva'],
            'precostosi' => $data['precostosi'],
            'margen' => $data['margen'],
            'descuento' => $data['descuento'],
            'cod_deposito' => $data['cod_deposito'],
            'tipo_moneda' => $data['tipo_moneda']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar ID requerido
        if(!isset($data['id_concepto'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del concepto de caja (id_concepto)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
         // ValidaciÃ³n bÃ¡sica de otros campos (se pueden aÃ±adir mÃ¡s)
        if(!isset($data['descripcion']) || !isset($data['tipo_concepto']) || !isset($data['fija']) || !isset($data['ingreso_egreso']) || !isset($data['id_caja']) || !isset($data['activo_inactivo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos para actualizar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_concepto'];

        $this->db->trans_start();

        // Actualizar tabla cajaconceptos
        $this->db->where('id_concepto', $id);
        $this->db->update('caja_conceptos', array(
            'descripcion' => $data['descripcion'],
            'tipo_concepto' => $data['tipo_concepto'],
            'fija' => $data['fija'],
            'ingreso_egreso' => $data['ingreso_egreso'],
            'id_caja' => $data['id_caja'],
            'activo_inactivo' => $data['activo_inactivo']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             $respuesta = array(
                "error" => false,
                "mensaje" => $rows, // NÃºmero de filas afectadas
                "datos_enviados" => $data // Opcional: devolver los datos enviados para depuraciÃ³n
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function SubirDatosRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_rubro']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_rubro, rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro with all fields
        $this->db->insert('rubros', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro'],
            'cod_depo' => isset($data['cod_depo']) ? $data['cod_depo'] : 0,
            'modidescri' => isset($data['modidescri']) ? $data['modidescri'] : 0,
            'modiprecio' => isset($data['modiprecio']) ? $data['modiprecio'] : 0,
            'mustuni' => isset($data['mustuni']) ? $data['mustuni'] : 0,
            'numerador' => isset($data['numerador']) ? $data['numerador'] : 0,
            'id_rubro_p' => $data['id_rubro_p']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_marca']) || !isset($data['marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_marca, marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro with all fields
        $this->db->insert('marcas', array(
            'cod_marca' => $data['cod_marca'],
            'marca' => $data['marca'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar la marca"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function historialventasxsucxcli_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar lÃ­mites de paginaciÃ³n
    $page = max(1, $page);
    $limit = max(10, min(1000, $limit));
    $offset = ($page - 1) * $limit;

    // Construir nombre de tabla
    $tabla = "psucursal" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tabla)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tabla no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Seleccionar campos especÃ­ficos incluyendo descripciÃ³n de tarjeta
        $this->db->select('p.tipodoc, p.puntoventa, p.idart, p.nomart, p.fecha, p.hora, p.cantidad, p.precio, p.cod_tar, p.numerocomprobante, p.id_num, p.idcli, CASE WHEN t.tarjeta IS NOT NULL THEN t.tarjeta ELSE \'Sin definir\' END as descripcion_tarjeta');
        $this->db->from($tabla . ' p');
        $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
        
        // Filtrar por cliente
        $this->db->where('p.idcli', $idcli);

        // Aplicar bÃºsqueda global si existe
        if ($search && trim($search) !== '') {
            $searchTerm = $this->db->escape_like_str($search);
            $this->db->group_start();
            $this->db->like('p.nomart', $searchTerm);
            $this->db->or_like('p.tipodoc', $searchTerm);
            $this->db->or_like('p.numerocomprobante', $searchTerm);
            $this->db->or_like('t.tarjeta', $searchTerm);
            $this->db->group_end();
        }

        // Aplicar filtros de columna si existen
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray)) {
                foreach ($filtersArray as $field => $filter) {
                    if (isset($filter['value']) && $filter['value'] !== '') {
                        $value = $filter['value'];
                        $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                        
                        // Mapear campos al alias correcto
                        $dbField = $field;
                        if ($field === 'descripcion_tarjeta') {
                            $dbField = 't.tarjeta';
                        } elseif (in_array($field, ['tipodoc', 'puntoventa', 'idart', 'nomart', 'fecha', 'hora', 'cantidad', 'precio', 'cod_tar', 'numerocomprobante', 'id_num', 'idcli'])) {
                            $dbField = 'p.' . $field;
                        }
                        
                        switch ($matchMode) {
                            case 'startsWith':
                                $this->db->like($dbField, $value, 'after');
                                break;
                            case 'contains':
                                $this->db->like($dbField, $value);
                                break;
                            case 'equals':
                                $this->db->where($dbField, $value);
                                break;
                            case 'gt':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'gte':
                                $this->db->where($dbField . ' >=', $value);
                                break;
                            case 'lt':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            case 'lte':
                                $this->db->where($dbField . ' <=', $value);
                                break;
                            case 'dateIs':
                                $this->db->where($dbField, $value);
                                break;
                            case 'dateAfter':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'dateBefore':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            default:
                                $this->db->like($dbField, $value);
                                break;
                        }
                    }
                }
            }
        }

        // Contar total de registros antes de aplicar lÃ­mites
        $totalQuery = clone $this->db;
        $totalRegistros = $totalQuery->count_all_results('', false);

        // Aplicar ordenamiento
        if ($sortField && trim($sortField) !== '') {
            $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
            
            // Mapear campo de ordenamiento al alias correcto
            $dbSortField = $sortField;
            if ($sortField === 'descripcion_tarjeta') {
                $dbSortField = 't.tarjeta';
            } elseif (in_array($sortField, ['tipodoc', 'puntoventa', 'idart', 'nomart', 'fecha', 'hora', 'cantidad', 'precio', 'cod_tar', 'numerocomprobante', 'id_num', 'idcli'])) {
                $dbSortField = 'p.' . $sortField;
            }
            
            $this->db->order_by($dbSortField, $sortDirection);
        } else {
            // Ordenamiento por defecto: fecha y hora mÃ¡s recientes primero
            $this->db->order_by('p.fecha', 'DESC');
            $this->db->order_by('p.hora', 'DESC');
        }

        // Aplicar paginaciÃ³n
        $this->db->limit($limit, $offset);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->result_array();

        // Calcular metadatos de paginaciÃ³n
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros)
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene los datos completos del recibo basÃ¡ndose en el id_num de la venta
 * Relaciona las tablas psucursal y recibos para mostrar informaciÃ³n completa
 */
public function obtenerDatosRecibo_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $idNum = $this->get('id_num');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$idNum) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e id_num"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaPsucursal = "psucursal" . $sucursal;
    $tablaRecibos = "recibos" . $sucursal;

    // Verificar si las tablas existen
    if (!$this->db->table_exists($tablaPsucursal) || !$this->db->table_exists($tablaRecibos)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Las tablas requeridas no existen para la sucursal $sucursal"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Consulta para obtener datos combinados de psucursal y recibos
        $this->db->select('
            p.id_num,
            p.numerocomprobante,
            p.puntoventa,
            p.fecha as fecha_venta,
            p.hora,
            p.nomart,
            p.precio,
            p.cantidad,
            p.tipodoc,
            p.idcli,
            p.idven,
            p.cod_tar,
            p.estado,
            r.recibo,
            r.c_tipo,
            r.c_cuota,
            r.fecha as fecha_recibo,
            r.importe,
            r.usuario,
            r.observacion,
            r.cod_lugar,
            r.sesion,
            r.c_tipf,
            r.recibo_saldo,
            r.cod_sucursal,
            r.fec_proceso,
            r.bonifica,
            r.bonifica_tipo,
            r.interes,
            r.interes_tipo,
            r.recibo_asoc,
            CASE WHEN t.tarjeta IS NOT NULL THEN t.tarjeta ELSE \'Sin definir\' END as descripcion_tarjeta
        ');
        
        $this->db->from($tablaPsucursal . ' p');
        $this->db->join($tablaRecibos . ' r', 'p.id_num = r.id_fac', 'left');
        $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
        $this->db->where('p.id_num', $idNum);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->row_array();

        if (!$datos) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron datos para el id_num: $idNum"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => "Datos del recibo obtenidos exitosamente",
            "data" => $datos
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos del recibo: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene historial de ventas de la tabla factcabx (historialventas2)
 * con paginaciÃ³n, filtros, bÃºsqueda y ordenamiento
 */
public function historialventas2xcli_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar lÃ­mites de paginaciÃ³n
    $page = max(1, $page);
    $limit = max(10, min(1000, $limit));
    $offset = ($page - 1) * $limit;

    // Construir nombre de tabla
    $tabla = "factcab" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tabla)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tabla no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Seleccionar campos especÃ­ficos de factcabx
        $this->db->select('
            f.cod_sucursal as sucursal,
            f.tipo,
            f.puntoventa,
            f.letra,
            f.numero_int,
            f.numero_fac,
            f.emitido,
            f.vencimiento,
            f.exento,
            f.basico,
            f.iva1,
            f.iva2,
            f.iva3,
            (f.exento + f.basico + f.iva1 + f.iva2 + f.iva3) as importe,
            COALESCE(MAX(r.bonifica), f.bonifica) as bonifica,
            COALESCE(MAX(r.bonifica_tipo), f.bonifica_tipo) as bonifica_tipo,
            COALESCE(MAX(r.interes), f.interes) as interes,
            COALESCE(MAX(r.interes_tipo), f.interes_tipo) as interes_tipo,
            f.saldo,
            f.usuario,
            f.id_num as id,
            f.cliente
        ');
        $this->db->from($tabla . ' f');
        // CORREGIDO: JOIN mejorado para evitar mezcla de datos entre clientes
        $this->db->join($tabla . ' rc', 'f.numero_fac = rc.numero_fac AND rc.tipo = \'RC\' AND f.cliente = rc.cliente', 'left');
        $this->db->join('recibos' . substr($tabla, -1) . ' r', 'rc.id_num = r.id_fac', 'left');
        $this->db->group_by('f.cod_sucursal, f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, f.saldo, f.usuario, f.id_num, f.cliente, f.bonifica, f.bonifica_tipo, f.interes, f.interes_tipo');
        
        // Filtrar por cliente
        $this->db->where('f.cliente', $idcli);
        
        // FILTRO IMPORTANTE: Excluir recibos RC de historial de ventas
        $this->aplicarFiltroSinRC('f');

        // Aplicar filtro de rango de fechas si se proporciona
        if ($fecha_desde && $fecha_hasta) {
            // Validar formato de fechas (YYYY-MM-DD)
            if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
                $this->db->where('f.emitido >=', $fecha_desde);
                $this->db->where('f.emitido <=', $fecha_hasta);
            }
        }

        // Aplicar bÃºsqueda global si existe
        if ($search && trim($search) !== '') {
            $searchTerm = $this->db->escape_like_str($search);
            $this->db->group_start();
            $this->db->like('f.tipo', $searchTerm);
            $this->db->or_like('f.letra', $searchTerm);
            $this->db->or_like('f.numero_fac', $searchTerm);
            $this->db->or_like('f.usuario', $searchTerm);
            $this->db->group_end();
        }

        // Aplicar filtros de columna si existen
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray)) {
                foreach ($filtersArray as $field => $filter) {
                    if (isset($filter['value']) && $filter['value'] !== '') {
                        $value = $filter['value'];
                        $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                        
                        // Mapear campos al alias correcto
                        $dbField = 'f.' . $field;
                        
                        switch ($matchMode) {
                            case 'startsWith':
                                $this->db->like($dbField, $value, 'after');
                                break;
                            case 'contains':
                                $this->db->like($dbField, $value);
                                break;
                            case 'equals':
                                $this->db->where($dbField, $value);
                                break;
                            case 'gt':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'gte':
                                $this->db->where($dbField . ' >=', $value);
                                break;
                            case 'lt':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            case 'lte':
                                $this->db->where($dbField . ' <=', $value);
                                break;
                            case 'dateIs':
                                $this->db->where($dbField, $value);
                                break;
                            case 'dateAfter':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'dateBefore':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            default:
                                $this->db->like($dbField, $value);
                                break;
                        }
                    }
                }
            }
        }

        // Contar total de registros antes de aplicar lÃ­mites
        $totalQuery = clone $this->db;
        $totalRegistros = $totalQuery->count_all_results('', false);

        // Aplicar ordenamiento
        if ($sortField && trim($sortField) !== '') {
            $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
            $dbSortField = 'f.' . $sortField;
            $this->db->order_by($dbSortField, $sortDirection);
        } else {
            // Ordenamiento por defecto: fecha de emisiÃ³n mÃ¡s reciente primero
            $this->db->order_by('f.emitido', 'DESC');
        }

        // Aplicar paginaciÃ³n
        $this->db->limit($limit, $offset);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->result_array();

        // Calcular metadatos de paginaciÃ³n
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros)
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas2: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene historial de ventas GLOBAL de todas las sucursales (factcabx)
 * Solo para usuarios con rol ADMIN o SUPER
 * con paginaciÃ³n, filtros, bÃºsqueda y ordenamiento
 */
public function historialventas2global_get()
{
    // Obtener parÃ¡metros de la URL
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');
    $user_role = $this->get('user_role'); // Se debe enviar desde el frontend

    // Validaciones bÃ¡sicas
    if (!$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Falta parÃ¡metro requerido: idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar permisos - Solo ADMIN y SUPER pueden acceder
    if (!$user_role || ($user_role !== 'admin' && $user_role !== 'super')) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Acceso denegado: Se requiere rol ADMIN o SUPER para vista global"
        );
        $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
        return;
    }

    // Validar lÃ­mites de paginaciÃ³n
    $page = max(1, $page);
    $limit = max(10, min(500, $limit)); // LÃ­mite mÃ¡s conservador para vista global
    $offset = ($page - 1) * $limit;

    try {
        // Obtener lista de sucursales disponibles
        $sucursales = $this->obtenerSucursalesDisponibles();
        
        // Log para debug
        error_log("Sucursales disponibles encontradas: " . print_r($sucursales, true));
        
        if (empty($sucursales)) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron sucursales disponibles"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Construir consulta UNION manualmente para evitar problemas con CodeIgniter
        $unionQueries = array();
        foreach ($sucursales as $sucursal) {
            $tabla = "factcab" . $sucursal;
            
            // Log para debug
            error_log("Verificando tabla: " . $tabla);
            
            // Verificar si la tabla existe
            if ($this->db->table_exists($tabla)) {
                error_log("Tabla {$tabla} existe - construyendo subconsulta");
                $subQuery = $this->construirSubConsultaGlobalManual($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters);
                if ($subQuery) {
                    $unionQueries[] = $subQuery;
                    error_log("Subconsulta agregada para {$tabla}: " . substr($subQuery, 0, 100) . "...");
                }
            } else {
                error_log("Tabla {$tabla} NO existe");
            }
        }

        if (empty($unionQueries)) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron tablas de facturas disponibles"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Construir consulta final con UNION
        $unionQuery = implode(' UNION ALL ', $unionQueries);
        
        // Log de la consulta final
        error_log("NÃºmero de subconsultas UNION: " . count($unionQueries));
        error_log("Consulta UNION completa: " . $unionQuery);
        
        // Aplicar filtro de sucursal DESPUÃ‰S del UNION si existe
        $whereClause = '';
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray) && isset($filtersArray['sucursal'])) {
                $sucursalFilter = $filtersArray['sucursal'];
                if (isset($sucursalFilter['value']) && $sucursalFilter['value'] !== '') {
                    $value = $sucursalFilter['value'];
                    $matchMode = isset($sucursalFilter['matchMode']) ? $sucursalFilter['matchMode'] : 'contains';
                    $value_escaped = $this->db->escape($value);
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape($value . '%');
                            break;
                        case 'contains':
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                        case 'equals':
                            $whereClause = " WHERE sucursal = {$value_escaped}";
                            break;
                        default:
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                    }
                    
                    error_log("Filtro de sucursal aplicado despuÃ©s del UNION: " . $whereClause);
                }
            }
        }
        
        // Agregar ordenamiento y paginaciÃ³n
        $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
        $orderField = $sortField ? $sortField : 'emitido';
        
        $finalQuery = "SELECT * FROM ({$unionQuery}) AS combined_results{$whereClause} ORDER BY {$orderField} {$sortDirection} LIMIT {$limit} OFFSET {$offset}";
        
        // Log de la consulta final
        error_log("Consulta final con paginaciÃ³n: " . $finalQuery);
        
        // Contar total de registros
        $countQuery = "SELECT COUNT(*) as total FROM ({$unionQuery}) AS combined_results{$whereClause}";
        $countResult = $this->db->query($countQuery)->row_array();
        $totalRegistros = $countResult['total'];

        // Log del conteo
        error_log("Total de registros encontrados: " . $totalRegistros);

        // Ejecutar consulta principal
        $query = $this->db->query($finalQuery);
        $datos = $query->result_array();
        
        // Log de resultados
        error_log("Registros devueltos: " . count($datos));

        // Calcular metadatos de paginaciÃ³n
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros),
                "sucursales_consultadas" => $sucursales,
                "vista" => "global"
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas global: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Construye una subconsulta para una sucursal especÃ­fica
 */
private function construirSubConsultaGlobal($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters)
{
    $this->db->select('
        \'' . $sucursal . '\' as sucursal,
        tipo,
        puntoventa,
        letra,
        numero_fac,
        emitido,
        vencimiento,
        exento,
        basico,
        iva1,
        iva2,
        iva3,
        (exento + basico + iva1 + iva2 + iva3) as importe,
        saldo,
        usuario,
        id_num as id,
        cliente
    ');
    $this->db->from($tabla);
    $this->db->where('cliente', $idcli);

    // Aplicar filtro de rango de fechas si se proporciona
    if ($fecha_desde && $fecha_hasta) {
        if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
            $this->db->where('emitido >=', $fecha_desde);
            $this->db->where('emitido <=', $fecha_hasta);
        }
    }

    // Aplicar bÃºsqueda global si existe
    if ($search && trim($search) !== '') {
        $searchTerm = $this->db->escape_like_str($search);
        $this->db->group_start();
        $this->db->like('tipo', $searchTerm);
        $this->db->or_like('letra', $searchTerm);
        $this->db->or_like('numero_fac', $searchTerm);
        $this->db->or_like('usuario', $searchTerm);
        $this->db->group_end();
    }

    // Aplicar filtros de columna si existen
    if ($filters && trim($filters) !== '') {
        $filtersArray = json_decode($filters, true);
        if ($filtersArray && is_array($filtersArray)) {
            foreach ($filtersArray as $field => $filter) {
                if (isset($filter['value']) && $filter['value'] !== '') {
                    $value = $filter['value'];
                    $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $this->db->like($field, $value, 'after');
                            break;
                        case 'contains':
                            $this->db->like($field, $value);
                            break;
                        case 'equals':
                            $this->db->where($field, $value);
                            break;
                        case 'gt':
                            $this->db->where($field . ' >', $value);
                            break;
                        case 'gte':
                            $this->db->where($field . ' >=', $value);
                            break;
                        case 'lt':
                            $this->db->where($field . ' <', $value);
                            break;
                        case 'lte':
                            $this->db->where($field . ' <=', $value);
                            break;
                        case 'dateIs':
                            $this->db->where($field, $value);
                            break;
                        case 'dateAfter':
                            $this->db->where($field . ' >', $value);
                            break;
                        case 'dateBefore':
                            $this->db->where($field . ' <', $value);
                            break;
                        default:
                            $this->db->like($field, $value);
                            break;
                    }
                }
            }
        }
    }

    return $this->db->get_compiled_select();
}

/**
 * Construye una subconsulta manual para una sucursal especÃ­fica (evita problemas con CodeIgniter)
 */
private function construirSubConsultaGlobalManual($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters)
{
    // Escapar valores
    $idcli_escaped = $this->db->escape($idcli);
    $sucursal_escaped = $this->db->escape($sucursal);
    $tabla_escaped = $this->db->escape_identifiers($tabla);
    
    // Log para debug
    error_log("Construyendo subconsulta para tabla: {$tabla}, sucursal: {$sucursal}, cliente: {$idcli}");
    
    // Construir SELECT base - CORREGIDO: Agregado filtro por cliente en el JOIN
    $select = "SELECT {$sucursal_escaped} as sucursal, f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, (f.exento + f.basico + f.iva1 + f.iva2 + f.iva3) as importe, COALESCE(MAX(r.bonifica), f.bonifica) as bonifica, COALESCE(MAX(r.bonifica_tipo), f.bonifica_tipo) as bonifica_tipo, COALESCE(MAX(r.interes), f.interes) as interes, COALESCE(MAX(r.interes_tipo), f.interes_tipo) as interes_tipo, f.saldo, f.usuario, f.id_num as id, f.cliente FROM {$tabla_escaped} f LEFT JOIN {$tabla_escaped} rc ON f.numero_fac = rc.numero_fac AND rc.tipo = 'RC' AND f.cliente = rc.cliente LEFT JOIN recibos" . substr($tabla, -1) . " r ON rc.id_num = r.id_fac GROUP BY f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, f.saldo, f.usuario, f.id_num, f.cliente, f.bonifica, f.bonifica_tipo, f.interes, f.interes_tipo";
    
    // Construir WHERE
    $where = "WHERE f.cliente = {$idcli_escaped} AND f.tipo != 'RC'";
    
    // Log de la consulta base
    error_log("Consulta base para {$tabla}: {$select} {$where}");
    
    // Aplicar filtro de rango de fechas si se proporciona
    if ($fecha_desde && $fecha_hasta) {
        if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
            $fecha_desde_escaped = $this->db->escape($fecha_desde);
            $fecha_hasta_escaped = $this->db->escape($fecha_hasta);
            $where .= " AND f.emitido >= {$fecha_desde_escaped} AND f.emitido <= {$fecha_hasta_escaped}";
        }
    }
    
    // Aplicar bÃºsqueda global si existe
    if ($search && trim($search) !== '') {
        $search_escaped = $this->db->escape('%' . $search . '%');
        $where .= " AND (f.tipo LIKE {$search_escaped} OR f.letra LIKE {$search_escaped} OR f.numero_fac::text LIKE {$search_escaped} OR f.usuario LIKE {$search_escaped})";
    }
    
    // Aplicar filtros de columna si existen (EXCLUYENDO el filtro de sucursal)
    if ($filters && trim($filters) !== '') {
        $filtersArray = json_decode($filters, true);
        if ($filtersArray && is_array($filtersArray)) {
            foreach ($filtersArray as $field => $filter) {
                // EXCLUIR el filtro de sucursal ya que es una columna virtual
                if ($field === 'sucursal') {
                    error_log("Filtro de sucursal excluido de subconsulta - se aplicarÃ¡ despuÃ©s del UNION");
                    continue;
                }
                
                if (isset($filter['value']) && $filter['value'] !== '') {
                    $value = $filter['value'];
                    $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                    $value_escaped = $this->db->escape($value);
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $where .= " AND f.{$field} LIKE " . $this->db->escape($value . '%');
                            break;
                        case 'contains':
                            $where .= " AND f.{$field} LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                        case 'equals':
                            $where .= " AND f.{$field} = {$value_escaped}";
                            break;
                        case 'gt':
                            $where .= " AND f.{$field} > {$value_escaped}";
                            break;
                        case 'gte':
                            $where .= " AND f.{$field} >= {$value_escaped}";
                            break;
                        case 'lt':
                            $where .= " AND f.{$field} < {$value_escaped}";
                            break;
                        case 'lte':
                            $where .= " AND f.{$field} <= {$value_escaped}";
                            break;
                        case 'dateIs':
                            $where .= " AND f.{$field} = {$value_escaped}";
                            break;
                        case 'dateAfter':
                            $where .= " AND f.{$field} > {$value_escaped}";
                            break;
                        case 'dateBefore':
                            $where .= " AND f.{$field} < {$value_escaped}";
                            break;
                        default:
                            $where .= " AND f.{$field} LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                    }
                }
            }
        }
    }
    
    return $select . ' ' . $where;
}

/**
 * Obtiene lista de sucursales disponibles
 */
private function obtenerSucursalesDisponibles()
{
    // Buscar tablas factcab* en la base de datos
    $tables = $this->db->list_tables();
    $sucursales = array();
    
    error_log("Todas las tablas en la base de datos: " . print_r($tables, true));
    
    foreach ($tables as $table) {
        if (strpos($table, 'factcab') === 0 && strlen($table) > 7) {
            $sucursal = substr($table, 7); // Extraer nÃºmero de sucursal
            if (is_numeric($sucursal)) {
                $sucursales[] = $sucursal;
                error_log("Sucursal detectada: " . $sucursal . " de tabla: " . $table);
            }
        }
    }
    
    // TambiÃ©n intentar con un rango fijo para asegurar cobertura
    for ($i = 1; $i <= 10; $i++) {
        $tabla = "factcab" . $i;
        if ($this->db->table_exists($tabla) && !in_array($i, $sucursales)) {
            $sucursales[] = $i;
            error_log("Sucursal adicional detectada: " . $i);
        }
    }
    
    sort($sucursales); // Ordenar sucursales
    error_log("Sucursales finales: " . print_r($sucursales, true));
    return $sucursales;
}

/**
 * Endpoint de prueba para verificar sucursales disponibles
 */
public function test_sucursales_disponibles_get()
{
    $sucursales = $this->obtenerSucursalesDisponibles();
    
    $respuesta = array(
        "error" => false,
        "mensaje" => array(
            "sucursales_detectadas" => $sucursales,
            "total_sucursales" => count($sucursales)
        )
    );
    
    $this->response($respuesta);
}

/**
 * Endpoint de prueba para verificar datos por sucursal
 */
public function test_datos_por_sucursal_get()
{
    $idcli = $this->get('idcli');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');
    
    if (!$idcli || !$fecha_desde || !$fecha_hasta) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros: idcli, fecha_desde, fecha_hasta"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }
    
    $sucursales = $this->obtenerSucursalesDisponibles();
    $resultados = array();
    
    foreach ($sucursales as $sucursal) {
        $tabla = "factcab" . $sucursal;
        
        if ($this->db->table_exists($tabla)) {
            $query = "SELECT COUNT(*) as total FROM {$tabla} WHERE cliente = {$this->db->escape($idcli)} AND emitido >= {$this->db->escape($fecha_desde)} AND emitido <= {$this->db->escape($fecha_hasta)}";
            $result = $this->db->query($query)->row_array();
            
            $resultados[] = array(
                "sucursal" => $sucursal,
                "tabla" => $tabla,
                "registros" => $result['total']
            );
        }
    }
    
    $respuesta = array(
        "error" => false,
        "mensaje" => array(
            "cliente" => $idcli,
            "fecha_desde" => $fecha_desde,
            "fecha_hasta" => $fecha_hasta,
            "resultados_por_sucursal" => $resultados
        )
    );
    
    $this->response($respuesta);
}

/**
 * Obtiene los datos completos del recibo basÃ¡ndose en el id de factcabx
 * para historialventas2
 */
public function obtenerDatosRecibo2_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $id = $this->get('id');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$id) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e id"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaFactcab = "factcab" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tablaFactcab)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tablaFactcab no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Consultar datos completos de factcabx
        $this->db->select('*');
        $this->db->from($tablaFactcab);
        $this->db->where('id', $id);
        $query = $this->db->get();
        
        if ($query->num_rows() > 0) {
            $datos = $query->row_array();
            
            // Calcular importe total
            $excento = floatval($datos['excento']) ?: 0;
            $basico = floatval($datos['basico']) ?: 0;
            $iva1 = floatval($datos['iva1']) ?: 0;
            $iva2 = floatval($datos['iva2']) ?: 0;
            $iva3 = floatval($datos['iva3']) ?: 0;
            $datos['importe_total'] = $excento + $basico + $iva1 + $iva2 + $iva3;
            
            $respuesta = array(
                "error" => false,
                "mensaje" => "Datos del recibo obtenidos exitosamente",
                "data" => $datos
            );
        } else {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron datos para el recibo con ID: $id"
            );
        }

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos del recibo2: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene datos expandidos (recibos y psucursal) para una factura especÃ­fica
 * segÃºn las relaciones definidas en el diagrama DBML
 */
public function obtenerDatosExpandidos_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $id_factura = $this->get('id_factura');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$id_factura) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e id_factura"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaFactcab = "factcab" . $sucursal;
    $tablaRecibos = "recibos" . $sucursal;
    $tablaPsucursal = "psucursal" . $sucursal;

    // Verificar si las tablas existen
    if (!$this->db->table_exists($tablaFactcab) || !$this->db->table_exists($tablaRecibos) || !$this->db->table_exists($tablaPsucursal)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Una o mÃ¡s tablas no existen para la sucursal: $sucursal"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Obtener datos de recibos asociados a la factura
        // CORREGIDO: Usar cliente en lugar de numero_fac para evitar mezcla de datos
        
        // Primero obtener la factura para conseguir cliente y numero_fac
        $this->db->select('numero_fac, cliente');
        $this->db->from($tablaFactcab);
        $this->db->where('id_num', $id_factura);
        $queryFactura = $this->db->get();
        $factura = $queryFactura->row_array();
        
        if (!$factura) {
            throw new Exception("Factura no encontrada con id_num: $id_factura");
        }
        
        $numero_fac = $factura['numero_fac'];
        $cliente_id = $factura['cliente'];
        
        // Consulta UNION CORREGIDA para obtener recibos directos + recibos RC relacionados
        // CAMBIO CRÃTICO: Agregado filtro por cliente para evitar mezcla de datos entre clientes
        $query = "
            (
                SELECT 
                    r.recibo, r.c_tipo, r.c_numero, r.c_cuota, r.fecha, r.importe, 
                    r.usuario, r.observacion, r.cod_lugar, r.sesion, r.c_tipf, 
                    r.c_puntoventa, r.recibo_asoc, r.recibo_saldo, r.cod_sucursal,
                    r.fec_proceso, r.bonifica, r.bonifica_tipo, r.interes, r.interes_tipo, 
                    r.id_fac, 'DIRECTO' as origen
                FROM {$tablaRecibos} r
                WHERE r.id_fac = {$id_factura}
            )
            UNION ALL
            (
                SELECT 
                    r.recibo, r.c_tipo, r.c_numero, r.c_cuota, r.fecha, r.importe, 
                    r.usuario, r.observacion, r.cod_lugar, r.sesion, r.c_tipf, 
                    r.c_puntoventa, r.recibo_asoc, r.recibo_saldo, r.cod_sucursal,
                    r.fec_proceso, r.bonifica, r.bonifica_tipo, r.interes, r.interes_tipo, 
                    r.id_fac, 'RC' as origen
                FROM {$tablaRecibos} r
                INNER JOIN {$tablaFactcab} f ON r.id_fac = f.id_num
                WHERE r.recibo_asoc = {$id_factura} AND f.tipo = 'RC'
            )
            ORDER BY fecha DESC
        ";
        
        $queryRecibos = $this->db->query($query);
        $recibos = $queryRecibos->result_array();

        // NUEVO: Obtener historial de pagos de la factura (solo pagos reales RC)
        // CORREGIDO: Agregado filtro por cliente para evitar mezcla de datos
        $this->db->select('
            r.recibo,
            r.c_tipo,
            r.c_numero,
            r.fecha,
            r.importe,
            r.usuario,
            r.c_puntoventa,
            f.tipo as tipo_documento
        ');
        $this->db->from($tablaRecibos . ' r');
        $this->db->join($tablaFactcab . ' f', 'r.id_fac = f.id_num', 'left');
        $this->db->where('r.recibo_asoc', $id_factura);
        $this->db->where('f.tipo', 'RC');  // Filtrar solo pagos reales (Recibos de Cobro)
        $this->db->where('f.cliente', $cliente_id);  // CRÃTICO: Filtrar por cliente del documento original
        $this->db->order_by('r.fecha', 'ASC');
        $queryPagos = $this->db->get();
        $pagos = $queryPagos->result_array();

        // Calcular total pagado
        $total_pagado = 0;
        foreach ($pagos as $pago) {
            $total_pagado += (float)$pago['importe'];
        }

        // ELIMINADO: Consulta duplicada ya no necesaria - el cliente_id se obtiene al principio

        // Para cada recibo, obtener sus productos especÃ­ficos
        foreach ($recibos as $index => $recibo) {
            // Debug: log de los valores que estamos buscando
            error_log("Buscando productos para recibo: " . $recibo['recibo'] . 
                     " - recibo_asoc: " . $recibo['recibo_asoc'] . 
                     " - cliente_id: " . $cliente_id);
            $this->db->select('
                p.idart,
                p.cantidad,
                p.precio,
                p.idcli,
                p.idven,
                p.fecha,
                p.hora,
                p.tipoprecio,
                p.cod_tar,
                t.tarjeta,
                p.titulartar,
                p.numerotar,
                p.cod_mov,
                p.suc_destino,
                p.nomart,
                p.nautotar,
                p.dni_tar,
                p.banco,
                p.ncuenta,
                p.ncheque,
                p.nombre,
                p.plaza,
                p.importeimputar,
                p.importecheque,
                p.fechacheque,
                p.emailop,
                p.tipodoc,
                p.puntoventa,
                p.numerocomprobante,
                p.estado,
                p.id_num
            ');
            $this->db->from($tablaPsucursal . ' p');
            $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
            $this->db->where('p.id_num', $recibo['recibo_asoc']);
            if ($cliente_id) {
                $this->db->where('p.idcli', trim($cliente_id));
            }
            $this->db->order_by('p.fecha', 'DESC');
            $this->db->order_by('p.hora', 'DESC');
            
            $queryProductos = $this->db->get();
            $productos = $queryProductos->result_array();
            
            // Debug: log del resultado
            error_log("Productos encontrados para recibo " . $recibo['recibo'] . ": " . count($productos));
            if (count($productos) > 0) {
                error_log("Primer producto: " . json_encode($productos[0]));
            }
            
            // Agregar productos al recibo
            $recibos[$index]['productos'] = $productos;
        }

        // Preparar respuesta con datos expandidos incluyendo historial de pagos
        $datosExpandidos = array(
            'recibos' => $recibos,
            'historialPagos' => $pagos,
            'totalPagado' => $total_pagado
        );

        $respuesta = array(
            "error" => false,
            "mensaje" => "Datos expandidos obtenidos exitosamente",
            "data" => $datosExpandidos
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos expandidos: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Genera una descripciÃ³n automÃ¡tica para movimientos de caja tipo 'A'
 * basada en el patrÃ³n: tipo_comprobante + numero_comprobante + Rec. NÂº + numero_recibo
 */
private function generarDescripcionAutomatica($data) {
    $tipo_comprobante = isset($data['tipo_comprobante']) ? $data['tipo_comprobante'] : '';
    $numero_comprobante = isset($data['numero_comprobante']) ? $data['numero_comprobante'] : '';
    $num_operacion = isset($data['num_operacion']) ? $data['num_operacion'] : '';
    
    // Si no hay datos suficientes, usar descripciÃ³n por defecto
    if (empty($tipo_comprobante) && empty($numero_comprobante)) {
        return 'Movimiento automÃ¡tico';
    }
    
    // Formato: "FC     21 Rec. NÂº 100000"
    $descripcion = '';
    
    if (!empty($tipo_comprobante)) {
        $descripcion .= $tipo_comprobante;
    }
    
    if (!empty($numero_comprobante)) {
        // Agregar espacios para formato consistente (ajustar segÃºn necesidad)
        $descripcion .= str_repeat(' ', max(1, 6 - strlen($tipo_comprobante))) . $numero_comprobante;
    }
    
    if (!empty($num_operacion)) {
        $descripcion .= ' Rec. NÂº ' . $num_operacion;
    }
    
    // Asegurar que la descripciÃ³n no exceda 80 caracteres (lÃ­mite del campo)
    return substr($descripcion, 0, 80);
}

/**
 * Valida que una fecha tenga el formato YYYY-MM-DD
 */
private function validarFormatoFecha($fecha) {
    // Verificar formato bÃ¡sico con regex
    if (!preg_match('/^\d{4}-\d{2}-\d{2}$/', $fecha)) {
        return false;
    }
    
    // Verificar que sea una fecha vÃ¡lida
    $parts = explode('-', $fecha);
    return checkdate((int)$parts[1], (int)$parts[2], (int)$parts[0]);
}

// ==================== MÃ‰TODO PARA CAMBIO MASIVO DE PRECIOS ====================

public function PriceUpdate_post()
{
    try {
        $data = $this->post();
        
        // Validar datos requeridos
        if (!isset($data['tipo_modificacion']) || !isset($data['porcentaje'])) {
            $this->response([
                'error' => true,
                'mensaje' => 'Faltan parÃ¡metros requeridos: tipo_modificacion, porcentaje'
            ], 400);
            return;
        }
        
        // Preparar parÃ¡metros
        $marca = isset($data['marca']) ? $data['marca'] : null;
        $cd_proveedor = isset($data['cd_proveedor']) ? intval($data['cd_proveedor']) : null;
        $rubro = isset($data['rubro']) ? $data['rubro'] : null;
        $cod_iva = isset($data['cod_iva']) ? intval($data['cod_iva']) : null;
        $tipo_modificacion = $data['tipo_modificacion'];
        $porcentaje = floatval($data['porcentaje']);
        $sucursal = isset($data['sucursal']) ? intval($data['sucursal']) : 1;
        $observacion = isset($data['observacion']) ? $data['observacion'] : 'Cambio masivo desde aplicaciÃ³n web';
        $usuario = isset($data['usuario']) && !empty($data['usuario']) 
            ? $data['usuario'] 
            : 'usuario_desconocido';
        
        // Construir descripciÃ³n inteligente para auditorÃ­a
        $tipo_descriptivo = "ACTUALIZACIÃ“N POR ";
        
        if (!empty($marca)) {
            $tipo_descriptivo .= "MARCA (" . trim($marca) . ") Y ";
        } elseif (!empty($rubro)) {
            $tipo_descriptivo .= "RUBRO (" . trim($rubro) . ") Y ";
        } elseif (!empty($cd_proveedor)) {
            $tipo_descriptivo .= "PROVEEDOR (" . $cd_proveedor . ") Y ";
        } elseif (!empty($cod_iva)) {
            $tipo_descriptivo .= "TIPO IVA (" . $cod_iva . ") Y ";
        } else {
            $tipo_descriptivo .= "FILTRO MÃšLTIPLE Y ";
        }
        
        $tipo_descriptivo .= strtoupper($tipo_modificacion);
        
        // Iniciar transacciÃ³n
        $this->db->trans_begin();
        
        // âœ… NUEVO: Detectar si usar funciÃ³n atÃ³mica o clÃ¡sica
        $use_atomic = isset($data['atomic']) && $data['atomic'] === true;
        
        if ($use_atomic) {
            // Llamar a la funciÃ³n ATÃ“MICA que actualiza precios Y conflistas
            $sql = "SELECT update_precios_masivo_atomico(?, ?, ?, ?, ?, ?, ?, ?) as result";
            $params = array(
                $marca, 
                $cd_proveedor, 
                $rubro, 
                $cod_iva, 
                $tipo_descriptivo,  // DescripciÃ³n inteligente incluyendo "ATOMICO"
                $porcentaje, 
                $sucursal, 
                $usuario
            );
        } else {
            // Llamar a la funciÃ³n CLÃSICA (compatibilidad legacy)
            $sql = "SELECT update_precios_masivo(?, ?, ?, ?, ?, ?, ?, ?) as result";
            $params = array(
                $marca, 
                $cd_proveedor, 
                $rubro, 
                $cod_iva, 
                $tipo_descriptivo,  // DescripciÃ³n inteligente en lugar de tipo_modificacion
                $porcentaje, 
                $sucursal, 
                $usuario            // Sin observacion - ahora posiciÃ³n 8
            );
        }
        
        $query = $this->db->query($sql, $params);
        
        if ($query && $query->num_rows() > 0) {
            $row = $query->row();
            $result_json = $row->result;
            $result = json_decode($result_json, true);
            
            if ($result && $result['success']) {
                // Commit la transacciÃ³n
                $this->db->trans_commit();
                
                // âœ… MEJORADO: Agregar informaciÃ³n especÃ­fica de operaciÃ³n atÃ³mica
                $response_data = [
                    'error' => false,
                    'result' => $result_json,
                    'atomic_operation' => $use_atomic,  // Indicar si fue operaciÃ³n atÃ³mica
                    'function_used' => $use_atomic ? 'update_precios_masivo_atomico' : 'update_precios_masivo'
                ];
                
                // Si fue operaciÃ³n atÃ³mica, agregar detalles adicionales
                if ($use_atomic && isset($result['conflistas_actualizadas'])) {
                    $response_data['conflistas_actualizadas'] = $result['conflistas_actualizadas'];
                }
                
                $this->response($response_data);
            } else {
                // Rollback en caso de error
                $this->db->trans_rollback();
                
                $error_message = isset($result['message']) ? $result['message'] : 'Error desconocido en la actualizaciÃ³n';
                
                // âœ… MEJORADO: Respuesta de error con contexto atÃ³mico
                $error_response = [
                    'error' => true,
                    'mensaje' => $error_message,
                    'atomic_operation' => $use_atomic,
                    'rollback_executed' => true
                ];
                
                // Si fue error atÃ³mico, incluir informaciÃ³n especÃ­fica
                if ($use_atomic && isset($result['rollback_completo'])) {
                    $error_response['rollback_completo'] = $result['rollback_completo'];
                    $error_response['sqlstate'] = $result['sqlstate'] ?? null;
                }
                
                $this->response($error_response, 500);
            }
        } else {
            // Rollback en caso de error
            $this->db->trans_rollback();
            
            $this->response([
                'error' => true,
                'mensaje' => 'No se pudo ejecutar la actualizaciÃ³n masiva de precios'
            ], 500);
        }
        
    } catch (Exception $e) {
        // Rollback en caso de excepciÃ³n
        $this->db->trans_rollback();
        
        $this->response([
            'error' => true,
            'mensaje' => 'Error interno: ' . $e->getMessage()
        ], 500);
    }
}

// ============================================================================
// ============================================================================
//
//        ALTERNATIVA C - GRANULARIDAD CAJAMOVI (HÃBRIDA)
//        ImplementaciÃ³n: 14 de Octubre de 2025
//
//        Estas funciones implementan el enfoque hÃ­brido donde:
//        1. Frontend calcula y envÃ­a subtotales por mÃ©todo de pago
//        2. Backend valida recalculando desde productos
//        3. Si coinciden â†’ usa frontend (eficiente)
//        4. Si difieren â†’ usa recalculados (seguro) + log warning
//
// ============================================================================
// ============================================================================

/**
 * ============================================================================
 * FUNCIÃ“N PRINCIPAL: procesarSubtotalesHibrido()
 * ============================================================================
 *
 * NÃºcleo de la Alternativa C - ValidaciÃ³n HÃ­brida
 *
 * Procesa subtotales usando enfoque hÃ­brido: valida frontend con recÃ¡lculo backend
 *
 * @param array|null $subtotales_frontend Subtotales recibidos del frontend
 *        Formato: [{cod_tarj: 11, importe_detalle: 10000}, {cod_tarj: 1, importe_detalle: 5000}]
 *
 * @param array $productos Array de productos insertados con cod_tar
 *        Formato: [{cod_tar: 11, precio: 100, cantidad: 100}, ...]
 *
 * @param float $total_movimiento Total del movimiento para validaciÃ³n
 *
 * @param int $id_movimiento ID del movimiento (para logs)
 *
 * @return array Subtotales validados listos para insertar
 *         Formato: [cod_tarj => importe_detalle]
 *         Ejemplo: [11 => 10000.00, 1 => 5000.00]
 *
 * FLUJO DE DECISIÃ“N:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ Â¿Frontend enviÃ³ subtotales vÃ¡lidos? â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                â”‚
 *       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
 *       â”‚ NO              â”‚ SÃ
 *       v                 v
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ Recalcularâ”‚    â”‚ Recalcular para  â”‚
 *   â”‚ desde     â”‚    â”‚ validar          â”‚
 *   â”‚ productos â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜             â”‚
 *         â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
 *         â”‚            â”‚ Â¿Coinciden? â”‚
 *         â”‚            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
 *         â”‚                   â”‚
 *         â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
 *         â”‚          â”‚ SÃ              â”‚ NO
 *         â”‚          v                 v
 *         â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *         â”‚     â”‚ Usar   â”‚      â”‚ Usar     â”‚
 *         â”‚     â”‚Frontendâ”‚      â”‚Recalc +  â”‚
 *         â”‚     â”‚        â”‚      â”‚Warning   â”‚
 *         â”‚     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
 *         â”‚          â”‚               â”‚
 *         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                    â”‚
 *                    v
 *         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *         â”‚ Subtotales listos  â”‚
 *         â”‚ para insertar en   â”‚
 *         â”‚ caja_movi_detalle  â”‚
 *         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */
private function procesarSubtotalesHibrido(
    $subtotales_frontend,
    $productos,
    $total_movimiento,
    $id_movimiento
) {
    // ğŸ” LOG: Entrada de la funciÃ³n
    log_message('info', "ğŸ” procesarSubtotalesHibrido - Movimiento {$id_movimiento}, Total: {$total_movimiento}");
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - Subtotales frontend: ' . json_encode($subtotales_frontend));
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - Cantidad productos: ' . count($productos));

    // ========================================================================
    // 1ï¸âƒ£ VALIDACIÃ“N: Â¿Vienen subtotales del frontend?
    // ========================================================================
    $frontend_valido = is_array($subtotales_frontend) && !empty($subtotales_frontend);
    log_message('info', "ğŸ” procesarSubtotalesHibrido - Frontend vÃ¡lido: " . ($frontend_valido ? 'SÃ' : 'NO'));

    // ========================================================================
    // 2ï¸âƒ£ RECALCULAR desde productos (para validaciÃ³n)
    // ========================================================================
    $subtotales_recalculados = $this->calcularSubtotalesPorMetodoPago(
        $productos,
        $total_movimiento
    );
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - Subtotales recalculados: ' . json_encode($subtotales_recalculados));

    // ========================================================================
    // 3ï¸âƒ£ DECISIÃ“N HÃBRIDA
    // ========================================================================

    // CASO A: Frontend NO enviÃ³ subtotales â†’ Usar recalculados
    if (!$frontend_valido) {
        log_message('info', "ğŸ” CASO A - Movimiento {$id_movimiento}: Usando subtotales recalculados (frontend no enviÃ³ datos)");
        return $subtotales_recalculados;
    }

    // CASO B: No se pudo recalcular â†’ Usar frontend (confiamos)
    if (empty($subtotales_recalculados)) {
        log_message('warning', "ğŸ” CASO B - Movimiento {$id_movimiento}: No se pudo recalcular. Usando subtotales de frontend sin validaciÃ³n");
        $resultado_frontend = $this->formatearSubtotalesFrontend($subtotales_frontend);
        log_message('info', 'ğŸ” CASO B - Resultado frontend formateado: ' . json_encode($resultado_frontend));
        return $resultado_frontend;
    }

    // CASO C: Comparar frontend vs recalculados
    $comparacion = $this->compararSubtotales(
        $subtotales_frontend,
        $subtotales_recalculados
    );
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - ComparaciÃ³n: ' . json_encode($comparacion));

    if ($comparacion['coinciden']) {
        // âœ… COINCIDEN â†’ Usar frontend (mÃ¡s eficiente)
        log_message('info', "ğŸ” CASO C (COINCIDEN) - Movimiento {$id_movimiento}: Subtotales frontend validados âœ“ " .
                    "Coinciden con recÃ¡lculo backend (diff mÃ¡x: {$comparacion['diferencia_max']})");
        $resultado_frontend = $this->formatearSubtotalesFrontend($subtotales_frontend);
        log_message('info', 'ğŸ” CASO C (COINCIDEN) - Resultado frontend formateado: ' . json_encode($resultado_frontend));
        return $resultado_frontend;
    } else {
        // âš ï¸ DISCREPANCIA â†’ Usar recalculados (mÃ¡s seguro)
        log_message('warning', "ğŸ” CASO C (DISCREPANCIA) - Movimiento {$id_movimiento}: DISCREPANCIA detectada. " .
                    "Diferencia mÃ¡xima: {$comparacion['diferencia_max']}. " .
                    "Usando subtotales recalculados por seguridad");

        // Notificar discrepancia al administrador (opcional)
        $this->notificarDiscrepancia($id_movimiento, $comparacion);

        log_message('info', 'ğŸ” CASO C (DISCREPANCIA) - Retornando subtotales recalculados: ' . json_encode($subtotales_recalculados));
        return $subtotales_recalculados;
    }
}

/**
 * ============================================================================
 * FUNCIÃ“N: calcularSubtotalesPorMetodoPago()
 * ============================================================================
 *
 * Recalcula subtotales por mÃ©todo de pago desde array de productos
 * Usado para validaciÃ³n en el enfoque hÃ­brido
 *
 * @param array $productos Array de productos con cod_tar, precio, cantidad
 * @param float $total_movimiento Total del movimiento para validaciÃ³n
 *
 * @return array Subtotales por mÃ©todo de pago
 *         Formato: [cod_tarj => importe_total]
 *         Ejemplo: [11 => 10000.00, 1 => 5000.00]
 */
private function calcularSubtotalesPorMetodoPago($productos, $total_movimiento) {
    // ğŸ” LOG: Entrada
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Total movimiento: ' . $total_movimiento);
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Cantidad productos: ' . count($productos));

    $subtotales_map = array();

    if (empty($productos)) {
        log_message('error', 'ğŸ” calcularSubtotalesPorMetodoPago: Array de productos vacÃ­o');
        return $subtotales_map;
    }

    // Agrupar productos por cod_tar y sumar importes
    foreach ($productos as $index => $producto) {
        $cod_tar = isset($producto['cod_tar']) ? intval($producto['cod_tar']) : null;

        // ğŸ” LOG: Cada producto
        log_message('info', "ğŸ” calcularSubtotalesPorMetodoPago - Producto #{$index}: " . json_encode($producto));

        if ($cod_tar === null || $cod_tar === 0) {
            log_message('warning', 'ğŸ” calcularSubtotalesPorMetodoPago - Producto sin cod_tar: ' .
                        json_encode($producto));
            continue;
        }

        $cantidad = isset($producto['cantidad']) ? floatval($producto['cantidad']) : 0;
        $precio = isset($producto['precio']) ? floatval($producto['precio']) : 0;
        $importe_producto = round($cantidad * $precio, 2);

        // ğŸ” LOG: CÃ¡lculo
        log_message('info', "ğŸ” calcularSubtotalesPorMetodoPago - cod_tar={$cod_tar}, cant={$cantidad}, precio={$precio}, importe={$importe_producto}");

        if (!isset($subtotales_map[$cod_tar])) {
            $subtotales_map[$cod_tar] = 0;
        }
        $subtotales_map[$cod_tar] += $importe_producto;
    }

    // ğŸ” LOG: Mapa antes de validar
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Mapa acumulado: ' . json_encode($subtotales_map));

    // Validar que la suma de subtotales = total del movimiento
    $suma_subtotales = array_sum($subtotales_map);
    $diferencia = abs($suma_subtotales - $total_movimiento);

    // ğŸ” LOG: ValidaciÃ³n
    log_message('info', "ğŸ” calcularSubtotalesPorMetodoPago - Suma subtotales: {$suma_subtotales}, Total: {$total_movimiento}, Diferencia: {$diferencia}");

    if ($diferencia > 0.01) {
        log_message('error', "ğŸ” calcularSubtotalesPorMetodoPago - ERROR: Diferencia > 0.01. " .
                    "Suma: {$suma_subtotales}, Total: {$total_movimiento}, Dif: {$diferencia}");
        return array();
    }

    // Redondear todos los importes a 2 decimales
    foreach ($subtotales_map as $cod_tar => $importe) {
        $subtotales_map[$cod_tar] = round($importe, 2);
    }

    // ğŸ” LOG: Resultado final
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Resultado final: ' . json_encode($subtotales_map));

    return $subtotales_map;
}

/**
 * ============================================================================
 * FUNCIÃ“N: compararSubtotales()
 * ============================================================================
 *
 * Compara subtotales del frontend con los recalculados por el backend
 *
 * @param array $subtotales_frontend [{cod_tarj: 11, importe_detalle: 10000}, ...]
 * @param array $subtotales_recalc [11 => 10000, 1 => 5000, ...]
 *
 * @return array Resultado de la comparaciÃ³n
 *         [
 *           'coinciden' => bool,           // TRUE si diferencia <= tolerancia
 *           'diferencia_max' => float,     // Diferencia mÃ¡xima encontrada
 *           'diferencias' => array         // Detalles de cada diferencia
 *         ]
 */
private function compararSubtotales($subtotales_frontend, $subtotales_recalc) {
    $tolerancia = 0.01; // 1 centavo de tolerancia por redondeos
    $diferencia_max = 0;
    $diferencias = array();

    // Convertir arrays a mapas por cod_tarj para comparaciÃ³n fÃ¡cil
    $map_frontend = array();
    foreach ($subtotales_frontend as $sub) {
        $cod_tarj = intval($sub['cod_tarj']);
        $importe = floatval($sub['importe_detalle']);
        $map_frontend[$cod_tarj] = $importe;
    }

    // $subtotales_recalc ya viene como [cod_tar => importe]
    $map_backend = $subtotales_recalc;

    // Obtener todos los cÃ³digos de tarjeta Ãºnicos de ambos arrays
    $cod_tarj_todos = array_unique(
        array_merge(
            array_keys($map_frontend),
            array_keys($map_backend)
        )
    );

    // Comparar cada mÃ©todo de pago
    foreach ($cod_tarj_todos as $cod_tarj) {
        $importe_frontend = isset($map_frontend[$cod_tarj]) ? $map_frontend[$cod_tarj] : 0;
        $importe_backend = isset($map_backend[$cod_tarj]) ? $map_backend[$cod_tarj] : 0;
        $diferencia = abs($importe_frontend - $importe_backend);

        // Actualizar diferencia mÃ¡xima
        if ($diferencia > $diferencia_max) {
            $diferencia_max = $diferencia;
        }

        // Registrar diferencias significativas
        if ($diferencia > $tolerancia) {
            $diferencias[] = array(
                'cod_tarj' => $cod_tarj,
                'frontend' => $importe_frontend,
                'backend' => $importe_backend,
                'diferencia' => $diferencia
            );
        }
    }

    return array(
        'coinciden' => ($diferencia_max <= $tolerancia),
        'diferencia_max' => round($diferencia_max, 2),
        'diferencias' => $diferencias
    );
}

/**
 * ============================================================================
 * FUNCIÃ“N: formatearSubtotalesFrontend()
 * ============================================================================
 *
 * Formatea subtotales del frontend a array asociativo [cod_tarj => importe]
 *
 * @param array $subtotales_frontend [{cod_tarj: 11, importe_detalle: 10000}, ...]
 *
 * @return array [cod_tarj => importe_detalle]
 */
private function formatearSubtotalesFrontend($subtotales_frontend) {
    // ğŸ” LOG: Entrada de la funciÃ³n
    log_message('info', 'ğŸ” formatearSubtotalesFrontend - Entrada: ' . json_encode($subtotales_frontend));

    $resultado = array();

    foreach ($subtotales_frontend as $item) {
        $cod_tarj = intval($item['cod_tarj']);
        $importe = round(floatval($item['importe_detalle']), 2);
        $resultado[$cod_tarj] = $importe;

        // ğŸ” LOG: Cada elemento procesado
        log_message('info', "ğŸ” formatearSubtotalesFrontend - Procesado: cod_tarj={$cod_tarj}, importe={$importe}");
    }

    // ğŸ” LOG: Resultado final
    log_message('info', 'ğŸ” formatearSubtotalesFrontend - Resultado: ' . json_encode($resultado));

    return $resultado;
}

/**
 * ============================================================================
 * FUNCIÃ“N: insertarDetallesMetodosPago()
 * ============================================================================
 *
 * Inserta detalles de mÃ©todos de pago en caja_movi_detalle
 *
 * @param int $id_movimiento ID del movimiento padre
 * @param array $subtotales Array asociativo [cod_tarj => importe]
 * @param float $total_movimiento Total para calcular porcentaje
 *
 * @throws Exception Si falla alguna inserciÃ³n
 */
private function insertarDetallesMetodosPago($id_movimiento, $subtotales, $total_movimiento) {
    // ğŸ” LOG: Entrada de la funciÃ³n
    log_message('info', "ğŸ” insertarDetallesMetodosPago - ID Movimiento: {$id_movimiento}, Total: {$total_movimiento}");
    log_message('info', 'ğŸ” insertarDetallesMetodosPago - Subtotales recibidos: ' . json_encode($subtotales));
    log_message('info', 'ğŸ” insertarDetallesMetodosPago - Cantidad de subtotales: ' . count($subtotales));

    if (empty($subtotales)) {
        log_message('warning', "insertarDetallesMetodosPago: Array de subtotales vacÃ­o para movimiento {$id_movimiento}");
        return;
    }

    $contador = 0;
    foreach ($subtotales as $cod_tarj => $importe_detalle) {
        $contador++;

        // ğŸ” LOG: Cada iteraciÃ³n
        log_message('info', "ğŸ” insertarDetallesMetodosPago - IteraciÃ³n #{$contador}: cod_tarj={$cod_tarj}, importe={$importe_detalle}");

        // Calcular porcentaje
        $porcentaje = ($total_movimiento > 0)
            ? round(($importe_detalle / $total_movimiento) * 100, 2)
            : 0;

        $detalle = array(
            'id_movimiento' => $id_movimiento,
            'cod_tarj' => $cod_tarj,
            'importe_detalle' => round($importe_detalle, 2),
            'porcentaje' => $porcentaje
        );

        // ğŸ” LOG: Datos a insertar
        log_message('info', 'ğŸ” insertarDetallesMetodosPago - Datos a insertar: ' . json_encode($detalle));

        $this->db->insert('caja_movi_detalle', $detalle);

        // ğŸ” LOG: Resultado de inserciÃ³n
        $affected = $this->db->affected_rows();
        log_message('info', "ğŸ” insertarDetallesMetodosPago - Filas afectadas: {$affected}");

        if ($affected === 0) {
            log_message('error', "ğŸ” insertarDetallesMetodosPago - ERROR: No se insertÃ³ el registro para cod_tarj {$cod_tarj}");
            throw new Exception("Error al insertar detalle para cod_tarj {$cod_tarj} en movimiento {$id_movimiento}");
        }
    }

    log_message('info', "ğŸ” insertarDetallesMetodosPago - COMPLETADO: {$contador} de " . count($subtotales) . " detalles insertados en caja_movi_detalle");
}

/**
 * ============================================================================
 * FUNCIÃ“N: notificarDiscrepancia() (OPCIONAL)
 * ============================================================================
 *
 * Notifica discrepancia al administrador cuando hay diferencias entre
 * los subtotales del frontend y los recalculados por el backend
 *
 * Implementar segÃºn necesidades:
 * - Email al administrador
 * - Log en tabla de auditorÃ­a
 * - Alerta en dashboard
 *
 * @param int $id_movimiento ID del movimiento con discrepancia
 * @param array $comparacion Resultado de compararSubtotales()
 */
private function notificarDiscrepancia($id_movimiento, $comparacion) {
    // Por ahora, solo log detallado
    // TODO: Implementar notificaciÃ³n por email/dashboard segÃºn requerimientos

    log_message('error', "AUDITORÃA: Discrepancia en movimiento {$id_movimiento}. " .
                "Diferencia mÃ¡xima: {$comparacion['diferencia_max']}. " .
                "Detalles: " . json_encode($comparacion['diferencias']));

    // Ejemplo de implementaciÃ³n futura:
    // $this->enviarEmailAdministrador(
    //     'Discrepancia en Cajamovi',
    //     "Se detectÃ³ una discrepancia en el movimiento {$id_movimiento}..."
    // );

    // O insertar en tabla de auditorÃ­a:
    // $this->db->insert('auditoria_discrepancias', [
    //     'id_movimiento' => $id_movimiento,
    //     'diferencia_max' => $comparacion['diferencia_max'],
    //     'detalles_json' => json_encode($comparacion['diferencias']),
    //     'fecha_deteccion' => date('Y-m-d H:i:s')
    // ]);
}

// ============================================================================
//                     FIN ALTERNATIVA C - GRANULARIDAD CAJAMOVI
// ============================================================================

// ============================================================================
//                     SISTEMA DE CANCELACIÃ“N MOV.STOCK
// ============================================================================

/**
 * FUNCIÃ“N: CancelarPedido_post()
 *
 * Cancela o rechaza pedidos de stock segÃºn el tipo de cancelaciÃ³n y estado actual.
 * Implementa validaciones de permisos por rol y mantiene auditorÃ­a completa.
 *
 * TIPOS DE CANCELACIÃ“N:
 * - 'solicitante': Cancelado por quien solicitÃ³ (estado "Solicitado")
 * - 'rechazado': Rechazado por quien debe enviar (estado "Solicitado")
 * - 'problema': Problema reportado en trÃ¡nsito (estado "Solicitado-E")
 *
 * ESTADOS NUEVOS:
 * - 'Cancel-Sol': Cancelado por Solicitante
 * - 'Cancel-Rech': Rechazado por Receptor
 * - 'En-Revision': Problema reportado, requiere revisiÃ³n
 *
 * PERMISOS:
 * - SUPER/ADMIN: Pueden cancelar cualquier estado
 * - USER: Solo puede cancelar sus propias solicitudes en estado "Solicitado" o "Solicitado-E"
 *
 * @date 2025-10-31
 */
public function CancelarPedido_post() {
    $data = $this->post();

    // Validar datos requeridos
    if(!isset($data['id_num']) || !isset($data['motivo']) || !isset($data['tipo_cancelacion'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos requeridos: id_num, motivo, tipo_cancelacion"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $id_num = $data['id_num'];
    $motivo = trim($data['motivo']);
    $tipo_cancelacion = $data['tipo_cancelacion']; // 'solicitante', 'rechazado', 'problema'
    $usuario = isset($data['usuario']) ? $data['usuario'] : '';
    $rol = isset($data['rol']) ? $data['rol'] : 'USER'; // SUPER, ADMIN, USER

    // Validar que el motivo no estÃ© vacÃ­o
    if(empty($motivo)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "El motivo de cancelaciÃ³n es obligatorio"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Iniciar transacciÃ³n
    $this->db->trans_start();

    // Determinar nuevo estado segÃºn tipo de cancelaciÃ³n
    switch($tipo_cancelacion) {
        case 'solicitante':
            $nuevo_estado = 'Cancel-Sol';
            break;
        case 'rechazado':
            $nuevo_estado = 'Cancel-Rech';
            break;
        case 'problema':
            $nuevo_estado = 'En-Revision';
            break;
        default:
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "Tipo de cancelaciÃ³n invÃ¡lido: " . $tipo_cancelacion
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
    }

    // Obtener pedido actual
    $query = $this->db->query("SELECT estado, usuario FROM pedidoscb WHERE id_num = ?", [$id_num]);

    if ($query->num_rows() === 0) {
        $this->db->trans_rollback();
        $respuesta = array(
            "error" => true,
            "mensaje" => "Pedido no encontrado con id_num: " . $id_num
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    $pedido = $query->row_array();
    $estado_actual = trim($pedido['estado']);
    $usuario_pedido = trim($pedido['usuario']);

    // VALIDACIÃ“N DE PERMISOS POR ROL
    if ($rol === 'user') {
        // USER solo puede cancelar sus propias solicitudes
        if ($usuario_pedido !== $usuario) {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "No tiene permisos para cancelar solicitudes de otros usuarios"
            );
            $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
            return;
        }

        // USER solo puede cancelar estados "Solicitado" o reportar problema "Solicitado-E"
        if (!in_array($estado_actual, ['Solicitado', 'Solicitado-E'])) {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "No tiene permisos para cancelar pedidos en estado: " . $estado_actual
            );
            $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
            return;
        }

        // USER no puede rechazar solicitudes (solo SUPER/ADMIN)
        if ($tipo_cancelacion === 'rechazado') {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "No tiene permisos para rechazar solicitudes. Solo puede cancelar sus propias solicitudes."
            );
            $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
            return;
        }
    }

    // SUPER y ADMIN pueden cancelar cualquier estado (sin validaciones adicionales)

    // Validar que el estado permita cancelaciÃ³n (solo para USER)
    if ($rol === 'user') {
        $estados_cancelables = ['Solicitado', 'Solicitado-E'];
        if (!in_array($estado_actual, $estados_cancelables)) {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se puede cancelar un pedido en estado: " . $estado_actual
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
    }

    // Validar tipo de cancelaciÃ³n segÃºn estado
    if ($estado_actual === 'Solicitado' && $tipo_cancelacion === 'problema') {
        $this->db->trans_rollback();
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se puede reportar problema en estado Solicitado. Use cancelaciÃ³n normal."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Actualizar pedidoscb
    $sql_update_cab = "
        UPDATE pedidoscb
        SET estado = ?,
            motivo_cancelacion = ?,
            fecha_cancelacion = CURRENT_DATE,
            usuario_cancelacion = ?
        WHERE id_num = ?
    ";
    $this->db->query($sql_update_cab, [$nuevo_estado, $motivo, $usuario, $id_num]);

    // Actualizar pedidoitem - agregar motivo a observaciÃ³n
    $sql_update_item = "
        UPDATE pedidoitem
        SET estado = ?,
            observacion = CONCAT(COALESCE(observacion, ''), ' | CANCELADO: ', ?)
        WHERE id_num = ?
    ";
    $this->db->query($sql_update_item, [$nuevo_estado, $motivo, $id_num]);

    // Completar transacciÃ³n
    $this->db->trans_complete();

    if ($this->db->trans_status() === FALSE) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al cancelar el pedido. La transacciÃ³n ha sido revertida."
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    } else {
        // Log de auditorÃ­a
        log_message('info', "âœ… Pedido cancelado - ID: {$id_num}, Estado anterior: {$estado_actual}, Nuevo estado: {$nuevo_estado}, Usuario: {$usuario}, Tipo: {$tipo_cancelacion}");

        $respuesta = array(
            "error" => false,
            "mensaje" => "Pedido cancelado exitosamente",
            "nuevo_estado" => $nuevo_estado,
            "estado_anterior" => $estado_actual
        );
        $this->response($respuesta);
    }

    // Nota: Si el estado era "Solicitado-E" y se reporta problema,
    // NO revertir stocks automÃ¡ticamente (requiere revisiÃ³n manual por ADMIN/SUPER)
}

// ============================================================================
//                     FIN SISTEMA DE CANCELACIÃ“N MOV.STOCK
// ============================================================================

// ============================================================================
//                  SISTEMA DE ALTA DE EXISTENCIAS
// ============================================================================
// CreaciÃ³n de alta de existencias en sucursal
// Autor: Sistema MotoApp
// Fecha: 2025-01-04
// DescripciÃ³n: Permite dar de alta existencias directamente en una sucursal
//              sin necesidad de transferencia entre sucursales.
// ============================================================================

/**
 * Crear Alta de Existencias
 *
 * Registra un alta de existencias en pedidoitem/pedidoscb y actualiza
 * automÃ¡ticamente el stock en artsucursal.
 *
 * @method POST
 * @param array pedidoitem - Datos del item (cantidad, id_art, etc.)
 * @param array pedidoscb - Datos de cabecera (sucursal, usuario, etc.)
 * @return JSON - Respuesta con resultado de la operaciÃ³n
 */
public function AltaExistencias_post() {
    $data = $this->post();

    // Validar que llegaron los datos necesarios
    if(!isset($data['pedidoitem']) || !isset($data['pedidoscb'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requieren pedidoitem y pedidoscb."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $pedidoItem = $data['pedidoitem'];
    $pedidoscb = $data['pedidoscb'];

    // ============================================================================
    // VALIDACIONES DE DATOS
    // ============================================================================

    // Validar cantidad > 0
    if (!isset($pedidoItem['cantidad']) || $pedidoItem['cantidad'] <= 0) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La cantidad debe ser mayor a 0"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar que id_art sea vÃ¡lido
    if (!isset($pedidoItem['id_art']) || $pedidoItem['id_art'] == 0 || empty($pedidoItem['id_art'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "ID de artÃ­culo invÃ¡lido. No se puede crear el alta."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar que sucursald === sucursalh (sin transferencia)
    if (!isset($pedidoscb['sucursald']) || !isset($pedidoscb['sucursalh']) ||
        $pedidoscb['sucursald'] != $pedidoscb['sucursalh']) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Para altas de existencias, ambas sucursales deben ser iguales (sin transferencia)"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar observaciÃ³n (mÃ­nimo 10 caracteres)
    if (!isset($pedidoItem['observacion']) || strlen(trim($pedidoItem['observacion'])) < 10) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La observaciÃ³n debe tener al menos 10 caracteres explicando el motivo del alta"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar que el producto exista
    $query_producto = $this->db->query(
        "SELECT id_articulo, nomart FROM artsucursal WHERE id_articulo = ?",
        [$pedidoItem['id_art']]
    );

    if ($query_producto->num_rows() == 0) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "El producto con ID " . $pedidoItem['id_art'] . " no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    // ============================================================================
    // INICIAR TRANSACCIÃ“N
    // ============================================================================

    $this->db->trans_start();

    try {
        // ============================================================================
        // 1. INSERTAR EN PEDIDOITEM
        // ============================================================================

        $sql_pedidoitem = "INSERT INTO pedidoitem
            (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado)
            VALUES (?, ?, ?, ?, ?, CURRENT_DATE, ?, ?, 'ALTA')
            RETURNING id_items";

        $query = $this->db->query($sql_pedidoitem, [
            'PE', // Tipo fijo: Pedido
            $pedidoItem['cantidad'],
            $pedidoItem['id_art'],
            $pedidoItem['descripcion'],
            isset($pedidoItem['precio']) ? $pedidoItem['precio'] : 0,
            $pedidoItem['usuario_res'],
            $pedidoItem['observacion']
        ]);

        $result = $query->row_array();
        $id_items = $result['id_items'];

        log_message('info', "âœ… Alta Existencias - Pedidoitem insertado. ID: {$id_items}");

        // ============================================================================
        // 2. INSERTAR EN PEDIDOSCB
        // ============================================================================

        $sql_pedidoscb = "INSERT INTO pedidoscb
            (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso)
            VALUES (?, ?, ?, CURRENT_DATE, ?, ?, 'ALTA', ?)
            RETURNING id_num";

        $query = $this->db->query($sql_pedidoscb, [
            'PE', // Tipo fijo: Pedido
            $pedidoscb['sucursald'],
            $pedidoscb['sucursalh'],
            $pedidoscb['usuario'],
            isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : $pedidoItem['observacion'],
            $id_items
        ]);

        $result = $query->row_array();
        $id_num = $result['id_num'];

        log_message('info', "âœ… Alta Existencias - Pedidoscb insertado. ID: {$id_num}");

        // ============================================================================
        // 3. ACTUALIZAR ID_NUM EN PEDIDOITEM
        // ============================================================================

        $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num, $id_items]);

        // ============================================================================
        // 4. ACTUALIZAR STOCK EN ARTSUCURSAL
        // ============================================================================

        // Mapeo de sucursales a campos exi
        $mapeo_sucursal_exi = [
            1 => 'exi2', // Casa Central
            2 => 'exi3', // Valle Viejo
            3 => 'exi4', // GÃ¼emes
            4 => 'exi1', // Deposito
            5 => 'exi5'  // Mayorista
        ];

        $sucursal = $pedidoscb['sucursald'];
        $campo_stock = isset($mapeo_sucursal_exi[$sucursal])
            ? $mapeo_sucursal_exi[$sucursal]
            : 'exi' . $sucursal;

        log_message('info', "Alta Existencias - Actualizando stock: Sucursal={$sucursal}, Campo={$campo_stock}, Cantidad=+{$pedidoItem['cantidad']}, ArtÃ­culo={$pedidoItem['id_art']}");

        $sql_update_stock = "UPDATE artsucursal
                            SET $campo_stock = $campo_stock + ?
                            WHERE id_articulo = ?";

        $this->db->query($sql_update_stock, [
            $pedidoItem['cantidad'],
            $pedidoItem['id_art']
        ]);

        $rows_affected = $this->db->affected_rows();
        log_message('info', "âœ… Alta Existencias - Stock actualizado. Rows affected: {$rows_affected}");

        if ($rows_affected == 0) {
            throw new Exception("No se pudo actualizar el stock del artÃ­culo");
        }

        // ============================================================================
        // COMPLETAR TRANSACCIÃ“N
        // ============================================================================

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            throw new Exception("Error en la transacciÃ³n de base de datos");
        }

        // Respuesta exitosa
        $respuesta = array(
            "error" => false,
            "mensaje" => "Alta de existencias registrada correctamente",
            "id_num" => $id_num,
            "id_items" => $id_items,
            "cantidad" => $pedidoItem['cantidad'],
            "sucursal" => $sucursal
        );

        log_message('info', "âœ…âœ…âœ… Alta Existencias EXITOSA - ID_NUM: {$id_num}, Cantidad: {$pedidoItem['cantidad']}, Sucursal: {$sucursal}, Usuario: {$pedidoItem['usuario_res']}");

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        // Rollback en caso de error
        $this->db->trans_rollback();

        log_message('error', "âŒ Error en Alta Existencias: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al registrar alta de existencias: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtener Altas de Existencias con Costos Calculados
 *
 * Obtiene listado de altas de existencias con costos calculados.
 * Implementa lÃ³gica dual:
 * - Estado 'ALTA': Calcula costos dinÃ¡micamente con valores actuales de tipo de cambio
 * - Estado 'Cancel-Alta': Usa valores fijos guardados al momento de cancelaciÃ³n
 *
 * @method GET
 * @param int sucursal (opcional) - Filtrar por sucursal
 * @param string estado (opcional) - Filtrar por estado ('ALTA', 'Cancel-Alta', 'Todas')
 * @return JSON - Array de altas con costos calculados
 */
/**
 * Obtiene listado de altas de existencias con costos calculados
 *
 * VERSIÃ“N 2.0: Con soporte para paginaciÃ³n, ordenamiento y filtros dinÃ¡micos
 *
 * @method GET
 * @param int sucursal (opcional) - Filtrar por sucursal
 * @param string estado (opcional) - Filtrar por estado ('ALTA', 'Cancel-Alta', 'Todas')
 * @param int page (opcional, default: 1) - NÃºmero de pÃ¡gina
 * @param int limit (opcional, default: 50) - Registros por pÃ¡gina
 * @param string sortField (opcional) - Campo para ordenar
 * @param string sortOrder (opcional, default: ASC) - DirecciÃ³n de ordenamiento (ASC/DESC)
 * @param array filter_* (opcional) - Filtros dinÃ¡micos por columna
 * @param array matchMode_* (opcional) - Modo de matching para filtros
 * @return JSON
 */
public function ObtenerAltasConCostos_get() {
    // ========================================================================
    // PARÃMETROS
    // ========================================================================

    // Filtros bÃ¡sicos
    $sucursal = $this->get('sucursal');
    $estado_filtro = $this->get('estado');

    // PaginaciÃ³n
    $page = $this->get('page');
    $limit = $this->get('limit');

    // Ordenamiento
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder');

    // ValidaciÃ³n y valores por defecto
    $page = $page ? max(1, intval($page)) : 1;
    $limit = $limit ? max(1, min(500, intval($limit))) : 50;
    $sortOrder = strtoupper($sortOrder) === 'DESC' ? 'DESC' : 'ASC';

    // ========================================================================
    // QUERY BASE
    // ========================================================================

    $sql = "
        SELECT
            pi.id_num,
            pi.id_items,
            pi.id_art,
            pi.descripcion,
            pi.cantidad,
            pc.fecha,
            pi.fecha_resuelto,
            pi.usuario_res,
            pi.observacion,
            TRIM(pi.estado) AS estado,
            pi.motivo_cancelacion,
            pi.fecha_cancelacion,
            pi.usuario_cancelacion,
            pc.sucursald,
            pc.sucursalh,
            pc.usuario,
            pc.tipo,

            -- LÃ“GICA DUAL: Costos dinÃ¡micos vs fijos
            CASE
                WHEN TRIM(pi.estado) = 'ALTA' THEN costos.costo_total_1_calculado
                WHEN TRIM(pi.estado) = 'Cancel-Alta' THEN pi.costo_total_1_fijo
                ELSE NULL
            END AS costo_total_1,

            CASE
                WHEN TRIM(pi.estado) = 'ALTA' THEN costos.costo_total_2_calculado
                WHEN TRIM(pi.estado) = 'Cancel-Alta' THEN pi.costo_total_2_fijo
                ELSE NULL
            END AS costo_total_2,

            CASE
                WHEN TRIM(pi.estado) = 'ALTA' THEN costos.vcambio_actual
                WHEN TRIM(pi.estado) = 'Cancel-Alta' THEN pi.vcambio_fijo
                ELSE NULL
            END AS vcambio,

            -- Indicador de tipo de cÃ¡lculo
            CASE
                WHEN TRIM(pi.estado) = 'ALTA' THEN 'dinamico'
                WHEN TRIM(pi.estado) = 'Cancel-Alta' THEN 'fijo'
                ELSE 'desconocido'
            END AS tipo_calculo,

            -- SÃ­mbolo de moneda: Siempre $ (PESOS)
            '$' AS simbolo_moneda

        FROM pedidoitem pi
        INNER JOIN pedidoscb pc ON pi.id_num = pc.id_num

        -- LATERAL JOIN: Calcular costos dinÃ¡micos solo cuando es necesario
        LEFT JOIN LATERAL (
            SELECT
                -- Obtener valor de cambio actual (mÃ¡s reciente) FILTRANDO POR TIPO DE MONEDA
                (SELECT COALESCE(vcambio, 1)
                 FROM valorcambio
                 WHERE codmone = art.tipo_moneda
                 ORDER BY fecdesde DESC
                 LIMIT 1) AS vcambio_actual,

                -- CÃ¡lculo de costo_total_1 = precostosi * cantidad * vcambio
                (art.precostosi * pi.cantidad *
                 (SELECT COALESCE(vcambio, 1) FROM valorcambio WHERE codmone = art.tipo_moneda ORDER BY fecdesde DESC LIMIT 1)
                ) AS costo_total_1_calculado,

                -- CÃ¡lculo de costo_total_2 = precon * cantidad * vcambio
                (art.precon * pi.cantidad *
                 (SELECT COALESCE(vcambio, 1) FROM valorcambio WHERE codmone = art.tipo_moneda ORDER BY fecdesde DESC LIMIT 1)
                ) AS costo_total_2_calculado

            FROM artsucursal art
            WHERE art.id_articulo = pi.id_art
        ) AS costos ON TRIM(pi.estado) = 'ALTA'

        WHERE TRIM(pi.estado) IN ('ALTA', 'Cancel-Alta')
    ";

    // ========================================================================
    // FILTROS BÃSICOS
    // ========================================================================

    if ($sucursal && $sucursal != 0) {
        $sql .= " AND pc.sucursald = " . intval($sucursal);
    }

    if ($estado_filtro && $estado_filtro !== 'Todas') {
        $sql .= " AND TRIM(pi.estado) = " . $this->db->escape($estado_filtro);
    }

    // ========================================================================
    // FILTROS DINÃMICOS
    // ========================================================================

    $validColumns = array(
        'id_num' => 'pi.id_num',
        'id_art' => 'pi.id_art',
        'descripcion' => 'pi.descripcion',
        'cantidad' => 'pi.cantidad',
        'estado' => 'pi.estado',
        'sucursald' => 'pc.sucursald',
        'usuario_res' => 'pi.usuario_res',
        'observacion' => 'pi.observacion'
    );

    foreach ($_GET as $key => $value) {
        if (strpos($key, 'filter_') === 0 && $value !== '' && $value !== null) {
            $field = substr($key, 7);

            if (!isset($validColumns[$field])) {
                continue;
            }

            $dbField = $validColumns[$field];
            $matchModeKey = 'matchMode_' . $field;
            $matchMode = $this->get($matchModeKey);
            if (!$matchMode) $matchMode = 'contains';

            switch ($matchMode) {
                case 'equals':
                    $sql .= " AND " . $dbField . " = " . $this->db->escape($value);
                    break;
                case 'contains':
                    $sql .= " AND " . $dbField . " ILIKE " . $this->db->escape('%' . $value . '%');
                    break;
                case 'startsWith':
                    $sql .= " AND " . $dbField . " ILIKE " . $this->db->escape($value . '%');
                    break;
                case 'endsWith':
                    $sql .= " AND " . $dbField . " ILIKE " . $this->db->escape('%' . $value);
                    break;
                default:
                    $sql .= " AND " . $dbField . " ILIKE " . $this->db->escape('%' . $value . '%');
            }
        }
    }

    // ========================================================================
    // CONTAR TOTAL (antes de paginaciÃ³n)
    // ========================================================================

    $countSql = "SELECT COUNT(*) as total FROM (" . $sql . ") AS count_query";

    try {
        $countQuery = $this->db->query($countSql);
        $totalRegistros = $countQuery->row()->total;
    } catch (Exception $e) {
        log_message('error', "âŒ Error al contar registros: " . $e->getMessage());
        $totalRegistros = 0;
    }

    // ========================================================================
    // ORDENAMIENTO
    // ========================================================================

    $sortFieldMap = array(
        'id_num' => 'pi.id_num',
        'id_art' => 'pi.id_art',
        'descripcion' => 'pi.descripcion',
        'cantidad' => 'pi.cantidad',
        'estado' => 'pi.estado',
        'fecha' => 'pc.fecha',
        'fecha_resuelto' => 'pi.fecha_resuelto',
        'sucursald' => 'pc.sucursald',
        'usuario_res' => 'pi.usuario_res',
        'observacion' => 'pi.observacion',
        'tipo_calculo' => 'tipo_calculo',
        'costo_total_1' => 'costo_total_1',
        'costo_total_2' => 'costo_total_2',
        'vcambio' => 'vcambio'
    );

    if ($sortField && isset($sortFieldMap[$sortField])) {
        $sql .= " ORDER BY " . $sortFieldMap[$sortField] . " " . $sortOrder;
    } else {
        $sql .= " ORDER BY pi.id_num DESC";
    }

    // ========================================================================
    // PAGINACIÃ“N
    // ========================================================================

    $offset = ($page - 1) * $limit;
    $sql .= " LIMIT " . intval($limit) . " OFFSET " . intval($offset);

    // ========================================================================
    // EJECUTAR QUERY
    // ========================================================================

    try {
        $query = $this->db->query($sql);

        if (!$query) {
            $error = $this->db->error();
            throw new Exception("Error en consulta SQL: " . $error['message']);
        }

        $altas = $query->result_array();

        // Formatear valores numÃ©ricos
        foreach ($altas as &$alta) {
            $alta['costo_total_1'] = $alta['costo_total_1'] !== null
                ? number_format((float)$alta['costo_total_1'], 2, '.', '')
                : null;

            $alta['costo_total_2'] = $alta['costo_total_2'] !== null
                ? number_format((float)$alta['costo_total_2'], 2, '.', '')
                : null;

            $alta['vcambio'] = $alta['vcambio'] !== null
                ? number_format((float)$alta['vcambio'], 4, '.', '')
                : null;
        }

        // ========================================================================
        // RESPUESTA CON PAGINACIÃ“N
        // ========================================================================

        $respuesta = array(
            "error" => false,
            "data" => $altas,
            "total" => $totalRegistros,
            "page" => $page,
            "limit" => $limit,
            "total_pages" => ceil($totalRegistros / $limit)
        );

        log_message('info', "âœ… Altas consultadas: " . count($altas) . " de " . $totalRegistros . " (pÃ¡gina " . $page . ")");

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        log_message('error', "âŒ Error al obtener altas con costos: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener altas de existencias: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Cancelar Alta de Existencias (V2.0 - Con fijaciÃ³n de valores)
 *
 * Cancela una o mÃºltiples altas de existencias previamente registradas,
 * revierte automÃ¡ticamente el stock en artsucursal y FIJA los valores
 * de costos al momento de la cancelaciÃ³n.
 *
 * @method POST
 * @param int id_num (opcional) - ID Ãºnico de la cabecera del alta a cancelar
 * @param array id_nums (opcional) - Array de IDs para cancelaciÃ³n mÃºltiple
 * @param string motivo - Motivo de la cancelaciÃ³n
 * @param string usuario - Usuario que cancela
 * @return JSON - Respuesta con resultado de la operaciÃ³n
 */
public function CancelarAltaExistencias_post() {
    $data = $this->post();

    // ============================================================================
    // VALIDAR DATOS DE ENTRADA
    // ============================================================================

    // Validar que exista id_num o id_nums
    if (!isset($data['id_num']) && !isset($data['id_nums'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requiere id_num o id_nums."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar motivo y usuario
    if (!isset($data['motivo']) || !isset($data['usuario'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requieren motivo y usuario."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $motivo = $data['motivo'];
    $usuario = $data['usuario'];

    // Validar motivo (mÃ­nimo 10 caracteres)
    if (strlen(trim($motivo)) < 10) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "El motivo de cancelaciÃ³n debe tener al menos 10 caracteres"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Convertir id_num a array para unificar lÃ³gica (backward compatibility)
    if (isset($data['id_nums']) && is_array($data['id_nums'])) {
        $ids_a_cancelar = $data['id_nums'];
    } else {
        $ids_a_cancelar = [$data['id_num']];
    }

    // Validar que el array no estÃ© vacÃ­o
    if (empty($ids_a_cancelar)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se especificaron IDs para cancelar"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // ============================================================================
    // OBTENER Y VALIDAR DATOS DE ALTAS A CANCELAR (incluye tipo_moneda)
    // ============================================================================

    $placeholders = implode(',', array_fill(0, count($ids_a_cancelar), '?'));

    $query_altas = $this->db->query(
        "SELECT
            pi.id_num,
            pi.id_items,
            pi.id_art,
            pi.descripcion,
            pi.cantidad,
            TRIM(pi.estado) AS estado,
            pc.sucursald,
            art.precostosi,
            art.precon,
            art.tipo_moneda
         FROM pedidoitem pi
         JOIN pedidoscb pc ON pi.id_num = pc.id_num
         JOIN artsucursal art ON pi.id_art = art.id_articulo
         WHERE pi.id_num IN ({$placeholders})",
        $ids_a_cancelar
    );

    if ($query_altas->num_rows() == 0) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se encontraron registros de alta con los IDs especificados"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    $registros_altas = $query_altas->result();

    // Validar que todos los registros tengan estado 'ALTA'
    $errores_validacion = [];
    foreach ($registros_altas as $registro) {
        if ($registro->estado !== 'ALTA') {
            $errores_validacion[] = "ID {$registro->id_num}: Estado actual '{$registro->estado}' (se requiere 'ALTA')";
        }
    }

    if (!empty($errores_validacion)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Algunos registros no pueden cancelarse",
            "errores" => $errores_validacion
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // ============================================================================
    // CALCULAR COSTOS FIJOS PARA CADA REGISTRO
    // ============================================================================

    $datos_cancelacion = [];
    foreach ($registros_altas as $registro) {
        // Obtener valor de cambio especÃ­fico para el tipo_moneda del artÃ­culo
        $query_vcambio = $this->db->query(
            "SELECT COALESCE(vcambio, 1) AS vcambio_actual
             FROM valorcambio
             WHERE codmone = ?
             ORDER BY fecdesde DESC
             LIMIT 1",
            array($registro->tipo_moneda)
        );

        $vcambio_fijo = 1; // Valor por defecto
        if ($query_vcambio->num_rows() > 0) {
            $vcambio_fijo = $query_vcambio->row()->vcambio_actual;
        }

        // Calcular costos fijos: costo * cantidad * vcambio (segÃºn tipo_moneda del artÃ­culo)
        $costo_total_1_fijo = $registro->precostosi * $registro->cantidad * $vcambio_fijo;
        $costo_total_2_fijo = $registro->precon * $registro->cantidad * $vcambio_fijo;

        $datos_cancelacion[] = [
            'id_num' => $registro->id_num,
            'id_art' => $registro->id_art,
            'cantidad' => $registro->cantidad,
            'sucursal' => $registro->sucursald,
            'costo_total_1_fijo' => $costo_total_1_fijo,
            'costo_total_2_fijo' => $costo_total_2_fijo,
            'vcambio_fijo' => $vcambio_fijo
        ];

        log_message('info', "ğŸ“Š Costos calculados para ID {$registro->id_num} (tipo_moneda={$registro->tipo_moneda}): C1={$costo_total_1_fijo}, C2={$costo_total_2_fijo}, VC={$vcambio_fijo}");
    }

    // ============================================================================
    // INICIAR TRANSACCIÃ“N ÃšNICA
    // ============================================================================

    $this->db->trans_start();

    try {
        // Mapeo de sucursales a campos exi
        $mapeo_sucursal_exi = [
            1 => 'exi2', // Casa Central
            2 => 'exi3', // Valle Viejo
            3 => 'exi4', // GÃ¼emes
            4 => 'exi1', // Deposito
            5 => 'exi5'  // Mayorista
        ];

        $resultados = [];
        $total_revertido = 0;

        // Procesar cada cancelaciÃ³n
        foreach ($datos_cancelacion as $dato) {
            // ========================================================================
            // 1. ACTUALIZAR ESTADO Y FIJAR VALORES EN PEDIDOITEM
            // ========================================================================

            $sql_update_item = "UPDATE pedidoitem
                               SET estado = 'Cancel-Alta',
                                   motivo_cancelacion = ?,
                                   fecha_cancelacion = CURRENT_DATE,
                                   usuario_cancelacion = ?,
                                   costo_total_1_fijo = ?,
                                   costo_total_2_fijo = ?,
                                   vcambio_fijo = ?
                               WHERE id_num = ?";

            $this->db->query($sql_update_item, [
                $motivo,
                $usuario,
                $dato['costo_total_1_fijo'],
                $dato['costo_total_2_fijo'],
                $dato['vcambio_fijo'],
                $dato['id_num']
            ]);

            log_message('info', "âœ… Pedidoitem actualizado con valores fijos. ID: {$dato['id_num']}");

            // ========================================================================
            // 2. ACTUALIZAR ESTADO EN PEDIDOSCB
            // ========================================================================

            $sql_update_cab = "UPDATE pedidoscb
                              SET estado = 'Cancel-Alta',
                                  motivo_cancelacion = ?,
                                  fecha_cancelacion = CURRENT_DATE,
                                  usuario_cancelacion = ?
                              WHERE id_num = ?";

            $this->db->query($sql_update_cab, [$motivo, $usuario, $dato['id_num']]);

            log_message('info', "âœ… Pedidoscb actualizado. ID: {$dato['id_num']}");

            // ========================================================================
            // 3. REVERTIR STOCK EN ARTSUCURSAL
            // ========================================================================

            $sucursal = $dato['sucursal'];
            $campo_stock = isset($mapeo_sucursal_exi[$sucursal])
                ? $mapeo_sucursal_exi[$sucursal]
                : 'exi' . $sucursal;

            log_message('info', "ğŸ”„ Revirtiendo stock: Sucursal={$sucursal}, Campo={$campo_stock}, Cantidad=-{$dato['cantidad']}, ArtÃ­culo={$dato['id_art']}");

            $sql_revertir_stock = "UPDATE artsucursal
                                  SET $campo_stock = $campo_stock - ?
                                  WHERE id_articulo = ?";

            $this->db->query($sql_revertir_stock, [
                $dato['cantidad'],
                $dato['id_art']
            ]);

            $rows_affected = $this->db->affected_rows();

            if ($rows_affected == 0) {
                throw new Exception("No se pudo revertir el stock del artÃ­culo ID: {$dato['id_art']}");
            }

            log_message('info', "âœ… Stock revertido. ID: {$dato['id_num']}, Rows affected: {$rows_affected}");

            // Agregar a resultados
            $resultados[] = [
                'id_num' => $dato['id_num'],
                'cantidad_revertida' => $dato['cantidad'],
                'sucursal' => $sucursal,
                'costo_total_1_fijo' => number_format($dato['costo_total_1_fijo'], 2, '.', ''),
                'costo_total_2_fijo' => number_format($dato['costo_total_2_fijo'], 2, '.', ''),
                'vcambio_fijo' => number_format($dato['vcambio_fijo'], 4, '.', '')
            ];

            $total_revertido += $dato['cantidad'];
        }

        // ============================================================================
        // COMPLETAR TRANSACCIÃ“N
        // ============================================================================

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            throw new Exception("Error en la transacciÃ³n de base de datos");
        }

        // Respuesta exitosa
        $respuesta = array(
            "error" => false,
            "mensaje" => count($resultados) === 1
                ? "Alta de existencias cancelada correctamente. Stock revertido y valores fijados."
                : count($resultados) . " altas de existencias canceladas correctamente. Stock revertido y valores fijados.",
            "resultados" => $resultados,
            "total_registros" => count($resultados),
            "total_cantidad_revertida" => $total_revertido
        );

        log_message('info', "âœ…âœ…âœ… CancelaciÃ³n(es) EXITOSA(S) - Total: " . count($resultados) . ", Cantidad total revertida: {$total_revertido}, Usuario: {$usuario}");

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        // Rollback en caso de error
        $this->db->trans_rollback();

        log_message('error', "âŒ Error al cancelar Alta Existencias: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al cancelar alta(s) de existencias: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

// ============================================================================
//                  FIN SISTEMA DE ALTA DE EXISTENCIAS
// ============================================================================

// ============================================================================
//            SISTEMA DE TRANSFERENCIAS MEJORADO (V2.0 - 15-NOV-2025)
// ============================================================================
// Nuevas funciones para flujo bidireccional con confirmaciÃ³n
// Flujos:
//   - PULL: Solicitar stock (Solicitado â†’ Aceptado â†’ Recibido)
//   - PUSH: Ofrecer stock (Ofrecido â†’ Aceptado â†’ Recibido)
// ============================================================================

/**
 * Aceptar Transferencia de Stock
 *
 * Acepta una solicitud (PULL) u oferta (PUSH) de transferencia de stock.
 * NO mueve stock, solo cambia el estado a "Aceptado".
 * FIX 18-Nov-2025: Stock se mueve en confirmaciÃ³n, no en aceptaciÃ³n.
 *
 * Flujo PULL (Solicitud):
 *   - Sucursal A solicita a Sucursal B (estado: "Solicitado")
 *   - Sucursal B acepta â†’ Estado cambia a: "Aceptado"
 *   - Sucursal A confirma recepciÃ³n â†’ MUEVE STOCK: B -cantidad, A +cantidad
 *
 * Flujo PUSH (Oferta):
 *   - Sucursal A ofrece a Sucursal B (estado: "Ofrecido")
 *   - Sucursal B acepta â†’ Estado cambia a: "Aceptado"
 *   - Sucursal A confirma envÃ­o â†’ MUEVE STOCK: A -cantidad, B +cantidad
 *
 * @method POST
 * @param int id_num - ID del pedido a aceptar
 * @param string usuario - Usuario que acepta
 * @return JSON - Respuesta con resultado
 */
public function AceptarTransferencia_post() {
    $data = $this->post();

    // ========================================================================
    // VALIDACIONES INICIALES
    // ========================================================================

    if (!isset($data['id_num']) || !isset($data['usuario'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requiere id_num y usuario."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $id_num = $data['id_num'];
    $usuario = $data['usuario'];

    log_message('info', "ğŸ”„ Iniciando aceptaciÃ³n de transferencia - ID: {$id_num}, Usuario: {$usuario}");

    try {
        // Iniciar transacciÃ³n
        $this->db->trans_start();

        // ====================================================================
        // OBTENER DATOS DEL PEDIDO CON BLOQUEO (FOR UPDATE)
        // ====================================================================

        $sql_pedido = "
            SELECT
                pi.id_items,
                pi.id_num,
                pi.id_art,
                pi.cantidad,
                pi.descripcion,
                TRIM(pi.estado) as estado,
                pi.tipo_transferencia,
                pc.sucursald,
                pc.sucursalh
            FROM pedidoitem pi
            INNER JOIN pedidoscb pc ON pi.id_num = pc.id_num
            WHERE pi.id_num = ?
              AND pi.tipo = 'PE'
            FOR UPDATE
        ";

        $query = $this->db->query($sql_pedido, [$id_num]);

        if ($query->num_rows() == 0) {
            throw new Exception("Transferencia no encontrada (ID: {$id_num})");
        }

        $items = $query->result();

        // Validar que todos los items tienen el mismo estado
        $primer_estado = $items[0]->estado;
        foreach ($items as $item) {
            if ($item->estado !== $primer_estado) {
                throw new Exception("Los items de la transferencia tienen estados inconsistentes");
            }
        }

        // ====================================================================
        // VALIDAR ESTADO PERMITIDO
        // ====================================================================

        if (!in_array($primer_estado, ['Solicitado', 'Ofrecido'])) {
            throw new Exception("No se puede aceptar una transferencia en estado '{$primer_estado}'. Solo se permiten 'Solicitado' u 'Ofrecido'.");
        }

        // ====================================================================
        // DETERMINAR DIRECCIÃ“N DEL MOVIMIENTO
        // ====================================================================

        $tipo_transferencia = $items[0]->tipo_transferencia;
        $sucursald = $items[0]->sucursald;
        $sucursalh = $items[0]->sucursalh;

        // PULL (Solicitud): sucursald pide a sucursalh
        // Stock se mueve: sucursalh â†’ sucursald
        // Origen: sucursalh, Destino: sucursald

        // PUSH (Oferta): sucursald ofrece a sucursalh
        // Stock se mueve: sucursald â†’ sucursalh
        // Origen: sucursald, Destino: sucursalh

        if ($primer_estado === 'Solicitado' || $tipo_transferencia === 'PULL') {
            $sucursal_origen = $sucursalh;  // Quien envÃ­a el stock
            $sucursal_destino = $sucursald; // Quien recibe el stock
            $tipo_flujo = 'PULL';
        } else {
            $sucursal_origen = $sucursald;  // Quien envÃ­a el stock
            $sucursal_destino = $sucursalh; // Quien recibe el stock
            $tipo_flujo = 'PUSH';
        }

        // Mapeo sucursal â†’ campo stock
        $mapeo_sucursal_exi = [
            1 => 'exi2', // Casa Central
            2 => 'exi3', // Valle Viejo
            3 => 'exi4', // GÃ¼emes
            4 => 'exi1', // DepÃ³sito
            5 => 'exi5'  // Mayorista
        ];

        $campo_origen = $mapeo_sucursal_exi[$sucursal_origen];
        $campo_destino = $mapeo_sucursal_exi[$sucursal_destino];

        log_message('info', "ğŸ“¦ Flujo {$tipo_flujo}: Origen (Suc {$sucursal_origen}, {$campo_origen}) â†’ Destino (Suc {$sucursal_destino}, {$campo_destino})");

        // ====================================================================
        // ACTUALIZAR ESTADO A "Aceptado"
        // ====================================================================
        // NOTA: El stock se moverÃ¡ cuando se confirme la transferencia (ConfirmarRecepcion/ConfirmarEnvio)
        // FIX 18-Nov-2025: Stock se mueve en confirmaciÃ³n, no en aceptaciÃ³n

        $fecha_actual = date('Y-m-d');

        $sql_update_item = "
            UPDATE pedidoitem
            SET
                estado = 'Aceptado',
                fecha_aceptacion = ?,
                usuario_aceptacion = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_item, [$fecha_actual, $usuario, $id_num]);

        $sql_update_cab = "
            UPDATE pedidoscb
            SET
                estado = 'Aceptado',
                fecha_aceptacion = ?,
                usuario_aceptacion = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_cab, [$fecha_actual, $usuario, $id_num]);

        // ====================================================================
        // COMMIT
        // ====================================================================

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            throw new Exception("Error en la transacciÃ³n de base de datos");
        }

        log_message('info', "âœ…âœ…âœ… Transferencia ACEPTADA exitosamente - ID: {$id_num}, Tipo: {$tipo_flujo}, Usuario: {$usuario}");

        $respuesta = array(
            "error" => false,
            "mensaje" => "Transferencia aceptada y stock movido correctamente",
            "id_num" => $id_num,
            "tipo_flujo" => $tipo_flujo,
            "sucursal_origen" => $sucursal_origen,
            "sucursal_destino" => $sucursal_destino,
            "total_items" => count($items),
            "fecha_aceptacion" => $fecha_actual,
            "usuario_aceptacion" => $usuario
        );

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        $this->db->trans_rollback();

        log_message('error', "âŒ Error al aceptar transferencia: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al aceptar transferencia: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Rechazar Transferencia de Stock
 *
 * Rechaza una solicitud (PULL) u oferta (PUSH) de transferencia de stock.
 * NO mueve stock, solo cambia el estado a "Rechazado" y registra el motivo.
 *
 * @method POST
 * @param int id_num - ID del pedido a rechazar
 * @param string usuario - Usuario que rechaza
 * @param string motivo_rechazo - Motivo del rechazo
 * @return JSON - Respuesta con resultado
 */
public function RechazarTransferencia_post() {
    $data = $this->post();

    // ========================================================================
    // VALIDACIONES INICIALES
    // ========================================================================

    if (!isset($data['id_num']) || !isset($data['usuario']) || !isset($data['motivo_rechazo'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requiere id_num, usuario y motivo_rechazo."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $id_num = $data['id_num'];
    $usuario = $data['usuario'];
    $motivo_rechazo = trim($data['motivo_rechazo']);

    // Validar motivo (mÃ­nimo 5 caracteres)
    if (strlen($motivo_rechazo) < 5) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "El motivo de rechazo debe tener al menos 5 caracteres"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    log_message('info', "ğŸ”„ Iniciando rechazo de transferencia - ID: {$id_num}, Usuario: {$usuario}");

    try {
        // Iniciar transacciÃ³n
        $this->db->trans_start();

        // ====================================================================
        // OBTENER Y VALIDAR ESTADO
        // ====================================================================

        $sql_estado = "
            SELECT TRIM(estado) as estado
            FROM pedidoitem
            WHERE id_num = ?
              AND tipo = 'PE'
            LIMIT 1
        ";

        $query = $this->db->query($sql_estado, [$id_num]);

        if ($query->num_rows() == 0) {
            throw new Exception("Transferencia no encontrada (ID: {$id_num})");
        }

        $estado_actual = $query->row()->estado;

        // Validar estado permitido
        if (!in_array($estado_actual, ['Solicitado', 'Ofrecido'])) {
            throw new Exception("No se puede rechazar una transferencia en estado '{$estado_actual}'. Solo se permiten 'Solicitado' u 'Ofrecido'.");
        }

        // ====================================================================
        // ACTUALIZAR ESTADO A "Rechazado"
        // ====================================================================

        $fecha_actual = date('Y-m-d');

        $sql_update_item = "
            UPDATE pedidoitem
            SET
                estado = 'Rechazado',
                fecha_rechazo = ?,
                usuario_rechazo = ?,
                motivo_rechazo = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_item, [$fecha_actual, $usuario, $motivo_rechazo, $id_num]);

        $sql_update_cab = "
            UPDATE pedidoscb
            SET
                estado = 'Rechazado',
                fecha_rechazo = ?,
                usuario_rechazo = ?,
                motivo_rechazo = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_cab, [$fecha_actual, $usuario, $motivo_rechazo, $id_num]);

        // ====================================================================
        // COMMIT
        // ====================================================================

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            throw new Exception("Error en la transacciÃ³n de base de datos");
        }

        log_message('info', "âœ…âœ…âœ… Transferencia RECHAZADA exitosamente - ID: {$id_num}, Usuario: {$usuario}, Motivo: {$motivo_rechazo}");

        $respuesta = array(
            "error" => false,
            "mensaje" => "Transferencia rechazada correctamente",
            "id_num" => $id_num,
            "fecha_rechazo" => $fecha_actual,
            "usuario_rechazo" => $usuario,
            "motivo_rechazo" => $motivo_rechazo
        );

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        $this->db->trans_rollback();

        log_message('error', "âŒ Error al rechazar transferencia: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al rechazar transferencia: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Confirmar RecepciÃ³n de Stock (Flujo PULL - Solicitud)
 *
 * Confirma la recepciÃ³n de un stock solicitado.
 * MUEVE el stock de origen a destino y actualiza estado a "Recibido".
 * FIX 18-Nov-2025: Stock se mueve en confirmaciÃ³n, no en aceptaciÃ³n.
 *
 * @method POST
 * @param int id_num - ID del pedido
 * @param string usuario - Usuario que confirma recepciÃ³n
 * @return JSON - Respuesta con resultado
 */
public function ConfirmarRecepcion_post() {
    $data = $this->post();

    // ========================================================================
    // VALIDACIONES INICIALES
    // ========================================================================

    if (!isset($data['id_num']) || !isset($data['usuario'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requiere id_num y usuario."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $id_num = $data['id_num'];
    $usuario = $data['usuario'];

    log_message('info', "ğŸ”„ Iniciando confirmaciÃ³n de recepciÃ³n - ID: {$id_num}, Usuario: {$usuario}");

    try {
        // Iniciar transacciÃ³n
        $this->db->trans_start();

        // ====================================================================
        // VALIDAR ESTADO Y TIPO
        // ====================================================================

        $sql_validar = "
            SELECT TRIM(pi.estado) as estado, pi.tipo_transferencia
            FROM pedidoitem pi
            WHERE pi.id_num = ?
              AND pi.tipo = 'PE'
            LIMIT 1
        ";

        $query = $this->db->query($sql_validar, [$id_num]);

        if ($query->num_rows() == 0) {
            throw new Exception("Transferencia no encontrada (ID: {$id_num})");
        }

        $datos = $query->row();
        $estado_actual = $datos->estado;
        $tipo_transferencia = $datos->tipo_transferencia;

        // Validar estado
        if ($estado_actual !== 'Aceptado') {
            throw new Exception("Solo se pueden confirmar recepciones de transferencias en estado 'Aceptado'. Estado actual: '{$estado_actual}'");
        }

        // Validar que sea flujo PULL (opcional, para mayor seguridad)
        if ($tipo_transferencia === 'PUSH') {
            throw new Exception("Esta transferencia es tipo PUSH (oferta). Use ConfirmarEnvio en su lugar.");
        }

        // ====================================================================
        // OBTENER DATOS DE LA TRANSFERENCIA
        // ====================================================================
        // FIX 18-Nov-2025: Mover stock en confirmaciÃ³n, no en aceptaciÃ³n

        $sql_datos = "
            SELECT pc.sucursald, pc.sucursalh
            FROM pedidoscb pc
            WHERE pc.id_num = ?
            LIMIT 1
        ";
        $query_datos = $this->db->query($sql_datos, [$id_num]);

        if ($query_datos->num_rows() == 0) {
            throw new Exception("Datos de transferencia no encontrados (ID: {$id_num})");
        }

        $datos_transferencia = $query_datos->row();
        $sucursald = $datos_transferencia->sucursald;
        $sucursalh = $datos_transferencia->sucursalh;

        // Obtener items
        $sql_items = "
            SELECT id_art, cantidad, descripcion
            FROM pedidoitem
            WHERE id_num = ?
              AND tipo = 'PE'
        ";
        $query_items = $this->db->query($sql_items, [$id_num]);
        $items = $query_items->result();

        if (count($items) == 0) {
            throw new Exception("No se encontraron items para esta transferencia");
        }

        // ====================================================================
        // DETERMINAR DIRECCIÃ“N DEL FLUJO Y MOVER STOCK
        // ====================================================================

        // PULL: Destino solicita de Origen â†’ Stock sale de Origen, entra a Destino
        $sucursal_origen = $sucursalh;  // Quien envÃ­a el stock
        $sucursal_destino = $sucursald; // Quien recibe el stock

        // Mapeo sucursal â†’ campo stock
        $mapeo_sucursal_exi = [
            1 => 'exi2', // Casa Central
            2 => 'exi3', // Valle Viejo
            3 => 'exi4', // GÃ¼emes
            4 => 'exi1', // DepÃ³sito
            5 => 'exi5'  // Mayorista
        ];

        $campo_origen = $mapeo_sucursal_exi[$sucursal_origen];
        $campo_destino = $mapeo_sucursal_exi[$sucursal_destino];

        log_message('info', "ğŸ“¦ Flujo PULL - ConfirmaciÃ³n RecepciÃ³n: Origen (Suc {$sucursal_origen}, {$campo_origen}) â†’ Destino (Suc {$sucursal_destino}, {$campo_destino})");

        // Mover stock para cada artÃ­culo
        foreach ($items as $item) {
            $id_art = $item->id_art;
            $cantidad = $item->cantidad;

            // Obtener stock actual
            $sql_stock = "SELECT {$campo_origen}, {$campo_destino} FROM artsucursal WHERE id_articulo = ?";
            $query_stock = $this->db->query($sql_stock, [$id_art]);

            if ($query_stock->num_rows() == 0) {
                throw new Exception("ArtÃ­culo {$id_art} no encontrado en artsucursal");
            }

            $stock_actual = $query_stock->row();
            $stock_origen_actual = $stock_actual->$campo_origen;
            $stock_destino_actual = $stock_actual->$campo_destino;

            // NOTA: NO se valida stock suficiente - Se permiten stocks negativos
            // FIX 18-Nov-2025: Eliminada restricciÃ³n de stock mÃ­nimo

            // Actualizar stock
            $sql_update_stock = "
                UPDATE artsucursal
                SET
                    {$campo_origen} = {$campo_origen} - ?,
                    {$campo_destino} = {$campo_destino} + ?
                WHERE id_articulo = ?
            ";

            $this->db->query($sql_update_stock, [$cantidad, $cantidad, $id_art]);

            log_message('info', "âœ… Stock movido (PULL): Art {$id_art}, Cantidad: {$cantidad}, Origen: {$stock_origen_actual} â†’ " . ($stock_origen_actual - $cantidad) . ", Destino: {$stock_destino_actual} â†’ " . ($stock_destino_actual + $cantidad));
        }

        // ====================================================================
        // ACTUALIZAR ESTADO A "Recibido"
        // ====================================================================

        $fecha_actual = date('Y-m-d');

        $sql_update_item = "
            UPDATE pedidoitem
            SET
                estado = 'Recibido',
                fecha_confirmacion = ?,
                usuario_confirmacion = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_item, [$fecha_actual, $usuario, $id_num]);

        $sql_update_cab = "
            UPDATE pedidoscb
            SET
                estado = 'Recibido',
                fecha_confirmacion = ?,
                usuario_confirmacion = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_cab, [$fecha_actual, $usuario, $id_num]);

        // ====================================================================
        // COMMIT
        // ====================================================================

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            throw new Exception("Error en la transacciÃ³n de base de datos");
        }

        log_message('info', "âœ…âœ…âœ… RecepciÃ³n CONFIRMADA exitosamente - ID: {$id_num}, Usuario: {$usuario}");

        $respuesta = array(
            "error" => false,
            "mensaje" => "RecepciÃ³n confirmada. Transferencia completada.",
            "id_num" => $id_num,
            "fecha_confirmacion" => $fecha_actual,
            "usuario_confirmacion" => $usuario
        );

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        $this->db->trans_rollback();

        log_message('error', "âŒ Error al confirmar recepciÃ³n: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al confirmar recepciÃ³n: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Confirmar EnvÃ­o de Stock (Flujo PUSH - Oferta)
 *
 * Confirma el envÃ­o de un stock ofrecido.
 * MUEVE el stock de origen a destino y actualiza estado a "Recibido".
 * FIX 18-Nov-2025: Stock se mueve en confirmaciÃ³n, no en aceptaciÃ³n.
 *
 * @method POST
 * @param int id_num - ID del pedido
 * @param string usuario - Usuario que confirma envÃ­o
 * @return JSON - Respuesta con resultado
 */
public function ConfirmarEnvio_post() {
    $data = $this->post();

    // ========================================================================
    // VALIDACIONES INICIALES
    // ========================================================================

    if (!isset($data['id_num']) || !isset($data['usuario'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Datos incompletos. Se requiere id_num y usuario."
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $id_num = $data['id_num'];
    $usuario = $data['usuario'];

    log_message('info', "ğŸ”„ Iniciando confirmaciÃ³n de envÃ­o - ID: {$id_num}, Usuario: {$usuario}");

    try {
        // Iniciar transacciÃ³n
        $this->db->trans_start();

        // ====================================================================
        // VALIDAR ESTADO Y TIPO
        // ====================================================================

        $sql_validar = "
            SELECT TRIM(pi.estado) as estado, pi.tipo_transferencia
            FROM pedidoitem pi
            WHERE pi.id_num = ?
              AND pi.tipo = 'PE'
            LIMIT 1
        ";

        $query = $this->db->query($sql_validar, [$id_num]);

        if ($query->num_rows() == 0) {
            throw new Exception("Transferencia no encontrada (ID: {$id_num})");
        }

        $datos = $query->row();
        $estado_actual = $datos->estado;
        $tipo_transferencia = $datos->tipo_transferencia;

        // Validar estado
        if ($estado_actual !== 'Aceptado') {
            throw new Exception("Solo se pueden confirmar envÃ­os de transferencias en estado 'Aceptado'. Estado actual: '{$estado_actual}'");
        }

        // Validar que sea flujo PUSH (opcional, para mayor seguridad)
        if ($tipo_transferencia === 'PULL') {
            throw new Exception("Esta transferencia es tipo PULL (solicitud). Use ConfirmarRecepcion en su lugar.");
        }

        // ====================================================================
        // OBTENER DATOS DE LA TRANSFERENCIA
        // ====================================================================
        // FIX 18-Nov-2025: Mover stock en confirmaciÃ³n, no en aceptaciÃ³n

        $sql_datos = "
            SELECT pc.sucursald, pc.sucursalh
            FROM pedidoscb pc
            WHERE pc.id_num = ?
            LIMIT 1
        ";
        $query_datos = $this->db->query($sql_datos, [$id_num]);

        if ($query_datos->num_rows() == 0) {
            throw new Exception("Datos de transferencia no encontrados (ID: {$id_num})");
        }

        $datos_transferencia = $query_datos->row();
        $sucursald = $datos_transferencia->sucursald;
        $sucursalh = $datos_transferencia->sucursalh;

        // Obtener items
        $sql_items = "
            SELECT id_art, cantidad, descripcion
            FROM pedidoitem
            WHERE id_num = ?
              AND tipo = 'PE'
        ";
        $query_items = $this->db->query($sql_items, [$id_num]);
        $items = $query_items->result();

        if (count($items) == 0) {
            throw new Exception("No se encontraron items para esta transferencia");
        }

        // ====================================================================
        // DETERMINAR DIRECCIÃ“N DEL FLUJO Y MOVER STOCK
        // ====================================================================

        // PUSH: Origen ofrece a Destino â†’ Stock sale de Origen, entra a Destino
        $sucursal_origen = $sucursald;  // Quien envÃ­a el stock
        $sucursal_destino = $sucursalh; // Quien recibe el stock

        // Mapeo sucursal â†’ campo stock
        $mapeo_sucursal_exi = [
            1 => 'exi2', // Casa Central
            2 => 'exi3', // Valle Viejo
            3 => 'exi4', // GÃ¼emes
            4 => 'exi1', // DepÃ³sito
            5 => 'exi5'  // Mayorista
        ];

        $campo_origen = $mapeo_sucursal_exi[$sucursal_origen];
        $campo_destino = $mapeo_sucursal_exi[$sucursal_destino];

        log_message('info', "ğŸ“¦ Flujo PUSH - ConfirmaciÃ³n EnvÃ­o: Origen (Suc {$sucursal_origen}, {$campo_origen}) â†’ Destino (Suc {$sucursal_destino}, {$campo_destino})");

        // Mover stock para cada artÃ­culo
        foreach ($items as $item) {
            $id_art = $item->id_art;
            $cantidad = $item->cantidad;

            // Obtener stock actual
            $sql_stock = "SELECT {$campo_origen}, {$campo_destino} FROM artsucursal WHERE id_articulo = ?";
            $query_stock = $this->db->query($sql_stock, [$id_art]);

            if ($query_stock->num_rows() == 0) {
                throw new Exception("ArtÃ­culo {$id_art} no encontrado en artsucursal");
            }

            $stock_actual = $query_stock->row();
            $stock_origen_actual = $stock_actual->$campo_origen;
            $stock_destino_actual = $stock_actual->$campo_destino;

            // NOTA: NO se valida stock suficiente - Se permiten stocks negativos
            // FIX 18-Nov-2025: Eliminada restricciÃ³n de stock mÃ­nimo

            // Actualizar stock
            $sql_update_stock = "
                UPDATE artsucursal
                SET
                    {$campo_origen} = {$campo_origen} - ?,
                    {$campo_destino} = {$campo_destino} + ?
                WHERE id_articulo = ?
            ";

            $this->db->query($sql_update_stock, [$cantidad, $cantidad, $id_art]);

            log_message('info', "âœ… Stock movido (PUSH): Art {$id_art}, Cantidad: {$cantidad}, Origen: {$stock_origen_actual} â†’ " . ($stock_origen_actual - $cantidad) . ", Destino: {$stock_destino_actual} â†’ " . ($stock_destino_actual + $cantidad));
        }

        // ====================================================================
        // ACTUALIZAR ESTADO A "Recibido"
        // ====================================================================

        $fecha_actual = date('Y-m-d');

        $sql_update_item = "
            UPDATE pedidoitem
            SET
                estado = 'Recibido',
                fecha_confirmacion = ?,
                usuario_confirmacion = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_item, [$fecha_actual, $usuario, $id_num]);

        $sql_update_cab = "
            UPDATE pedidoscb
            SET
                estado = 'Recibido',
                fecha_confirmacion = ?,
                usuario_confirmacion = ?
            WHERE id_num = ?
        ";

        $this->db->query($sql_update_cab, [$fecha_actual, $usuario, $id_num]);

        // ====================================================================
        // COMMIT
        // ====================================================================

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            throw new Exception("Error en la transacciÃ³n de base de datos");
        }

        log_message('info', "âœ…âœ…âœ… EnvÃ­o CONFIRMADO exitosamente - ID: {$id_num}, Usuario: {$usuario}");

        $respuesta = array(
            "error" => false,
            "mensaje" => "EnvÃ­o confirmado. Transferencia completada.",
            "id_num" => $id_num,
            "fecha_confirmacion" => $fecha_actual,
            "usuario_confirmacion" => $usuario
        );

        $this->response($respuesta, REST_Controller::HTTP_OK);

    } catch (Exception $e) {
        $this->db->trans_rollback();

        log_message('error', "âŒ Error al confirmar envÃ­o: " . $e->getMessage());

        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al confirmar envÃ­o: " . $e->getMessage()
        );

        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

// ============================================================================
//          FIN SISTEMA DE TRANSFERENCIAS MEJORADO (V2.0 - 15-NOV-2025)
// ============================================================================

}

