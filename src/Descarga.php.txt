<?php
defined('BASEPATH') OR exit('No direct script access allowed');
require_once(APPPATH.'/libraries/REST_Controller.php');
use Restserver\libraries\REST_Controller;

class Descarga extends REST_Controller {

public function __construct()
{

header("Access-Control-Allow-Origin:*");
header("Access-Control-Allow-Methods:PUT, GET, POST, DELETE, OPTIONS");
header("Access-Control-Allow-Headers:Content-Type, Content-Length, Accept-Encoding");


/* header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS");
header("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, Authorization"); */

  parent::__construct();
  $this->load->database();
}

/**
 * FILTRO PARA EXCLUIR RECIBOS RC DE CONSULTAS DE FACTURAS
 * 
 * Los recibos RC se almacenan en factcab por dependencias tÃ©cnicas,
 * pero deben filtrarse en reportes y consultas de facturaciÃ³n.
 * 
 * @param string $tabla_alias Alias de la tabla (ej: 'f', 'factcab')
 */
private function aplicarFiltroSinRC($tabla_alias = '') {
    $prefix = $tabla_alias ? $tabla_alias . '.' : '';
    $this->db->where($prefix . 'tipo !=', 'RC');
}

/**
 * FILTRO PARA INCLUIR SOLO RECIBOS RC
 * 
 * Para consultas especÃ­ficas de recibos RC
 * 
 * @param string $tabla_alias Alias de la tabla (ej: 'f', 'factcab')
 */
private function aplicarFiltroSoloRC($tabla_alias = '') {
    $prefix = $tabla_alias ? $tabla_alias . '.' : '';
    $this->db->where($prefix . 'tipo', 'RC');
}

public function Clisucxapp_post()//Aca se procesan los envios de clientes de la app y se los inserta en las talaba clientesapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["clientes"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='clisucapp'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA


$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

   //$this->response($this->db->insert_id());
  // $this->db->insert('prueba', $jsondata);
}
public function ClisucxappWeb_post()//Aca se procesan los envios de clientes de la app y se los inserta en las talaba clientesapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["clientes"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='clisuc';//$tabla='clisuc'.$id_vend;//ESTA ES LA QUE USABA CON VARIAS TABLAS AHORA SE CAMBIO POR UNA SOLA

// âœ… VALIDACIÃ“N: Verificar si el cliente ya existe (AGREGADO FASE 4 - 2025-10-07)
$id_cli = $datos['id_cli'];

$this->db->where('id_cli', $id_cli);
$query = $this->db->get($tabla);

if($query->num_rows() > 0) {
    // âŒ Cliente duplicado detectado - retornar HTTP 409 Conflict
    $respuesta = array(
        "error" => true,
        "mensaje" => "Cliente duplicado: Ya existe un cliente con id_cli = " . $id_cli,
        "codigo" => 409
    );
    $this->response($respuesta, REST_Controller::HTTP_CONFLICT);
} else {
    // âœ… Cliente no existe - proceder con INSERT
    $this->db->insert($tabla, $datos);
    $rows = $this->db->affected_rows();

    if($rows > 0) {
        // âœ… InserciÃ³n exitosa - retornar HTTP 201 Created
        $respuesta = array(
            "error" => false,
            "mensaje" => "Cliente creado exitosamente",
            "registros_insertados" => $rows,
            "id_cli" => $id_cli
        );
        $this->response($respuesta, REST_Controller::HTTP_CREATED);
    } else {
        // âŒ Error en la inserciÃ³n - retornar HTTP 500
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al insertar el cliente en la base de datos"
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_ERROR);
    }
}
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}
}
public function UpdateClisucxapp_post()//FunciÃ³n para modificar datos de un cliente en la tabla correspondiente SE AGREGO 10/07/23
{
  $data = $this->post();
  if(isset($data) AND count($data)>0){ 
    $datos = $data['clientes']; 
    $id_vend = $data["id_vend"];
    $tabla = 'clisuc';//$tabla = 'clisuc'.$id_vend;//ESTA ES LA QUE USABA CON VARIAS TABLAS AHORA SE CAMBIO POR UNA SOLA

    if(isset($datos['idcli'])){ 
      $this->db->where('idcli', $datos['idcli']); 
      $this->db->update($tabla, $datos); 
      $rows = $this->db->affected_rows();

      $respuesta=array(
        "error"=>false,
        "mensaje"=>$rows,
		"datoscliente"=>$datos['cliente'],
		"datos"=>$datos,
		"tabla"=>$tabla
      );
      $this->response($respuesta);
    }
    else{
      $respuesta=array(
        "error"=>true,
        "mensaje"=>"No se especificÃ³ la clave de cliente"
      );
      $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
    }
  }
  else{  
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST"
    );
    $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function UpdateArtsucxapp_post()//FunciÃ³n para modificar los stocks de la lista de productos  SE AGREGO 26/12/23
{
  $data = $this->post();
  if(isset($data) AND count($data)>0){ 
    $idart = $data['idart']; 
    $exi = $data["exi"];
    $op = $data["op"];
    $tabla = 'artsucursal'; // exi es lo mismo que sucursal
    

    if(isset($idart)){
      $campo= 'exi'.$exi;
      if($op === '+')
      {
        $this->db->set($campo, "$campo + 1", FALSE);
      }
      else if ($op === '-')
      {
        $this->db->set($campo, "$campo - 1", FALSE);
      }
       
      $this->db->where('idart', $idart); 
      $this->db->update($tabla); 
      $rows = $this->db->affected_rows();

      $respuesta=array(
        "error"=>false,
        "mensaje"=>$rows,
		    "tabla"=>$tabla
      );
      $this->response($respuesta);
    }
    else{
      $respuesta=array(
        "error"=>true,
        "mensaje"=>"No se especificÃ³ la clave de cliente"
      );
      $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
    }
  }
  else{  
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST"
    );
    $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function UpdateArtsucxappManagedPHP_post()//FunciÃ³n para modificar los stocks de la lista de productos  SE AGREGO 26/12/23
{
  $data = $this->post();

  if (isset($data['result'], $data['exi']) AND is_array($data['result'])) {
    $suc = $data['exi'];
    $tabla = 'artsucursal';
    $contador = 0;
    
    foreach ($data['result'] as $item) {
      // Obtener el ID del artÃ­culo
      $id_articulo = isset($item['id_articulo']) ? $item['id_articulo'] : null;
      $cantidad = $item['cantidad']; 
      $op = $item['tipodoc'];
      $campo = "exi{$suc}";
      
      // Verificar que tenemos un ID vÃ¡lido
      if (empty($id_articulo) || $id_articulo == 0) {
        continue; // Saltar este item si no tiene ID vÃ¡lido
      }
      
      // Aumenta o disminuye el stock segÃºn el operador
      if($op === "FC" OR $op === "PR" OR $op === "ND") {
        // RESTAN STOCK: Facturas, Presupuestos y Notas de DÃ©bito
        $this->db->set($campo, "$campo - $cantidad", FALSE);
      } else if ($op === "NC" OR $op === "NV") {
        // SUMAN STOCK: Notas de CrÃ©dito y Devoluciones
        $this->db->set($campo, "$campo + $cantidad", FALSE);
      } else if ($op === "CS") {
        // NO AFECTAN STOCK: Consultas
        log_message('info', "OperaciÃ³n {$op} no afecta stock para id_articulo: {$id_articulo}");
        continue; // Saltar al siguiente item
      } else {
        // Operaciones desconocidas - log para debugging
        log_message('warning', "OperaciÃ³n desconocida {$op} para id_articulo: {$id_articulo} - no se afecta stock");
        continue; // Saltar al siguiente item
      }
      
      // Usar id_articulo como condiciÃ³n WHERE
      $this->db->where('id_articulo', $id_articulo);
      $this->db->update($tabla);
      $affected = $this->db->affected_rows();
      $contador += $affected;
      
      // Log para debugging si no se actualiza nada
      if ($affected == 0) {
        log_message('error', "No se pudo actualizar stock para id_articulo: {$id_articulo}, cantidad: {$cantidad}, op: {$op}");
      }
    }
    
    $respuesta = [
      "error" => false,
      "mensaje" => "Se actualizaron {$contador} registros",
      "tabla" => $tabla,
      "sucursal_exi" => $suc,
      "items_procesados" => count($data['result']),
      "registros_actualizados" => $contador
    ];
    $this->response($respuesta);
    
  } else {
    // Mensaje de error si faltan datos
    $respuesta=array(
      "error"=>true,
      "mensaje"=>"Faltan datos en el POST o el formato no es correcto"
    );
    $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function eliminarCliente_post()
{
  $data = $this->post();
  if(isset($data) && count($data) > 0){
     $datos = $data['clientes'];
    $id_vend = $data["id_vend"];
    $tabla = 'clisuc'.$id_vend;

    if(isset($datos['idcli'])){ 
      
      $this->db->where('idcli', $datos['idcli']); 
      $this->db->delete($tabla); 
      $rows = $this->db->affected_rows();

      $respuesta = array(
        "error" => false,
        "mensaje" => $rows,
        "tabla" => $tabla
      );
      $this->response($respuesta);
    } else {
      $respuesta = array(
        "error" => true,
        "mensaje" => "No se especificÃ³ el ID del cliente"
      );
      $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
  } else {  
    $respuesta = array(
      "error" => true,
      "mensaje" => "Faltan datos en el POST"
    );
    $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
  }
}

public function EliminarRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_rubro_p'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_rubro_p)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro_p'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_rubro_p', $id);
        $this->db->delete('rubro_principal');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_rubro', $id);
        $this->db->delete('rubros');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_marca'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_marca', $id);
        $this->db->delete('marcas');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la marca"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function EliminarArtIva_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_ariva'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_ariva'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_ariva', $id);
        $this->db->delete('artiva');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el iva"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_moneda'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_moneda)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_moneda'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_moneda', $id);
        $this->db->delete('tipomone');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_valor'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_valor)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_valor'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_valor', $id);
        $this->db->delete('valorcambio');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function EliminarProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_prov'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_prov'];

        $this->db->trans_start();

        // Delete from rubro_principal
        $this->db->where('id_prov', $id);
        $this->db->delete('proveedores');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function EliminarConflista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_conflista'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_conflista)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_conflista'];

        $this->db->trans_start();

        // Delete from conflistas
        $this->db->where('id_conflista', $id);
        $this->db->delete('conf_lista');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la conflista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_articulo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_articulo)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_articulo'];

        $this->db->trans_start();

        // Delete from articulos
        $this->db->where('id_articulo', $id);
        $this->db->delete('artsucursal');

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n
        if(!isset($data['id_caja'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_caja)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = (int)$data['id_caja'];

        $this->db->trans_start();
        $this->db->where('id_caja', $id);
        $this->db->delete('caja_lista');
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            if ($rows > 0) {
                 $respuesta = array(
                    "error" => false,
                    "mensaje" => $rows // NÃºmero de filas eliminadas
                );
                $this->response($respuesta);
            } else {
                 $respuesta = array(
                    "error" => true, // O false si prefieres indicar que no se encontrÃ³ pero no es un error del servidor
                    "mensaje" => "No se encontrÃ³ la caja lista con el ID proporcionado o ya fue eliminada"
                );
                $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND); // Opcional: HTTP Status
            }
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        if(!isset($data['id_concepto'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_concepto)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_concepto'];

        $this->db->trans_start();
        $this->db->where('id_concepto', $id);
        $this->db->delete('caja_conceptos');
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             if ($rows > 0) {
                 $respuesta = array(
                    "error" => false,
                    "mensaje" => $rows // NÃºmero de filas eliminadas
                 );
             } else {
                  $respuesta = array(
                    "error" => true, // Considerar si no encontrarlo es un error o no
                    "mensaje" => "No se encontrÃ³ el concepto de caja con el ID proporcionado."
                 );
             }
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function EliminarCajamovi_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar que el ID estÃ© presente
        if(!isset($data['id_movimiento'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el campo requerido (id_movimiento)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_movimiento'];

        $this->db->trans_start();

        $this->db->where('id_movimiento', $id);
        $this->db->delete('caja_movi'); // Nombre de la tabla

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al eliminar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             if ($rows > 0) {
                 $respuesta = array(
                     "error" => false,
                     "mensaje" => $rows // Filas afectadas (deberÃ­a ser 1)
                 );
             } else {
                  $respuesta = array(
                     "error" => true, // Considerar error si no se encontrÃ³ el ID
                     "mensaje" => "No se encontrÃ³ el movimiento con el ID especificado para eliminar."
                 );
                 // PodrÃ­as usar HTTP_NOT_FOUND aquÃ­ tambiÃ©n
                 $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
                 return;
             }
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function PedidossucxappCompleto_post() {
    $data = $this->post();
    
    // Verificar si se recibieron datos en el POST
    if (isset($data) && count($data) > 0) {
        // Extraer datos del POST
        $pedidos = isset($data["pedidos"]) ? $data["pedidos"] : null;
        $cabecera = isset($data["cabecera"]) ? $data["cabecera"] : null;
        $id_vend = isset($data["id_vend"]) ? $data["id_vend"] : null;
        $caja_movi = isset($data["caja_movi"]) ? $data["caja_movi"] : null;
        $subtotales_metodos_pago = isset($data["subtotales_metodos_pago"]) ? $data["subtotales_metodos_pago"] : null;

        // Verificar que los datos necesarios no sean nulos
        if ($pedidos && $cabecera && $id_vend) {
            $tabla = 'psucursal' . $id_vend;
            $tabla_cabecera = 'factcab' . $id_vend;

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // Validar valores numÃ©ricos para evitar desbordamientos
            // Cliente, si es numÃ©rico, verificar lÃ­mite
            if (isset($cabecera['cliente']) && is_numeric($cabecera['cliente']) && $cabecera['cliente'] > 999999) {
                $cabecera['cliente'] = substr($cabecera['cliente'], 0, 6); // Truncar a 6 dÃ­gitos
            }
            
            // Controlar otros campos numÃ©ricos que puedan causar problemas
            $numeric_fields_to_check = ['numero_int', 'numero_fac', 'anumero_com'];
            foreach ($numeric_fields_to_check as $field) {
                if (isset($cabecera[$field]) && is_numeric($cabecera[$field]) && $cabecera[$field] > 999999) {
                    $cabecera[$field] = 999999; // Limitar al mÃ¡ximo permitido
                }
            }
            
            try {
                // Insertar cabecera y obtener el id_num generado
                $this->db->set($cabecera);
                $this->db->insert($tabla_cabecera);
                if ($this->db->affected_rows() > 0) {
                    $id_num = $this->db->insert_id(); // Obtener el id_num generado
                    $contador_exitosas = $this->db->affected_rows();
                } else {
                    log_message('error', 'Error al insertar en la tabla ' . $tabla_cabecera . ': ' . json_encode($cabecera));
                    $this->db->trans_rollback();
                    $respuesta = array(
                        "error" => true,
                        "mensaje" => "Error al insertar cabecera, transacciÃ³n revertida"
                    );
                    $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                    return;
                }
            } catch (Exception $e) {
                log_message('error', 'ExcepciÃ³n al insertar en ' . $tabla_cabecera . ': ' . $e->getMessage());
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al insertar cabecera: " . $e->getMessage()
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
                return;
            }

            // Insertar pedidos
            foreach ($pedidos as &$valor) {
                $valor['id_num'] = $id_num; // Asignar el id_num de la cabecera al pedido
                $this->db->insert($tabla, $valor); // valor es un objeto
                if ($this->db->affected_rows() > 0) {
                    $contador_exitosas += $this->db->affected_rows();
                } else {
                    log_message('error', 'Error al insertar en la tabla ' . $tabla . ': ' . json_encode($valor));
                }
            }
            
            // Generar recibo automÃ¡ticamente para todas las operaciones
            $this->generarReciboAutomatico($cabecera, $id_num, $id_vend);
            
            // ====================================================================
            // SOLUCIÃ“N MÃšLTIPLES CAJAS: Insertar caja_movi (soporta array o Ãºnico)
            // ====================================================================
            if ($caja_movi) {
                // Detectar si es array de movimientos o movimiento Ãºnico
                $movimientos_caja = [];

                // Verificar si es array asociativo (movimiento Ãºnico) o array indexado (mÃºltiples)
                if (isset($caja_movi[0]) && is_array($caja_movi[0])) {
                    // Es un array de movimientos
                    $movimientos_caja = $caja_movi;
                    log_message('info', 'âœ… MÃºltiples movimientos detectados: ' . count($movimientos_caja));
                } else {
                    // Es un movimiento Ãºnico (compatibilidad hacia atrÃ¡s)
                    $movimientos_caja = [$caja_movi];
                    log_message('info', 'âœ… Movimiento Ãºnico detectado (compatibilidad)');
                }

                // Array para almacenar los IDs de movimientos creados
                $ids_movimientos = [];

                // Procesar cada movimiento de caja
                foreach ($movimientos_caja as $index => $movimiento) {
                    // Asignar el id_num de la cabecera al movimiento de caja
                    $movimiento['num_operacion'] = $id_num;

                    // Limpiar campos de fecha nulos o vacÃ­os
                    foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
                        if (isset($movimiento[$dateField]) && empty($movimiento[$dateField])) {
                            $movimiento[$dateField] = null;
                        }
                    }

                    // Validar campos numÃ©ricos para prevenir desbordamientos
                    $numeric_limit_fields = [
                        'sucursal' => 999999,
                        'codigo_mov' => 9999999999,
                        'num_operacion' => 9999999999,
                        'banco' => 9999999999,
                        'num_cheque' => 9999999999,
                        'cuenta_mov' => 999999,
                        'cliente' => 9999999999,
                        'proveedor' => 9999999999,
                        'codigo_mbco' => 9999999999,
                        'punto_venta' => 9999,
                        'numero_comprobante' => 99999999
                    ];

                    foreach ($numeric_limit_fields as $field => $limit) {
                        if (isset($movimiento[$field]) && !empty($movimiento[$field])) {
                            if (is_numeric($movimiento[$field]) && $movimiento[$field] > $limit) {
                                $movimiento[$field] = $limit;
                            }
                        } else {
                            $movimiento[$field] = null;
                        }
                    }

                    // Limpiar campos de texto nulos o vacÃ­os
                    foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
                        if (isset($movimiento[$strField]) && $movimiento[$strField] === '') {
                            $movimiento[$strField] = null;
                        }
                    }

                    // Generar descripciÃ³n automÃ¡tica si tipo_movi es 'A'
                    if (isset($movimiento['tipo_movi']) && $movimiento['tipo_movi'] === 'A') {
                        $movimiento['descripcion_mov'] = $this->generarDescripcionAutomatica($movimiento);
                    }

                    try {
                        $this->db->insert('caja_movi', $movimiento);
                        if ($this->db->affected_rows() > 0) {
                            $contador_exitosas += $this->db->affected_rows();
                            $id_movimiento = $this->db->insert_id();
                            $ids_movimientos[] = $id_movimiento;

                            log_message('info', "âœ… Movimiento #{$index} insertado con ID: {$id_movimiento}, Caja: {$movimiento['caja']}, Importe: {$movimiento['importe_mov']}");
                        } else {
                            log_message('error', 'âŒ Error al insertar movimiento #' . $index . ': ' . json_encode($movimiento));
                        }
                    } catch (Exception $e) {
                        log_message('error', 'âŒ ExcepciÃ³n al insertar movimiento #' . $index . ': ' . $e->getMessage());
                    }
                }

                // ====================================================================
                // âš ï¸ FASE 2: CÃ“DIGO COMENTADO - NO SE INSERTAN DETALLES EN caja_movi_detalle
                // ====================================================================
                // MOTIVO: La tabla caja_movi_detalle es redundante con la nueva implementaciÃ³n
                // que crea movimientos separados por mÃ©todo de pago.
                // Fecha: 2025-10-21
                // Ver: eliminacion_caja_movi_detalle.md para mÃ¡s informaciÃ³n
                // ====================================================================

                log_message('info', 'âœ… FASE 2: Nueva implementaciÃ³n activa - No se insertan detalles en caja_movi_detalle');

                /*
                // ALTERNATIVA C MEJORADA: Insertar detalles vinculados a cada movimiento
                if ($subtotales_metodos_pago !== null && !empty($ids_movimientos)) {
                    try {
                        // Si hay mÃºltiples movimientos, cada uno tiene su detalle
                        if (count($ids_movimientos) > 1) {
                            log_message('info', 'ğŸ“Š Insertando detalles para ' . count($ids_movimientos) . ' movimientos');

                            // Procesar subtotales para obtener array [cod_tarj => importe]
                            $subtotales_finales = $this->procesarSubtotalesHibrido(
                                $subtotales_metodos_pago,
                                $pedidos,
                                array_sum(array_column($movimientos_caja, 'importe_mov')), // Total general
                                $ids_movimientos[0] // ID del primer movimiento (para logs)
                            );

                            // Cada movimiento corresponde a un mÃ©todo de pago
                            $index_detalle = 0;
                            foreach ($subtotales_finales as $cod_tarj => $importe_detalle) {
                                if (isset($ids_movimientos[$index_detalle])) {
                                    $id_mov = $ids_movimientos[$index_detalle];

                                    // Insertar detalle con porcentaje = 100 (cada movimiento es 100% de ese mÃ©todo)
                                    $this->insertarDetallesMetodosPago(
                                        $id_mov,
                                        [$cod_tarj => $importe_detalle],
                                        $importe_detalle // El total del movimiento es el importe del detalle
                                    );

                                    log_message('info', "âœ… Detalle insertado: Movimiento {$id_mov} â†’ cod_tarj={$cod_tarj}, importe={$importe_detalle}");
                                }
                                $index_detalle++;
                            }
                        } else {
                            // Movimiento Ãºnico: comportamiento original
                            $id_movimiento = $ids_movimientos[0];
                            $total_movimiento = isset($movimientos_caja[0]['importe_mov']) ? floatval($movimientos_caja[0]['importe_mov']) : 0;

                            $subtotales_finales = $this->procesarSubtotalesHibrido(
                                $subtotales_metodos_pago,
                                $pedidos,
                                $total_movimiento,
                                $id_movimiento
                            );

                            if (!empty($subtotales_finales)) {
                                $this->insertarDetallesMetodosPago(
                                    $id_movimiento,
                                    $subtotales_finales,
                                    $total_movimiento
                                );

                                log_message('info', "Movimiento {$id_movimiento}: Detalles de mÃ©todos de pago insertados correctamente");
                            } else {
                                log_message('warning', "Movimiento {$id_movimiento}: No se pudieron procesar los subtotales");
                            }
                        }
                    } catch (Exception $e) {
                        log_message('error', "âŒ Error al insertar detalles de movimientos: " . $e->getMessage());
                    }
                }
                */
                // ====================================================================
            }

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error, revertir la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al insertar datos, transacciÃ³n revertida"
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Respuesta exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => $contador_exitosas
                );
                $this->response($respuesta);
            }
        } else {
            // Respuesta de error por datos incompletos
            $respuesta = array(
                "error" => true,
                "mensaje" => "Datos incompletos en el POST"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    } else {
        // Respuesta de error por falta de datos en el POST
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function Pedidossucxapp_post()//Aca se procesan los envios de pedidos de la app y se los inserta en las talaba pedidosapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["pedidos"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='psucursal'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA
$contador_exitosas = 0; // Contador de inserciones exitosas
//$jsondata=json_decode($datos);
  foreach ($datos as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto
    if ($this->db->affected_rows() > 0) { // Si la inserciÃ³n fue exitosa
        $contador_exitosas += $this->db->affected_rows();
    }
  }
//$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=> $contador_exitosas//$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}

/**
 * FunciÃ³n auxiliar para generar recibo automÃ¡ticamente
 * Se ejecuta para todas las operaciones sin importar el saldo
 */
private function generarReciboAutomatico($cabecera, $id_num, $id_vend) {
    try {
        // Generar nÃºmero de recibo Ãºnico
        $numero_recibo = $this->getNextReciboNumber($id_vend);
        
        // Calcular importe total
        $importe_total = floatval($cabecera['basico']) + floatval($cabecera['iva1']);
        
        // Determinar el saldo del recibo (0 para operaciones al contado)
        $recibo_saldo = isset($cabecera['saldo']) ? floatval($cabecera['saldo']) : 0;
        
        // Preparar datos del recibo
        $recibo = array(
            'recibo' => $numero_recibo,
            'c_tipo' => 'RC',
            'c_numero' => isset($cabecera['numero_fac']) ? $cabecera['numero_fac'] : 0,
            'c_cuota' => 0,
            'fecha' => isset($cabecera['emitido']) ? $cabecera['emitido'] : date('Y-m-d'),
            'importe' => $importe_total,
            'usuario' => isset($cabecera['usuario']) ? $cabecera['usuario'] : 'sistema',
            'observacion' => 0,
            'cod_lugar' => '1',
            'sesion' => 0,
            'c_tipf' => isset($cabecera['letra']) ? $cabecera['letra'] : 'B',
            'c_puntoventa' => isset($cabecera['puntoventa']) ? $cabecera['puntoventa'] : 0,
            'recibo_asoc' => $id_num,
            'recibo_saldo' => $recibo_saldo,
            'cod_sucursal' => $id_vend,
            'fec_proceso' => date('Y-m-d'),
            'bonifica' => isset($cabecera['bonifica']) ? $cabecera['bonifica'] : 0,
            'bonifica_tipo' => isset($cabecera['bonifica_tipo']) ? $cabecera['bonifica_tipo'] : 'P',
            'interes' => isset($cabecera['interes']) ? $cabecera['interes'] : 0,
            'interes_tipo' => isset($cabecera['interes_tipo']) ? $cabecera['interes_tipo'] : 'P',
            'id_fac' => $id_num
        );
        
        // Insertar recibo en la tabla correspondiente
        $tabla_recibos = 'recibos' . $id_vend;
        $this->db->insert($tabla_recibos, $recibo);
        
        // Log del recibo generado
        log_message('info', 'Recibo generado automÃ¡ticamente: ' . $numero_recibo . ' para operaciÃ³n: ' . $id_num);
        
    } catch (Exception $e) {
        // Log del error pero no interrumpir la transacciÃ³n principal
        log_message('error', 'Error al generar recibo automÃ¡tico: ' . $e->getMessage());
    }
}

/**
 * FunciÃ³n auxiliar para obtener el siguiente nÃºmero de recibo
 */
private function getNextReciboNumber($id_vend) {
    try {
        // Obtener el Ãºltimo nÃºmero de recibo de la tabla correspondiente
        $tabla_recibos = 'recibos' . $id_vend;
        $this->db->select('MAX(CAST(recibo AS INTEGER)) as max_recibo');
        $this->db->from($tabla_recibos);
        $query = $this->db->get();
        
        if ($query->num_rows() > 0) {
            $row = $query->row();
            $max_recibo = $row->max_recibo;
            return $max_recibo ? $max_recibo + 1 : 1;
        } else {
            return 1;
        }
    } catch (Exception $e) {
        log_message('error', 'Error al obtener nÃºmero de recibo: ' . $e->getMessage());
        return 1;
    }
}

public function Mixto_post()
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["mixto"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='mixto'.$id_vend;


//$this->db->query("DELETE FROM $tabla");//PRUEBA

$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}

public function Articulossucxapp_post()//Aca se procesan los envios de pedidos de la app y se los inserta en las talaba pedidosapp
{
$data=$this->post();
if(isset($data) AND count($data)>0){ // TIENE QUE IR PUESTO ACA PR QUE SINO ME DA ERROR POR UNDEFINED INDEX CLIENTES
// para array como en el caso de $data se usa count en lugar de strlen ya que este es para strings

$datos=$data["articulos"];
$id_vend=$data["id_vend"]; //ESTO ES PARA DIRECCIONAR EL NOMBRE DE LA TABLA
$tabla='artsucapp'.$id_vend;

//$this->db->query("DELETE FROM $tabla");//PRUEBA

$jsondata=json_decode($datos);
  foreach ($jsondata as  $valor)
  {
    $this->db->insert($tabla, $valor);// valor es un objeto

  }
$rows =  $this->db->affected_rows(); // va a dar 1 por que lo hace de uno por vez

  $respuesta=array(
    "error"=>false,
    "mensaje"=>$rows
  );
   $this->response($respuesta);
}
else // ESTE ELSE ES POR SI NO SE ENVIAN DATOS EN EL POST
{
  $respuesta=array(
    "error"=>true,
    "mensaje"=>"faltan datos en el post"
  );
   $this->response($respuesta,REST_Controller::HTTP_BAD_REQUEST);
}

}
public function PagoCabecera_post()
{
    $data = $this->post();

    // Verificar que los datos necesarios estÃ©n presentes
    if (!isset($data['sucursal']) || !isset($data['pagoCC'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan datos requeridos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    $sucursal = $data['sucursal'];
    $pagoCC = $data['pagoCC'];

    // Verificar que todos los componentes necesarios de pagoCC estÃ©n presentes
    if (!isset($pagoCC['cabeceras']) || !isset($pagoCC['psucursal']) || !isset($pagoCC['cabecera']) || !isset($pagoCC['recibo'])) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan componentes en pagoCC"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // NUEVA VALIDACIÃ“N: Verificar que todos los documentos sean del mismo tipo
    $tiposUnicos = array();
    foreach ($pagoCC['cabeceras'] as $cabecera) {
        if (isset($cabecera['tipo']) && !in_array($cabecera['tipo'], $tiposUnicos)) {
            $tiposUnicos[] = $cabecera['tipo'];
        }
    }
    
    if (count($tiposUnicos) > 1) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se pueden procesar documentos de diferentes tipos en la misma operaciÃ³n"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }
    
    $tipoDocumento = $tiposUnicos[0] ?? 'FC';
    
    // Para presupuestos (PR), el frontend ya maneja la restricciÃ³n de efectivo
    // La informaciÃ³n del mÃ©todo de pago se almacena en 'codigo_mov' y 'caja', no en cod_tarj
    if ($tipoDocumento === 'PR') {
        // ValidaciÃ³n manejada en frontend - PR siempre usa efectivo (codTarj = "11")
        // No se requiere lÃ³gica adicional aquÃ­
    }

    // Iniciar transacciÃ³n
    $this->db->trans_start();

    $registros_afectados = array(
        'factcab' => 0,
        'psucursal' => 0,
        'recibos' => 0,
        'caja_movi' => 0  // âœ… NUEVO
    );

    $id_num_cabecera = null;

    // 1. Actualizar cabeceras en factcab<sucursal>
    foreach ($pagoCC['cabeceras'] as $cabecera) {
        if (!isset($cabecera['id_num']) || !isset($cabecera['saldo']) || !isset($cabecera['id_aso'])) {
            $this->db->trans_rollback();
            $respuesta = array(
                "error" => true,
                "mensaje" => "Datos incompletos en una cabecera"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->where('id_num', $cabecera['id_num']);
        $this->db->update('factcab' . $sucursal, array(
            'saldo' => $cabecera['saldo'],
            'id_aso' => $cabecera['id_aso'],
			'anumero_com' => $cabecera['anumero_com'],
			'atipo' => $cabecera['atipo']
        ));
        $registros_afectados['factcab'] += $this->db->affected_rows();
    }

    // 2. Insertar en psucursal<sucursal>
    $this->db->insert('psucursal' . $sucursal, $pagoCC['psucursal']);
    $registros_afectados['psucursal'] = $this->db->affected_rows();

    // 3. Insertar en factcab<sucursal> y obtener ID
    $this->db->insert('factcab' . $sucursal, $pagoCC['cabecera']);
    $registros_afectados['factcab'] += $this->db->affected_rows();
    $id_num_cabecera = $this->db->insert_id();

    // 4. Insertar en recibos<sucursal>
    foreach ($pagoCC['recibo'] as $recibo) {
        $this->db->insert('recibos' . $sucursal, $recibo);
        $registros_afectados['recibos'] += $this->db->affected_rows();
    }

    // âœ… NUEVO: 5. Insertar caja_movi (REUTILIZANDO LÃ“GICA DE PedidossucxappCompleto_post)
    if (isset($pagoCC['caja_movi']) && $pagoCC['caja_movi']) {
        $caja_movi = $pagoCC['caja_movi'];

        // Asignar el id_num generado
        $caja_movi['num_operacion'] = $id_num_cabecera;

        // Limpiar campos de fecha nulos o vacÃ­os
        foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
            if (isset($caja_movi[$dateField]) && empty($caja_movi[$dateField])) {
                $caja_movi[$dateField] = null;
            }
        }

        // Validar campos numÃ©ricos para prevenir desbordamientos
        $numeric_limit_fields = [
            'sucursal' => 999999,
            'codigo_mov' => 9999999999,
            'num_operacion' => 9999999999,
            'banco' => 9999999999,
            'num_cheque' => 9999999999,
            'cuenta_mov' => 999999,
            'cliente' => 9999999999,
            'proveedor' => 9999999999,
            'codigo_mbco' => 9999999999,
            'punto_venta' => 9999,
            'numero_comprobante' => 99999999
        ];

        foreach ($numeric_limit_fields as $field => $limit) {
            if (isset($caja_movi[$field]) && !empty($caja_movi[$field])) {
                if (is_numeric($caja_movi[$field]) && $caja_movi[$field] > $limit) {
                    $caja_movi[$field] = $limit;
                }
            } else {
                $caja_movi[$field] = null;
            }
        }

        // Limpiar campos de texto nulos o vacÃ­os
        foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
            if (isset($caja_movi[$strField]) && $caja_movi[$strField] === '') {
                $caja_movi[$strField] = null;
            }
        }

        // Generar descripciÃ³n automÃ¡tica si tipo_movi es 'A'
        if (isset($caja_movi['tipo_movi']) && $caja_movi['tipo_movi'] === 'A') {
            $caja_movi['descripcion_mov'] = $this->generarDescripcionAutomatica($caja_movi);
        }

        try {
            $this->db->insert('caja_movi', $caja_movi);
            $registros_afectados['caja_movi'] = $this->db->affected_rows();

            if ($registros_afectados['caja_movi'] > 0) {
                log_message('info', 'Movimiento de caja insertado para pago cabecera ID: ' . $id_num_cabecera);
            } else {
                log_message('error', 'Error al insertar movimiento de caja para pago ID: ' . $id_num_cabecera);
            }
        } catch (Exception $e) {
            log_message('error', 'ExcepciÃ³n al insertar en caja_movi ID ' . $id_num_cabecera . ': ' . $e->getMessage());
            // No hacer rollback, permitir que continÃºe
        }
    }

    // Completar transacciÃ³n
    $this->db->trans_complete();

    // Verificar si la transacciÃ³n fue exitosa
    if ($this->db->trans_status() === FALSE) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error en la transacciÃ³n. Se ha realizado un rollback."
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    } else {
        $respuesta = array(
            "error" => false,
            "mensaje" => "OperaciÃ³n exitosa",
            "registros_afectados" => $registros_afectados
        );
        $this->response($respuesta);
    }
}
public function PedidoItemyCab_post() {
        $data = $this->post();
        
        if(isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // ============================================================================
            // VALIDACIÃ“N DE ID_ART VÃLIDO
            // ============================================================================
            // Verificar que el id_art no sea 0 (artÃ­culo invÃ¡lido)
            if ($pedidoItem['id_art'] == 0 || $pedidoItem['id_art'] === '0' || empty($pedidoItem['id_art'])) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: ID de artÃ­culo invÃ¡lido (id_art = 0 o vacÃ­o). No se puede crear el pedido. Contacte al administrador del sistema."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            // Insertar en la tabla pedidoitem y obtener el ID
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                isset($pedidoItem['observacion']) ? $pedidoItem['observacion'] : '',
                $pedidoItem['estado']
            ]);
            $result = $query->row_array();
            $id_items = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : '',
                $pedidoscb['estado'],
                $id_items
            ]);
            $result = $query->row_array();
            $id_num = $result['id_num'];

            // Actualizar id_num en pedidoitem
            $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num, $id_items]);

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido. La transacciÃ³n ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacciÃ³n fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado exitosamente",
                    "id_items" => $id_items,
                    "id_num" => $id_num
                );
                $this->response($respuesta);
            }
        } else {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }
	public function PedidoItemyCabId_post() {
       $data = $this->post();

        // Validar que los datos necesarios estÃ©n presentes en la solicitud
        if(isset($data['id_num']) && isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $id_num_parametro = $data['id_num'];
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // ============================================================================
            // VALIDACIÃ“N DE ID_ART VÃLIDO
            // ============================================================================
            // Verificar que el id_art no sea 0 (artÃ­culo invÃ¡lido)
            if ($pedidoItem['id_art'] == 0 || $pedidoItem['id_art'] === '0' || empty($pedidoItem['id_art'])) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: ID de artÃ­culo invÃ¡lido (id_art = 0 o vacÃ­o). No se puede recibir el pedido. Contacte al administrador del sistema."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            // Insertar en la tabla pedidoitem y obtener el ID (sin modificar el estado por ahora)
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                isset($pedidoItem['observacion']) ? $pedidoItem['observacion'] : '',
                  $pedidoItem['estado'] // Establecer el estado inicial del nuevo pedidoItem
            ]);
            $result = $query->row_array();
            $id_items_nuevo = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?,?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : '',
                $pedidoscb['estado'],
                $id_items_nuevo // Asociar con el nuevo id_items
            ]);
            $result = $query->row_array();
            $id_num_generado = $result['id_num'];

            // Actualizar id_num en el nuevo pedidoitem
                $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num_generado, $id_items_nuevo]);

            // Actualizar estado a "Recibido" solo en el pedidoitem existente si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoitem SET estado = ? WHERE id_num = ? AND estado = 'Solicitado-E'", ["Recibido", $id_num_parametro]);
             }

              // Actualizar estado a "Recibido" solo en pedidoscb existentes si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoscb SET estado = ? WHERE id_num = ? AND estado = 'Solicitado-E'", ["Recibido", $id_num_parametro]);
             }

            // ============================================================================
            // ACTUALIZACIÃ“N AUTOMÃTICA DE STOCK EN RECEPCIÃ“N
            // ============================================================================
            // MAPEO DE FIREBASE VALUE A CAMPOS EXI
            // Firebase almacena un campo 'value' para cada sucursal que NO corresponde
            // directamente al nÃºmero del campo exi. Este mapeo traduce correctamente:
            $mapeo_sucursal_exi = [
                1 => 'exi2', // Casa Central
                2 => 'exi3', // Valle Viejo
                3 => 'exi4', // GÃ¼emes
                4 => 'exi1', // Deposito
                5 => 'exi5'  // Mayorista
            ];

            // Actualizar stock en sucursal DESTINO (la que recibe - SUMA stock)
            $sucursal_destino = $pedidoscb['sucursald'];
            $campo_stock_destino = isset($mapeo_sucursal_exi[$sucursal_destino])
                ? $mapeo_sucursal_exi[$sucursal_destino]
                : 'exi' . $sucursal_destino; // Fallback por seguridad

            $sql_update_destino = "UPDATE artsucursal
                                   SET $campo_stock_destino = $campo_stock_destino + ?
                                   WHERE id_articulo = ?";
            $this->db->query($sql_update_destino, [
                $pedidoItem['cantidad'],
                $pedidoItem['id_art']
            ]);

            // Actualizar stock en sucursal ORIGEN (la que envÃ­a - RESTA stock)
            $sucursal_origen = $pedidoscb['sucursalh'];
            $campo_stock_origen = isset($mapeo_sucursal_exi[$sucursal_origen])
                ? $mapeo_sucursal_exi[$sucursal_origen]
                : 'exi' . $sucursal_origen; // Fallback por seguridad

            // IMPORTANTE: Se permite stock negativo, NO validamos si hay suficiente
            $sql_update_origen = "UPDATE artsucursal
                                  SET $campo_stock_origen = $campo_stock_origen - ?
                                  WHERE id_articulo = ?";
            $this->db->query($sql_update_origen, [
                $pedidoItem['cantidad'],
                $pedidoItem['id_art']
            ]);
            // ============================================================================

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido y actualizar estados. La transacciÃ³n ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacciÃ³n fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado y estados actualizados exitosamente",
                    "id_items_nuevo" => $id_items_nuevo,
                    "id_num_generado" => $id_num_generado
                );
                $this->response($respuesta);
            }
        } else {
            // Si faltan datos en la solicitud
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST. Se requieren 'id_num', 'pedidoItem' y 'pedidoscb'."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }
	
	public function PedidoItemyCabIdEnvio_post() {
       $data = $this->post();

        // Validar que los datos necesarios estÃ©n presentes en la solicitud
        if(isset($data['id_num']) && isset($data['pedidoItem']) && isset($data['pedidoscb'])) {
            $id_num_parametro = $data['id_num'];
            $pedidoItem = $data['pedidoItem'];
            $pedidoscb = $data['pedidoscb'];

            $this->db->trans_start(); // Iniciar transacciÃ³n

            // ============================================================================
            // VALIDACIÃ“N DE ID_ART VÃLIDO
            // ============================================================================
            // Verificar que el id_art no sea 0 (artÃ­culo invÃ¡lido)
            if ($pedidoItem['id_art'] == 0 || $pedidoItem['id_art'] === '0' || empty($pedidoItem['id_art'])) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: ID de artÃ­culo invÃ¡lido (id_art = 0 o vacÃ­o). No se puede procesar el envÃ­o. Contacte al administrador del sistema."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            // ============================================================================
            // VALIDACIÃ“N DE STOCK DISPONIBLE ANTES DE ENVIAR
            // ============================================================================
            // MAPEO DE FIREBASE VALUE A CAMPOS EXI
            // Firebase almacena un campo 'value' para cada sucursal que NO corresponde
            // directamente al nÃºmero del campo exi. Este mapeo traduce correctamente:
            // value 1 (Casa Central) â†’ exi2
            // value 2 (Valle Viejo)  â†’ exi3
            // value 3 (GÃ¼emes)       â†’ exi4
            // value 4 (Deposito)     â†’ exi1
            // value 5 (Mayorista)    â†’ exi5
            $mapeo_sucursal_exi = [
                1 => 'exi2', // Casa Central
                2 => 'exi3', // Valle Viejo
                3 => 'exi4', // GÃ¼emes
                4 => 'exi1', // Deposito
                5 => 'exi5'  // Mayorista
            ];

            $sucursal_origen = $pedidoscb['sucursald']; // Sucursal que envÃ­a (ORIGEN en esta funciÃ³n)
            $campo_stock_origen = isset($mapeo_sucursal_exi[$sucursal_origen])
                ? $mapeo_sucursal_exi[$sucursal_origen]
                : 'exi' . $sucursal_origen; // Fallback por seguridad

            // Consultar stock actual de la sucursal que envÃ­a
            $sql_check_stock = "SELECT $campo_stock_origen as stock_actual
                                FROM artsucursal
                                WHERE id_articulo = ?";
            $query_stock = $this->db->query($sql_check_stock, [$pedidoItem['id_art']]);

            if ($query_stock->num_rows() === 0) {
                // El artÃ­culo no existe en artsucursal
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: El artÃ­culo no existe en el catÃ¡logo."
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }

            $row_stock = $query_stock->row_array();
            $stock_actual = $row_stock['stock_actual'];

            // NOTA: Se permite enviar stock incluso con valores negativos
            // El sistema debe permitir stocks negativos para reflejar deudas de stock
            // Por ejemplo: Si sucursal tiene -80 y envÃ­a 1, quedarÃ¡ -81
            /* VALIDACIÃ“N DESHABILITADA - Se permite stock negativo
            if ($stock_actual < $pedidoItem['cantidad']) {
                $this->db->trans_rollback();
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error: Stock insuficiente en sucursal origen. Disponible: " . $stock_actual . ", Solicitado: " . $pedidoItem['cantidad']
                );
                $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
                return;
            }
            */
            // ============================================================================

            // Insertar en la tabla pedidoitem y obtener el ID (sin modificar el estado por ahora)
            $sql_pedidoitem = "INSERT INTO pedidoitem (tipo, cantidad, id_art, descripcion, precio, fecha_resuelto, usuario_res, observacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_items";
            $query = $this->db->query($sql_pedidoitem, [
                $pedidoItem['tipo'],
                $pedidoItem['cantidad'],
                $pedidoItem['id_art'],
                $pedidoItem['descripcion'],
                $pedidoItem['precio'],
                $pedidoItem['fecha_resuelto'],
                $pedidoItem['usuario_res'],
                isset($pedidoItem['observacion']) ? $pedidoItem['observacion'] : '',
                  $pedidoItem['estado'] // Establecer el estado inicial del nuevo pedidoItem
            ]);
            $result = $query->row_array();
            $id_items_nuevo = $result['id_items'];

            // Insertar en la tabla pedidoscb y obtener el ID
            $sql_pedidoscb = "INSERT INTO pedidoscb (tipo, sucursald, sucursalh, fecha, usuario, observacion, estado, id_aso) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id_num";
            $query = $this->db->query($sql_pedidoscb, [
                $pedidoscb['tipo'],
                //$pedidoscb['numero'],
                $pedidoscb['sucursald'],
                $pedidoscb['sucursalh'],
                $pedidoscb['fecha'],
                $pedidoscb['usuario'],
                isset($pedidoscb['observacion']) ? $pedidoscb['observacion'] : '',
                $pedidoscb['estado'],
                $id_items_nuevo // Asociar con el nuevo id_items
            ]);
            $result = $query->row_array();
            $id_num_generado = $result['id_num'];

            // Actualizar id_num en el nuevo pedidoitem
                $this->db->query("UPDATE pedidoitem SET id_num = ? WHERE id_items = ?", [$id_num_generado, $id_items_nuevo]);

            // Actualizar estado a "Solicitado-E" solo en el pedidoitem existente si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoitem SET estado = ? WHERE id_num = ? AND estado = 'Solicitado'", ["Solicitado-E", $id_num_parametro]);
             }
             
              // Actualizar estado a "Solicitado-E" solo en pedidoscb existentes si se proporciona id_num
            if ($id_num_parametro) {
                 $this->db->query("UPDATE pedidoscb SET estado = ? WHERE id_num = ? AND estado = 'Solicitado'", ["Solicitado-E", $id_num_parametro]);
             }

            // ============================================================================
            // ACTUALIZACIÃ“N AUTOMÃTICA DE STOCK EN ENVÃO DIRECTO
            // ============================================================================
            // IMPORTANTE: En esta funciÃ³n, la semÃ¡ntica es DIFERENTE a PedidoItemyCabId_post:
            // - sucursald = ORIGEN (quien envÃ­a)
            // - sucursalh = DESTINO (quien recibe)

            // Actualizar stock en sucursal DESTINO (la que recibe - SUMA stock)
            $sucursal_destino = $pedidoscb['sucursalh']; // DESTINO en esta funciÃ³n
            $campo_stock_destino = isset($mapeo_sucursal_exi[$sucursal_destino])
                ? $mapeo_sucursal_exi[$sucursal_destino]
                : 'exi' . $sucursal_destino; // Fallback por seguridad

            $sql_update_destino = "UPDATE artsucursal
                                   SET $campo_stock_destino = $campo_stock_destino + ?
                                   WHERE id_articulo = ?";
            $this->db->query($sql_update_destino, [
                $pedidoItem['cantidad'],
                $pedidoItem['id_art']
            ]);

            // Actualizar stock en sucursal ORIGEN (la que envÃ­a - RESTA stock)
            // Nota: $sucursal_origen y $campo_stock_origen ya definidos en lÃ­neas 1853-1856
            // IMPORTANTE: Se permite stock negativo, NO validamos si hay suficiente
            $sql_update_origen = "UPDATE artsucursal
                                  SET $campo_stock_origen = $campo_stock_origen - ?
                                  WHERE id_articulo = ?";
            $this->db->query($sql_update_origen, [
                $pedidoItem['cantidad'],
                $pedidoItem['id_art']
            ]);
            // ============================================================================

            $this->db->trans_complete(); // Completar transacciÃ³n

            if ($this->db->trans_status() === FALSE) {
                // Si hubo un error en la transacciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "Error al crear el pedido y actualizar estados. La transacciÃ³n ha sido revertida."
                );
                $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
            } else {
                // Si la transacciÃ³n fue exitosa
                $respuesta = array(
                    "error" => false,
                    "mensaje" => "Pedido creado y estados actualizados exitosamente",
                    "id_items_nuevo" => $id_items_nuevo,
                    "id_num_generado" => $id_num_generado
                );
                $this->response($respuesta);
            }
        } else {
            // Si faltan datos en la solicitud
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan datos en el POST. Se requieren 'id_num', 'pedidoItem' y 'pedidoscb'."
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        }
    }

public function SubirDatosRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_rubro']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_rubro, rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('rubro_principal', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function SubirDatosArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['nomart']) || !isset($data['marca']) || !isset($data['precon'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (nomart, marca, precon)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new articulo with all fields
        $this->db->insert('artsucursal', array(
            'nomart' => $data['nomart'],
            'marca' => $data['marca'],
            'precon' => $data['precon'],
            'prefi1' => $data['prefi1'],
            'prefi2' => $data['prefi2'],
            'prefi3' => $data['prefi3'],
            'prefi4' => $data['prefi4'],
            'exi1' => $data['exi1'],
            'exi2' => $data['exi2'],
            'exi3' => $data['exi3'],
            'exi4' => $data['exi4'],
            'exi5' => $data['exi5'],
            'stkmin1' => $data['stkmin1'],
            'stkmax1' => $data['stkmax1'],
            'stkprep1' => $data['stkprep1'],
            'stkmin2' => $data['stkmin2'],
            'stkmax2' => $data['stkmax2'],
            'stkprep2' => $data['stkprep2'],
            'stkmin3' => $data['stkmin3'],
            'stkmax3' => $data['stkmax3'],
            'stkprep3' => $data['stkprep3'],
            'stkmin4' => $data['stkmin4'],
            'stkmax4' => $data['stkmax4'],
            'stkprep4' => $data['stkprep4'],
            'stkmin5' => $data['stkmin5'],
            'stkmax5' => $data['stkmax5'],
            'stkprep5' => $data['stkprep5'],
            'cd_articulo' => $data['cd_articulo'],
            'cd_proveedor' => $data['cd_proveedor'],
            'cd_barra' => $data['cd_barra'],
            'idart' => $data['idart'],
            'estado' => $data['estado'],
            'rubro' => $data['rubro'],
            'articulo' => $data['articulo'],
            'cod_iva' => $data['cod_iva'],
            'prebsiva' => $data['prebsiva'],
            'precostosi' => $data['precostosi'],
            'margen' => $data['margen'],
            'descuento' => $data['descuento'],
            'cod_deposito' => $data['cod_deposito'],
            'tipo_moneda' => $data['tipo_moneda']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function SubirDatosTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_mone']) || !isset($data['moneda']) || !isset($data['simbolo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_mone, moneda, simbolo)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('tipomone', array(
            "cod_mone"=> $data['cod_mone'],
        "moneda"=> $data['moneda'],
        "simbolo"=> $data['simbolo'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['codmone']) || !isset($data['desvalor']) || !isset($data['vcambio'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (codmone, desvalor, vcambio)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro
        $this->db->insert('valorcambio', array(
            "codmone"=> $data['codmone'],
        "desvalor"=> $data['desvalor'],
        "fecdesde"=> $data['fecdesde'],
        "fechasta"=> $data['fechasta'],
        "vcambio"=> $data['vcambio'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function SubirDatosProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['nombre']) || !isset($data['cuit'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (nombre, cuit)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new provider with all fields
        $this->db->insert('proveedores', array(
            'cod_prov' => $data['cod_prov'],
            'nombre' => $data['nombre'],
            'direccion' => $data['direccion'],
            'codpos' => $data['codpos'],
            'localidad' => $data['localidad'],
            'telefono' => $data['telefono'],
            'cuit' => $data['cuit'],
            'contacto' => $data['contacto'],
            'rubro' => $data['rubro'],
            'cod_iva' => $data['cod_iva'],
            'ganancias' => $data['ganancias'],
            'ingbrutos' => $data['ingbrutos'],
            'email' => $data['email'],
            'www' => $data['www'],
            'cta_proveedores' => $data['cta_proveedores'],
            'fec_proceso' => $data['fec_proceso']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosArtIva_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_iva']) || !isset($data['descripcion'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_iva, descripcion)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new artiva record
        $this->db->insert('artiva', array(
            'cod_iva' => $data['cod_iva'],
            'descripcion' => $data['descripcion'],
            // 'desde_date' => $data['desde_date'],
           /*  'desde_date' => date('Y-m-d', strtotime($data['desde_date'])),
            'hasta_date' => $data['hasta_date'], */
    'desde' => !empty($data['desde']) ? date('Y-m-d', strtotime($data['desde'])) : null,
'hasta' => !empty($data['hasta']) ? date('Y-m-d', strtotime($data['hasta'])) : null,
            'tipo_ali_1' => $data['tipo_ali_1'],
            'alicuota1' => $data['alicuota1'],
            'tipo_ali_2' => $data['tipo_ali_2'],
            'alicuota2' => $data['alicuota2'],
            'tipo_ali_3' => $data['tipo_ali_3'],
            'alicuota3' => $data['alicuota3'],
            'cuit' => $data['cuit'] ? 't' : 'f'
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el registro de IVA"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n bÃ¡sica de campos requeridos (se pueden aÃ±adir mÃ¡s)
        if(!isset($data['descripcion']) || !isset($data['tipo_concepto']) || !isset($data['fija']) || !isset($data['ingreso_egreso']) || !isset($data['id_caja']) || !isset($data['activo_inactivo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos para el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start();

        // Insertar nuevo concepto
        $this->db->insert('caja_conceptos', array(
            'descripcion' => $data['descripcion'],
            'tipo_concepto' => $data['tipo_concepto'],
            'fija' => $data['fija'],
            'ingreso_egreso' => $data['ingreso_egreso'],
            'id_caja' => $data['id_caja'],
            'activo_inactivo' => $data['activo_inactivo']
            // 'id_concepto' es serial y se genera automÃ¡ticamente
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Indica cuÃ¡ntas filas se insertaron (deberÃ­a ser 1)
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosCajamovi_post()
{
    $data = $this->post(); // Recibe el objeto JSON directamente del servicio Angular
    if(isset($data) && count($data) > 0) {

        // ValidaciÃ³n bÃ¡sica (puedes aÃ±adir mÃ¡s validaciones segÃºn necesidad)
        if(!isset($data['sucursal']) || !isset($data['codigo_mov']) || !isset($data['fecha_mov']) || !isset($data['importe_mov']) || !isset($data['descripcion_mov']) || !isset($data['marca_cerrado']) || !isset($data['tipo_movi']) || !isset($data['caja'])) {
             $respuesta = array(
                 "error" => true,
                 "mensaje" => "Faltan campos requeridos para el movimiento de caja"
             );
             $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
             return;
         }

        // Limpiar datos antes de insertar (ej: convertir fechas si vienen como string)
        // Asumiendo que las fechas vienen en formato YYYY-MM-DD del form Angular
        foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
            if (isset($data[$dateField]) && empty($data[$dateField])) {
                 $data[$dateField] = null; // Convertir strings vacÃ­os a NULL para la DB
            } elseif (isset($data[$dateField])) {
                // PodrÃ­as aÃ±adir validaciÃ³n de formato de fecha aquÃ­ si es necesario
                 //$date = DateTime::createFromFormat('Y-m-d', $data[$dateField]);
                 //if ($date === false || $date->format('Y-m-d') !== $data[$dateField]) {
                 //    // Error de formato
                 //}
            }
        }
         // Asegurar que los campos numÃ©ricos opcionales vacÃ­os sean NULL
         foreach(['banco', 'num_cheque', 'cuenta_mov', 'cliente', 'proveedor', 'codigo_mbco', 'punto_venta', 'numero_comprobante'] as $numField) {
             if (isset($data[$numField]) && $data[$numField] === '') {
                  $data[$numField] = null;
             }
         }
         // Asegurar que los campos string opcionales vacÃ­os sean NULL o string vacÃ­o segÃºn prefieras
         foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
              if (isset($data[$strField]) && $data[$strField] === '') {
                   $data[$strField] = null; // O mantener como '' si la DB lo permite/prefiere
              }
         }

        // Generar descripciÃ³n automÃ¡tica si tipo_movi es 'A'
        if (isset($data['tipo_movi']) && $data['tipo_movi'] === 'A') {
            $data['descripcion_mov'] = $this->generarDescripcionAutomatica($data);
        }

        $this->db->trans_start(); // Iniciar transacciÃ³n

        $this->db->insert('caja_movi', $data); // Insertar los datos recibidos

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Completar transacciÃ³n

        if ($this->db->trans_status() === FALSE) {
            // Transaction failed
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            // Success response
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Devuelve el nÃºmero de filas afectadas (deberÃ­a ser 1)
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}



public function SubirDatosCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n bÃ¡sica (puedes aÃ±adir mÃ¡s segÃºn necesidad)
        if(!isset($data['descripcion']) || !isset($data['fecha_cierre']) || !isset($data['especial']) || !isset($data['fija'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (descripcion, fecha_cierre, especial, fija)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        // Preparar datos para insertar
        $insert_data = array(
            'descripcion' => trim($data['descripcion']),
            'fecha_cierre' => $data['fecha_cierre'], // Asume que el formato es compatible con 'date' de PGSQL
            'especial' => (int)$data['especial'], // Asegurar que sea entero (0 o 1)
            'fija' => (int)$data['fija']          // Asegurar que sea entero (0 o 1)
        );

        $this->db->trans_start();
        $this->db->insert('caja_lista', $insert_data);
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta, REST_Controller::HTTP_CREATED); // Opcional: HTTP Status 201
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosConflista_post()
{
    try {
        $data = $this->post();
        if (!isset($data) || count($data) === 0) {
            $respuesta = [
                "error"   => true,
                "mensaje" => "No se recibieron datos en el POST"
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
        // Validar campo obligatorio
        if (!isset($data['listap'])) {
            $respuesta = [
                "error"   => true,
                "mensaje" => "Faltan campos requeridos (listap)"
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $listap     = $data['listap'];
        $tipomone   = isset($data['tipomone'])   ? $data['tipomone']   : 0;
        $preciof21  = isset($data['preciof21'])  ? (float)$data['preciof21']  : 0;
        $preciof105 = isset($data['preciof105']) ? (float)$data['preciof105'] : 0;

        // DiagnÃ³stico
        $diagnostico = [
            'parametros_recibidos' => [
                'listap'     => $listap,
                'tipomone'   => $tipomone,
                'preciof21'  => $preciof21,
                'preciof105' => $preciof105
            ],
            'verificaciones' => []
        ];

        // CuÃ¡ntos productos hay con ese tipo de moneda
        $this->db->select('COUNT(*) as total');
        $this->db->where('tipo_moneda', $tipomone);
        $query_tipo_moneda = $this->db->get('artsucursal');
        $diagnostico['verificaciones']['productos_con_tipo_moneda']
            = $query_tipo_moneda->row()->total;

        // Resultados que devolveremos
        $resultados = [
            'conflista_creada'         => false,
            'productos_actualizados_21'  => 0,
            'productos_actualizados_105' => 0
        ];

        $this->db->trans_start();

        // Insertar la nueva conflista
        $this->db->insert('conf_lista', [
            'listap'     => $listap,
            'activa'     => isset($data['activa'])     ? $data['activa']     : false,
            'precosto21' => isset($data['precosto21']) ? $data['precosto21'] : 0,
            'precosto105'=> isset($data['precosto105'])? $data['precosto105']: 0,
            'pordcto'    => isset($data['pordcto'])    ? $data['pordcto']    : 0,
            'margen'     => isset($data['margen'])     ? $data['margen']     : 0,
            'preciof21'  => $preciof21,
            'preciof105' => $preciof105,
            'rmargen'    => isset($data['rmargen'])    ? $data['rmargen']    : false,
            'tipomone'   => $tipomone,
            'actprov'    => isset($data['actprov'])    ? $data['actprov']    : false,
            'cod_marca'  => isset($data['cod_marca'])  ? $data['cod_marca']  : '',
            'fecha'      => isset($data['fecha'])      ? $data['fecha']      : date('Y-m-d')
        ]);
        $conflista_id = $this->db->insert_id();
        $resultados['conflista_creada'] = true;
        $resultados['id_conflista']     = $conflista_id;

        // Nombre del campo de precio dinÃ¡mico
        $campo_precio = 'prefi' . $listap;
        $diagnostico['verificaciones']['campo_precio'] = $campo_precio;
        // Verificar existencia del campo
        $sql_check = "
            SELECT column_name
              FROM information_schema.columns
             WHERE table_name = 'artsucursal'
               AND column_name = ?
        ";
        $query_check = $this->db->query($sql_check, [$campo_precio]);
        $campo_existe = $query_check->num_rows() > 0;
        $diagnostico['verificaciones']['campo_existe'] = $campo_existe;

        if (!$campo_existe) {
            $diagnostico['verificaciones']['advertencia']
                = "El campo {$campo_precio} no existe en artsucursal";
            $this->db->trans_complete();

            $respuesta = [
                "error"      => false,
                "mensaje"    => "Lista creada pero no se actualizaron precios porque el campo {$campo_precio} no existe",
                "resultados" => $resultados,
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta);
            return;
        }

        //
        // === BLOQUE IVA 21% ===
        //
        $diagnostico['iva21_info'] = [];

        $this->db->select('cod_iva');
        $this->db->where("ROUND(CAST(alicuota1 AS numeric),2) =", 21.00);
        $query_iva21 = $this->db->get('artiva');

        $diagnostico['iva21_info']['registros_encontrados'] = $query_iva21->num_rows();

        if ($query_iva21->num_rows() > 0) {
            $iva21_records = [];
            foreach ($query_iva21->result() as $row) {
                $iva21_records[] = $row->cod_iva;
            }
            $diagnostico['iva21_info']['cod_iva_valores'] = $iva21_records;

            if (!empty($iva21_records)) {
                $factor21 = 1 + ($preciof21 / 100);
                $diagnostico['iva21_info']['factor'] = $factor21;

                // Contar productos elegibles con idart = 0
                $this->db->where_in('cod_iva', $iva21_records);
                $this->db->where('tipo_moneda', $tipomone);
                $this->db->where('idart', 0);
                $count_query = $this->db->get('artsucursal');
                $diagnostico['iva21_info']['productos_elegibles']
                    = $count_query->num_rows();

                if ($count_query->num_rows() > 0) {
                    $rows_affected = 0;
                    foreach ($iva21_records as $iva_code) {
                        $sql_update = "
                            UPDATE artsucursal
                               SET {$campo_precio} = precon * ?
                             WHERE cod_iva     = ?
                               AND tipo_moneda = ?
                               AND idart        = 0
                        ";
                        $this->db->query($sql_update, [
                            $factor21,
                            $iva_code,
                            $tipomone
                        ]);
                        $rows_affected += $this->db->affected_rows();
                    }
                    $resultados['productos_actualizados_21'] = $rows_affected;
                    $diagnostico['iva21_info']['productos_actualizados'] = $rows_affected;
                }
            }
        }

        //
        // === BLOQUE IVA 10.5% ===
        //
        $diagnostico['iva105_info'] = [];

        $this->db->select('cod_iva');
        $this->db->where("ROUND(CAST(alicuota1 AS numeric),2) =", 10.50);
        $query_iva105 = $this->db->get('artiva');

        $diagnostico['iva105_info']['registros_encontrados'] = $query_iva105->num_rows();

        if ($query_iva105->num_rows() > 0) {
            $iva105_records = [];
            foreach ($query_iva105->result() as $row) {
                $iva105_records[] = $row->cod_iva;
            }
            $diagnostico['iva105_info']['cod_iva_valores'] = $iva105_records;

            if (!empty($iva105_records)) {
                $factor105 = 1 + ($preciof105 / 100);
                $diagnostico['iva105_info']['factor'] = $factor105;

                // Contar productos elegibles con idart = 0
                $this->db->where_in('cod_iva', $iva105_records);
                $this->db->where('tipo_moneda', $tipomone);
                $this->db->where('idart', 0);
                $count_query = $this->db->get('artsucursal');
                $diagnostico['iva105_info']['productos_elegibles']
                    = $count_query->num_rows();

                if ($count_query->num_rows() > 0) {
                    $rows_affected = 0;
                    foreach ($iva105_records as $iva_code) {
                        $sql_update = "
                            UPDATE artsucursal
                               SET {$campo_precio} = precon * ?
                             WHERE cod_iva     = ?
                               AND tipo_moneda = ?
                               AND idart        = 0
                        ";
                        $this->db->query($sql_update, [
                            $factor105,
                            $iva_code,
                            $tipomone
                        ]);
                        $rows_affected += $this->db->affected_rows();
                    }
                    $resultados['productos_actualizados_105'] = $rows_affected;
                    $diagnostico['iva105_info']['productos_actualizados'] = $rows_affected;
                }
            }
        }

        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = [
                "error"      => true,
                "mensaje"    => "Error al procesar la operaciÃ³n",
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = [
                "error"      => false,
                "mensaje"    => "OperaciÃ³n completada exitosamente",
                "resultados" => $resultados,
                "diagnostico"=> $diagnostico
            ];
            $this->response($respuesta);
        }
    } catch (Exception $e) {
        $respuesta = [
            "error"   => true,
            "mensaje" => "Error en el servidor: " . $e->getMessage(),
            "file"    => $e->getFile(),
            "line"    => $e->getLine()
        ];
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

public function UpdateCajaLista_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // ValidaciÃ³n bÃ¡sica
        if(!isset($data['id_caja']) || !isset($data['descripcion']) || !isset($data['fecha_cierre']) || !isset($data['especial']) || !isset($data['fija'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (id_caja, descripcion, fecha_cierre, especial, fija)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = (int)$data['id_caja'];

        // Preparar datos para actualizar
        $update_data = array(
            'descripcion' => trim($data['descripcion']),
            'fecha_cierre' => $data['fecha_cierre'],
            'especial' => (int)$data['especial'],
            'fija' => (int)$data['fija']
        );

        $this->db->trans_start();
        $this->db->where('id_caja', $id);
        $this->db->update('caja_lista', $update_data);
        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar la caja lista"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             // Incluso si no se modificÃ³ nada (rows=0), la operaciÃ³n fue exitosa si trans_status es TRUE
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows // Informa cuÃ¡ntas filas fueron realmente cambiadas
                // "mensaje" => "ActualizaciÃ³n completada" // Alternativa
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateRubroPrincipal_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_rubro_p']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (id, datos)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro_p'];
        $datos = $data['rubro'];

        // Validate datos structure
        if(!isset($datos['cod_rubro']) || !isset($datos['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "El objeto datos debe contener cod_rubro y rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start();

        // Update rubro_principal
        $this->db->where('id_rubro_p', $id);
        $this->db->update('rubro_principal', array(
            'cod_rubro' => $datos['cod_rubro'],
            'rubro' => $datos['rubro']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro principal"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $datos
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateProveedor_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_prov'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_prov'];

        $this->db->trans_start();

        // Update proveedores table with all fields
        $this->db->where('id_prov', $id);
        $this->db->update('proveedores', array(
            'cod_prov' => $data['cod_prov'],
            'nombre' => $data['nombre'],
            'direccion' => $data['direccion'],
            'codpos' => $data['codpos'],
            'localidad' => $data['localidad'],
            'telefono' => $data['telefono'],
            'cuit' => $data['cuit'],
            'contacto' => $data['contacto'],
            'rubro' => $data['rubro'],
            'cod_iva' => $data['cod_iva'],
            'ganancias' => $data['ganancias'],
            'ingbrutos' => $data['ingbrutos'],
            'email' => $data['email'],
            'www' => $data['www'],
            'cta_proveedores' => $data['cta_proveedores'],
            'fec_proceso' => $data['fec_proceso']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el proveedor"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}
public function UpdateRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_rubro'];

        $this->db->trans_start();

        // Update rubros table with all fields
        $this->db->where('id_rubro', $id);
        $this->db->update('rubros', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro'],
            'numerador' => $data['numerador'],
            'modiprecio' => $data['modiprecio'],
            'modidescri' => $data['modidescri'],
            'cod_depo' => $data['cod_depo'],
            'mustuni' => $data['mustuni']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_marca'];

        $this->db->trans_start();

        // Update rubros table with all fields
        $this->db->where('id_marca', $id);
        $this->db->update('marcas', array(
            'id_marca' => $data['id_marca'],
            'cod_marca' => $data['cod_marca'],
            'marca' => $data['marca'],
            
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateTipoMoneda_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_moneda'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_moneda'];

        $this->db->trans_start();

        // Update tipomone table with all fields
        $this->db->where('id_moneda', $id);
        $this->db->update('tipomone', array(
            'cod_mone' => $data['cod_mone'],
            'moneda' => $data['moneda'],
            'simbolo' => $data['simbolo']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el tipo de moneda"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateValorCambio_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['id_valor'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_valor'];

        $this->db->trans_start();

        // Update valorcambio table with all fields
        $this->db->where('id_valor', $id);
        $this->db->update('valorcambio', array(
            'codmone' => $data['codmone'],
            'desvalor' => $data['desvalor'],
            'fecdesde' => $data['fecdesde'],
            'fechasta' => $data['fechasta'],
            'vcambio' => $data['vcambio']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el valor de cambio"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateCajamovi_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar que el ID estÃ© presente
        if(!isset($data['id_movimiento'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del movimiento para actualizar"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_movimiento'];
        unset($data['id_movimiento']); // No se actualiza el ID

        // ===========================================================================
        // FASE 7: POLÃTICA DE EDICIÃ“N - Verificar si el movimiento tiene desglose
        // Si tiene desglose de mÃ©todos de pago, denegar la ediciÃ³n para mantener
        // la integridad de los datos histÃ³ricos
        // ===========================================================================
        $sql_verificar = "SELECT COUNT(*) as tiene_desglose FROM caja_movi_detalle WHERE id_movimiento = ?";
        $query_verificar = $this->db->query($sql_verificar, array($id));

        if ($query_verificar && $query_verificar->num_rows() > 0) {
            $resultado = $query_verificar->row();
            if ($resultado->tiene_desglose > 0) {
                // El movimiento tiene desglose, denegar ediciÃ³n
                $respuesta = array(
                    "error" => true,
                    "mensaje" => "No se puede editar este movimiento porque tiene desglose de mÃ©todos de pago registrado. Los movimientos con desglose son de solo lectura para mantener la integridad de los datos histÃ³ricos.",
                    "codigo" => "MOVIMIENTO_CON_DESGLOSE_NO_EDITABLE"
                );
                $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
                return;
            }
        }
        // ===========================================================================

       // Limpiar datos (similar a la inserciÃ³n)
       foreach(['fecha_mov', 'fecha_emibco', 'fecha_cobro_bco', 'fecha_vto_bco', 'fecha_proceso'] as $dateField) {
           if (isset($data[$dateField]) && empty($data[$dateField])) {
                $data[$dateField] = null;
           }
       }
       foreach(['banco', 'num_cheque', 'cuenta_mov', 'cliente', 'proveedor', 'codigo_mbco', 'punto_venta', 'numero_comprobante'] as $numField) {
             if (isset($data[$numField]) && ($data[$numField] === '' || $data[$numField] === null)) {
                  $data[$numField] = null;
             }
         }
        foreach(['plaza_cheque', 'desc_bancaria', 'letra', 'tipo_comprobante'] as $strField) {
             if (isset($data[$strField]) && $data[$strField] === '') {
                  $data[$strField] = null;
             }
        }

        $this->db->trans_start();

        $this->db->where('id_movimiento', $id);
        $this->db->update('caja_movi', $data); // Actualiza con los datos recibidos

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el movimiento de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows, // Filas afectadas (puede ser 0 si no cambiÃ³ nada, o 1)
                "datos" => $this->post() // Devuelve los datos enviados para referencia
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}



public function UpdateConflista_post()
{
    try {
        $data = $this->post();
        
        // ===================================================
        // VALIDACIONES BÃSICAS PHP (OPCIONALES - PostgreSQL LAS REPETIRÃ)
        // ===================================================
        if (!isset($data['id_conflista'])) {
            $respuesta = [
                'error' => true,
                'mensaje' => 'Falta el ID de la conflista'
            ];
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
        
        // ===================================================
        // PREPARAR PARÃMETROS PARA POSTGRESQL
        // CONVERSIÃ“N ADECUADA DE TIPOS BOOLEAN
        // ===================================================
        
        // Convertir valores 't'/'f' a boolean para PostgreSQL
        $activa_bool = ($data['activa'] === 't' || $data['activa'] === true || $data['activa'] === 'true') ? true : false;
        $rmargen_bool = (($data['rmargen'] ?? 'f') === 't' || ($data['rmargen'] ?? false) === true) ? true : false;
        $actprov_bool = (($data['actprov'] ?? 'f') === 't' || ($data['actprov'] ?? false) === true) ? true : false;
        
        $params = [
            (int)$data['id_conflista'],                                           // p_id_conflista
            (int)$data['listap'],                                                // p_listap
            $activa_bool,                                                        // p_activa (boolean)
            (float)($data['precosto21'] ?? 0),                                   // p_precosto21
            (float)($data['precosto105'] ?? 0),                                  // p_precosto105
            (float)($data['pordcto'] ?? 0),                                      // p_pordcto
            (float)($data['margen'] ?? 0),                                       // p_margen
            (float)($data['preciof21'] ?? 0),                                    // p_preciof21
            (float)($data['preciof105'] ?? 0),                                   // p_preciof105
            $rmargen_bool,                                                       // p_rmargen (boolean)
            (int)($data['tipomone'] ?? 1),                                       // p_tipomone
            $actprov_bool,                                                       // p_actprov (boolean)
            $data['cod_marca'] ?? '',                                            // p_cod_marca
            $data['fecha'] ?? date('Y-m-d'),                                     // p_fecha
            isset($data['recalcular_21']) && $data['recalcular_21'] ? true : false,   // p_recalcular_21
            isset($data['recalcular_105']) && $data['recalcular_105'] ? true : false  // p_recalcular_105
        ];
        
        // ===================================================
        // LLAMADA ÃšNICA A POSTGRESQL - TODO ATÃ“MICO
        // USANDO CONSULTA DIRECTA PARA EVITAR PROBLEMAS DE CODEIGNITER
        // ===================================================
        
        // Construir la consulta SQL directamente con valores escapados
        $sql = sprintf(
            "SELECT update_conflista_con_recalculo(%d,%d,%s,%s,%s,%s,%s,%s,%s,%s,%d,%s,'%s','%s',%s,%s) as resultado",
            $params[0],  // id_conflista
            $params[1],  // listap
            $params[2] ? 'true' : 'false',  // activa
            $params[3],  // precosto21
            $params[4],  // precosto105
            $params[5],  // pordcto
            $params[6],  // margen
            $params[7],  // preciof21
            $params[8],  // preciof105
            $params[9] ? 'true' : 'false',  // rmargen
            $params[10], // tipomone
            $params[11] ? 'true' : 'false', // actprov
            $params[12], // cod_marca
            $params[13], // fecha
            $params[14] ? 'true' : 'false', // recalcular_21
            $params[15] ? 'true' : 'false'  // recalcular_105
        );
        
        // Debug de la llamada
        $debug_llamada = [
            'timestamp_llamada_php' => date('Y-m-d H:i:s'),
            'funcion_postgresql' => 'update_conflista_con_recalculo',
            'sql_generado' => $sql,
            'parametros_enviados' => [
                'id_conflista' => $params[0],
                'listap' => $params[1],
                'activa' => $params[2],
                'tipomone' => $params[10],
                'preciof21' => $params[7],
                'preciof105' => $params[8],
                'recalcular_21' => $params[14],
                'recalcular_105' => $params[15]
            ]
        ];
        
        $query = $this->db->query($sql);
        
        if (!$query) {
            throw new Exception('Error ejecutando funciÃ³n PostgreSQL: ' . $this->db->error()['message']);
        }
        
        $result = $query->row();
        
        if (!$result || !isset($result->resultado)) {
            throw new Exception('No se recibiÃ³ respuesta vÃ¡lida de PostgreSQL');
        }
        
        // DEBUG: Ver exactamente quÃ© devuelve PostgreSQL
        $raw_result = $result->resultado;
        error_log("=== DEBUG POSTGRESQL RESPONSE ===");
        error_log("Raw result: " . $raw_result);
        error_log("SQL ejecutado: " . $sql);
        
        // PostgreSQL devuelve JSON, decodificarlo
        $response = json_decode($raw_result, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new Exception('Error decodificando respuesta JSON de PostgreSQL: ' . json_last_error_msg() . '. Raw response: ' . $raw_result);
        }
        
        // Agregar informaciÃ³n de debug de PHP
        if (isset($response['debug'])) {
            $response['debug']['llamada_php'] = $debug_llamada;
            $response['debug']['timestamp_respuesta_php'] = date('Y-m-d H:i:s');
        }
        
        // ===================================================
        // ENVIAR RESPUESTA DIRECTA DE POSTGRESQL
        // ===================================================
        $http_status = $response['error'] ? REST_Controller::HTTP_INTERNAL_SERVER_ERROR : REST_Controller::HTTP_OK;
        $this->response($response, $http_status);
        
    } catch (Exception $e) {
        // ===================================================
        // MANEJO DE ERRORES PHP (ERRORES DE COMUNICACIÃ“N)
        // ===================================================
        $respuesta = [
            'error' => true,
            'mensaje' => 'Error en PHP al comunicarse con PostgreSQL: ' . $e->getMessage(),
            'debug' => [
                'timestamp_error_php' => date('Y-m-d H:i:s'),
                'error_php' => $e->getMessage(),
                'archivo' => $e->getFile(),
                'linea' => $e->getLine(),
                'datos_recibidos' => $data ?? null,
                'nota' => 'Este error ocurriÃ³ en PHP, no en PostgreSQL. La funciÃ³n PostgreSQL puede no haberse ejecutado.'
            ]
        ];
        
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

public function UpdateArticulo_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required field
        if(!isset($data['id_articulo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_articulo'];

        $this->db->trans_start();

        // Update articulos table with all fields
        $this->db->where('id_articulo', $id);
        $this->db->update('artsucursal', array(
            'nomart' => $data['nomart'],
            'marca' => $data['marca'],
            'precon' => $data['precon'],
            'prefi1' => $data['prefi1'],
            'prefi2' => $data['prefi2'],
            'prefi3' => $data['prefi3'],
            'prefi4' => $data['prefi4'],
            'exi1' => $data['exi1'],
            'exi2' => $data['exi2'],
            'exi3' => $data['exi3'],
            'exi4' => $data['exi4'],
            'exi5' => $data['exi5'],
            'stkmin1' => $data['stkmin1'],
            'stkmax1' => $data['stkmax1'],
            'stkprep1' => $data['stkprep1'],
            'stkmin2' => $data['stkmin2'],
            'stkmax2' => $data['stkmax2'],
            'stkprep2' => $data['stkprep2'],
            'stkmin3' => $data['stkmin3'],
            'stkmax3' => $data['stkmax3'],
            'stkprep3' => $data['stkprep3'],
            'stkmin4' => $data['stkmin4'],
            'stkmax4' => $data['stkmax4'],
            'stkprep4' => $data['stkprep4'],
            'stkmin5' => $data['stkmin5'],
            'stkmax5' => $data['stkmax5'],
            'stkprep5' => $data['stkprep5'],
            'cd_articulo' => $data['cd_articulo'],
            'cd_proveedor' => $data['cd_proveedor'],
            'cd_barra' => $data['cd_barra'],
            'idart' => $data['idart'],
            'estado' => $data['estado'],
            'rubro' => $data['rubro'],
            'articulo' => $data['articulo'],
            'cod_iva' => $data['cod_iva'],
            'prebsiva' => $data['prebsiva'],
            'precostosi' => $data['precostosi'],
            'margen' => $data['margen'],
            'descuento' => $data['descuento'],
            'cod_deposito' => $data['cod_deposito'],
            'tipo_moneda' => $data['tipo_moneda']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el artÃ­culo"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows,
                "datos" => $data
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function UpdateCajaconcepto_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validar ID requerido
        if(!isset($data['id_concepto'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Falta el ID del concepto de caja (id_concepto)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }
         // ValidaciÃ³n bÃ¡sica de otros campos (se pueden aÃ±adir mÃ¡s)
        if(!isset($data['descripcion']) || !isset($data['tipo_concepto']) || !isset($data['fija']) || !isset($data['ingreso_egreso']) || !isset($data['id_caja']) || !isset($data['activo_inactivo'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos para actualizar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $id = $data['id_concepto'];

        $this->db->trans_start();

        // Actualizar tabla cajaconceptos
        $this->db->where('id_concepto', $id);
        $this->db->update('caja_conceptos', array(
            'descripcion' => $data['descripcion'],
            'tipo_concepto' => $data['tipo_concepto'],
            'fija' => $data['fija'],
            'ingreso_egreso' => $data['ingreso_egreso'],
            'id_caja' => $data['id_caja'],
            'activo_inactivo' => $data['activo_inactivo']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete();

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al actualizar el concepto de caja"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
             $respuesta = array(
                "error" => false,
                "mensaje" => $rows, // NÃºmero de filas afectadas
                "datos_enviados" => $data // Opcional: devolver los datos enviados para depuraciÃ³n
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}


public function SubirDatosRubro_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_rubro']) || !isset($data['rubro'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_rubro, rubro)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro with all fields
        $this->db->insert('rubros', array(
            'cod_rubro' => $data['cod_rubro'],
            'rubro' => $data['rubro'],
            'cod_depo' => isset($data['cod_depo']) ? $data['cod_depo'] : 0,
            'modidescri' => isset($data['modidescri']) ? $data['modidescri'] : 0,
            'modiprecio' => isset($data['modiprecio']) ? $data['modiprecio'] : 0,
            'mustuni' => isset($data['mustuni']) ? $data['mustuni'] : 0,
            'numerador' => isset($data['numerador']) ? $data['numerador'] : 0,
            'id_rubro_p' => $data['id_rubro_p']
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar el rubro"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function SubirDatosMarca_post()
{
    $data = $this->post();
    if(isset($data) && count($data) > 0) {
        // Validate required fields
        if(!isset($data['cod_marca']) || !isset($data['marca'])) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Faltan campos requeridos (cod_marca, marca)"
            );
            $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
            return;
        }

        $this->db->trans_start(); // Start transaction

        // Insert new rubro with all fields
        $this->db->insert('marcas', array(
            'cod_marca' => $data['cod_marca'],
            'marca' => $data['marca'],
        ));

        $rows = $this->db->affected_rows();
        $this->db->trans_complete(); // Complete transaction

        if ($this->db->trans_status() === FALSE) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "Error al insertar la marca"
            );
            $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
        } else {
            $respuesta = array(
                "error" => false,
                "mensaje" => $rows
            );
            $this->response($respuesta);
        }
    } else {
        $respuesta = array(
            "error" => true,
            "mensaje" => "No se recibieron datos en el POST"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
    }
}

public function historialventasxsucxcli_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar lÃ­mites de paginaciÃ³n
    $page = max(1, $page);
    $limit = max(10, min(1000, $limit));
    $offset = ($page - 1) * $limit;

    // Construir nombre de tabla
    $tabla = "psucursal" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tabla)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tabla no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Seleccionar campos especÃ­ficos incluyendo descripciÃ³n de tarjeta
        $this->db->select('p.tipodoc, p.puntoventa, p.idart, p.nomart, p.fecha, p.hora, p.cantidad, p.precio, p.cod_tar, p.numerocomprobante, p.id_num, p.idcli, CASE WHEN t.tarjeta IS NOT NULL THEN t.tarjeta ELSE \'Sin definir\' END as descripcion_tarjeta');
        $this->db->from($tabla . ' p');
        $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
        
        // Filtrar por cliente
        $this->db->where('p.idcli', $idcli);

        // Aplicar bÃºsqueda global si existe
        if ($search && trim($search) !== '') {
            $searchTerm = $this->db->escape_like_str($search);
            $this->db->group_start();
            $this->db->like('p.nomart', $searchTerm);
            $this->db->or_like('p.tipodoc', $searchTerm);
            $this->db->or_like('p.numerocomprobante', $searchTerm);
            $this->db->or_like('t.tarjeta', $searchTerm);
            $this->db->group_end();
        }

        // Aplicar filtros de columna si existen
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray)) {
                foreach ($filtersArray as $field => $filter) {
                    if (isset($filter['value']) && $filter['value'] !== '') {
                        $value = $filter['value'];
                        $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                        
                        // Mapear campos al alias correcto
                        $dbField = $field;
                        if ($field === 'descripcion_tarjeta') {
                            $dbField = 't.tarjeta';
                        } elseif (in_array($field, ['tipodoc', 'puntoventa', 'idart', 'nomart', 'fecha', 'hora', 'cantidad', 'precio', 'cod_tar', 'numerocomprobante', 'id_num', 'idcli'])) {
                            $dbField = 'p.' . $field;
                        }
                        
                        switch ($matchMode) {
                            case 'startsWith':
                                $this->db->like($dbField, $value, 'after');
                                break;
                            case 'contains':
                                $this->db->like($dbField, $value);
                                break;
                            case 'equals':
                                $this->db->where($dbField, $value);
                                break;
                            case 'gt':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'gte':
                                $this->db->where($dbField . ' >=', $value);
                                break;
                            case 'lt':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            case 'lte':
                                $this->db->where($dbField . ' <=', $value);
                                break;
                            case 'dateIs':
                                $this->db->where($dbField, $value);
                                break;
                            case 'dateAfter':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'dateBefore':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            default:
                                $this->db->like($dbField, $value);
                                break;
                        }
                    }
                }
            }
        }

        // Contar total de registros antes de aplicar lÃ­mites
        $totalQuery = clone $this->db;
        $totalRegistros = $totalQuery->count_all_results('', false);

        // Aplicar ordenamiento
        if ($sortField && trim($sortField) !== '') {
            $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
            
            // Mapear campo de ordenamiento al alias correcto
            $dbSortField = $sortField;
            if ($sortField === 'descripcion_tarjeta') {
                $dbSortField = 't.tarjeta';
            } elseif (in_array($sortField, ['tipodoc', 'puntoventa', 'idart', 'nomart', 'fecha', 'hora', 'cantidad', 'precio', 'cod_tar', 'numerocomprobante', 'id_num', 'idcli'])) {
                $dbSortField = 'p.' . $sortField;
            }
            
            $this->db->order_by($dbSortField, $sortDirection);
        } else {
            // Ordenamiento por defecto: fecha y hora mÃ¡s recientes primero
            $this->db->order_by('p.fecha', 'DESC');
            $this->db->order_by('p.hora', 'DESC');
        }

        // Aplicar paginaciÃ³n
        $this->db->limit($limit, $offset);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->result_array();

        // Calcular metadatos de paginaciÃ³n
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros)
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene los datos completos del recibo basÃ¡ndose en el id_num de la venta
 * Relaciona las tablas psucursal y recibos para mostrar informaciÃ³n completa
 */
public function obtenerDatosRecibo_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $idNum = $this->get('id_num');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$idNum) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e id_num"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaPsucursal = "psucursal" . $sucursal;
    $tablaRecibos = "recibos" . $sucursal;

    // Verificar si las tablas existen
    if (!$this->db->table_exists($tablaPsucursal) || !$this->db->table_exists($tablaRecibos)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Las tablas requeridas no existen para la sucursal $sucursal"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Consulta para obtener datos combinados de psucursal y recibos
        $this->db->select('
            p.id_num,
            p.numerocomprobante,
            p.puntoventa,
            p.fecha as fecha_venta,
            p.hora,
            p.nomart,
            p.precio,
            p.cantidad,
            p.tipodoc,
            p.idcli,
            p.idven,
            p.cod_tar,
            p.estado,
            r.recibo,
            r.c_tipo,
            r.c_cuota,
            r.fecha as fecha_recibo,
            r.importe,
            r.usuario,
            r.observacion,
            r.cod_lugar,
            r.sesion,
            r.c_tipf,
            r.recibo_saldo,
            r.cod_sucursal,
            r.fec_proceso,
            r.bonifica,
            r.bonifica_tipo,
            r.interes,
            r.interes_tipo,
            r.recibo_asoc,
            CASE WHEN t.tarjeta IS NOT NULL THEN t.tarjeta ELSE \'Sin definir\' END as descripcion_tarjeta
        ');
        
        $this->db->from($tablaPsucursal . ' p');
        $this->db->join($tablaRecibos . ' r', 'p.id_num = r.id_fac', 'left');
        $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
        $this->db->where('p.id_num', $idNum);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->row_array();

        if (!$datos) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron datos para el id_num: $idNum"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => "Datos del recibo obtenidos exitosamente",
            "data" => $datos
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos del recibo: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene historial de ventas de la tabla factcabx (historialventas2)
 * con paginaciÃ³n, filtros, bÃºsqueda y ordenamiento
 */
public function historialventas2xcli_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar lÃ­mites de paginaciÃ³n
    $page = max(1, $page);
    $limit = max(10, min(1000, $limit));
    $offset = ($page - 1) * $limit;

    // Construir nombre de tabla
    $tabla = "factcab" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tabla)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tabla no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Seleccionar campos especÃ­ficos de factcabx
        $this->db->select('
            f.cod_sucursal as sucursal,
            f.tipo,
            f.puntoventa,
            f.letra,
            f.numero_int,
            f.numero_fac,
            f.emitido,
            f.vencimiento,
            f.exento,
            f.basico,
            f.iva1,
            f.iva2,
            f.iva3,
            (f.exento + f.basico + f.iva1 + f.iva2 + f.iva3) as importe,
            COALESCE(MAX(r.bonifica), f.bonifica) as bonifica,
            COALESCE(MAX(r.bonifica_tipo), f.bonifica_tipo) as bonifica_tipo,
            COALESCE(MAX(r.interes), f.interes) as interes,
            COALESCE(MAX(r.interes_tipo), f.interes_tipo) as interes_tipo,
            f.saldo,
            f.usuario,
            f.id_num as id,
            f.cliente
        ');
        $this->db->from($tabla . ' f');
        // CORREGIDO: JOIN mejorado para evitar mezcla de datos entre clientes
        $this->db->join($tabla . ' rc', 'f.numero_fac = rc.numero_fac AND rc.tipo = \'RC\' AND f.cliente = rc.cliente', 'left');
        $this->db->join('recibos' . substr($tabla, -1) . ' r', 'rc.id_num = r.id_fac', 'left');
        $this->db->group_by('f.cod_sucursal, f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, f.saldo, f.usuario, f.id_num, f.cliente, f.bonifica, f.bonifica_tipo, f.interes, f.interes_tipo');
        
        // Filtrar por cliente
        $this->db->where('f.cliente', $idcli);
        
        // FILTRO IMPORTANTE: Excluir recibos RC de historial de ventas
        $this->aplicarFiltroSinRC('f');

        // Aplicar filtro de rango de fechas si se proporciona
        if ($fecha_desde && $fecha_hasta) {
            // Validar formato de fechas (YYYY-MM-DD)
            if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
                $this->db->where('f.emitido >=', $fecha_desde);
                $this->db->where('f.emitido <=', $fecha_hasta);
            }
        }

        // Aplicar bÃºsqueda global si existe
        if ($search && trim($search) !== '') {
            $searchTerm = $this->db->escape_like_str($search);
            $this->db->group_start();
            $this->db->like('f.tipo', $searchTerm);
            $this->db->or_like('f.letra', $searchTerm);
            $this->db->or_like('f.numero_fac', $searchTerm);
            $this->db->or_like('f.usuario', $searchTerm);
            $this->db->group_end();
        }

        // Aplicar filtros de columna si existen
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray)) {
                foreach ($filtersArray as $field => $filter) {
                    if (isset($filter['value']) && $filter['value'] !== '') {
                        $value = $filter['value'];
                        $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                        
                        // Mapear campos al alias correcto
                        $dbField = 'f.' . $field;
                        
                        switch ($matchMode) {
                            case 'startsWith':
                                $this->db->like($dbField, $value, 'after');
                                break;
                            case 'contains':
                                $this->db->like($dbField, $value);
                                break;
                            case 'equals':
                                $this->db->where($dbField, $value);
                                break;
                            case 'gt':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'gte':
                                $this->db->where($dbField . ' >=', $value);
                                break;
                            case 'lt':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            case 'lte':
                                $this->db->where($dbField . ' <=', $value);
                                break;
                            case 'dateIs':
                                $this->db->where($dbField, $value);
                                break;
                            case 'dateAfter':
                                $this->db->where($dbField . ' >', $value);
                                break;
                            case 'dateBefore':
                                $this->db->where($dbField . ' <', $value);
                                break;
                            default:
                                $this->db->like($dbField, $value);
                                break;
                        }
                    }
                }
            }
        }

        // Contar total de registros antes de aplicar lÃ­mites
        $totalQuery = clone $this->db;
        $totalRegistros = $totalQuery->count_all_results('', false);

        // Aplicar ordenamiento
        if ($sortField && trim($sortField) !== '') {
            $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
            $dbSortField = 'f.' . $sortField;
            $this->db->order_by($dbSortField, $sortDirection);
        } else {
            // Ordenamiento por defecto: fecha de emisiÃ³n mÃ¡s reciente primero
            $this->db->order_by('f.emitido', 'DESC');
        }

        // Aplicar paginaciÃ³n
        $this->db->limit($limit, $offset);

        // Ejecutar consulta
        $query = $this->db->get();
        $datos = $query->result_array();

        // Calcular metadatos de paginaciÃ³n
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros)
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas2: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene historial de ventas GLOBAL de todas las sucursales (factcabx)
 * Solo para usuarios con rol ADMIN o SUPER
 * con paginaciÃ³n, filtros, bÃºsqueda y ordenamiento
 */
public function historialventas2global_get()
{
    // Obtener parÃ¡metros de la URL
    $idcli = $this->get('idcli');
    $page = $this->get('page') ? intval($this->get('page')) : 1;
    $limit = $this->get('limit') ? intval($this->get('limit')) : 50;
    $sortField = $this->get('sortField');
    $sortOrder = $this->get('sortOrder') ? intval($this->get('sortOrder')) : 1;
    $filters = $this->get('filters');
    $search = $this->get('search');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');
    $user_role = $this->get('user_role'); // Se debe enviar desde el frontend

    // Validaciones bÃ¡sicas
    if (!$idcli) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Falta parÃ¡metro requerido: idcli"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Validar permisos - Solo ADMIN y SUPER pueden acceder
    if (!$user_role || ($user_role !== 'admin' && $user_role !== 'super')) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Acceso denegado: Se requiere rol ADMIN o SUPER para vista global"
        );
        $this->response($respuesta, REST_Controller::HTTP_FORBIDDEN);
        return;
    }

    // Validar lÃ­mites de paginaciÃ³n
    $page = max(1, $page);
    $limit = max(10, min(500, $limit)); // LÃ­mite mÃ¡s conservador para vista global
    $offset = ($page - 1) * $limit;

    try {
        // Obtener lista de sucursales disponibles
        $sucursales = $this->obtenerSucursalesDisponibles();
        
        // Log para debug
        error_log("Sucursales disponibles encontradas: " . print_r($sucursales, true));
        
        if (empty($sucursales)) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron sucursales disponibles"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Construir consulta UNION manualmente para evitar problemas con CodeIgniter
        $unionQueries = array();
        foreach ($sucursales as $sucursal) {
            $tabla = "factcab" . $sucursal;
            
            // Log para debug
            error_log("Verificando tabla: " . $tabla);
            
            // Verificar si la tabla existe
            if ($this->db->table_exists($tabla)) {
                error_log("Tabla {$tabla} existe - construyendo subconsulta");
                $subQuery = $this->construirSubConsultaGlobalManual($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters);
                if ($subQuery) {
                    $unionQueries[] = $subQuery;
                    error_log("Subconsulta agregada para {$tabla}: " . substr($subQuery, 0, 100) . "...");
                }
            } else {
                error_log("Tabla {$tabla} NO existe");
            }
        }

        if (empty($unionQueries)) {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron tablas de facturas disponibles"
            );
            $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
            return;
        }

        // Construir consulta final con UNION
        $unionQuery = implode(' UNION ALL ', $unionQueries);
        
        // Log de la consulta final
        error_log("NÃºmero de subconsultas UNION: " . count($unionQueries));
        error_log("Consulta UNION completa: " . $unionQuery);
        
        // Aplicar filtro de sucursal DESPUÃ‰S del UNION si existe
        $whereClause = '';
        if ($filters && trim($filters) !== '') {
            $filtersArray = json_decode($filters, true);
            if ($filtersArray && is_array($filtersArray) && isset($filtersArray['sucursal'])) {
                $sucursalFilter = $filtersArray['sucursal'];
                if (isset($sucursalFilter['value']) && $sucursalFilter['value'] !== '') {
                    $value = $sucursalFilter['value'];
                    $matchMode = isset($sucursalFilter['matchMode']) ? $sucursalFilter['matchMode'] : 'contains';
                    $value_escaped = $this->db->escape($value);
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape($value . '%');
                            break;
                        case 'contains':
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                        case 'equals':
                            $whereClause = " WHERE sucursal = {$value_escaped}";
                            break;
                        default:
                            $whereClause = " WHERE sucursal LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                    }
                    
                    error_log("Filtro de sucursal aplicado despuÃ©s del UNION: " . $whereClause);
                }
            }
        }
        
        // Agregar ordenamiento y paginaciÃ³n
        $sortDirection = ($sortOrder === -1) ? 'DESC' : 'ASC';
        $orderField = $sortField ? $sortField : 'emitido';
        
        $finalQuery = "SELECT * FROM ({$unionQuery}) AS combined_results{$whereClause} ORDER BY {$orderField} {$sortDirection} LIMIT {$limit} OFFSET {$offset}";
        
        // Log de la consulta final
        error_log("Consulta final con paginaciÃ³n: " . $finalQuery);
        
        // Contar total de registros
        $countQuery = "SELECT COUNT(*) as total FROM ({$unionQuery}) AS combined_results{$whereClause}";
        $countResult = $this->db->query($countQuery)->row_array();
        $totalRegistros = $countResult['total'];

        // Log del conteo
        error_log("Total de registros encontrados: " . $totalRegistros);

        // Ejecutar consulta principal
        $query = $this->db->query($finalQuery);
        $datos = $query->result_array();
        
        // Log de resultados
        error_log("Registros devueltos: " . count($datos));

        // Calcular metadatos de paginaciÃ³n
        $totalPaginas = ceil($totalRegistros / $limit);

        // Formatear respuesta
        $respuesta = array(
            "error" => false,
            "mensaje" => array(
                "data" => $datos,
                "total" => $totalRegistros,
                "total_pages" => $totalPaginas,
                "current_page" => $page,
                "per_page" => $limit,
                "from" => $offset + 1,
                "to" => min($offset + $limit, $totalRegistros),
                "sucursales_consultadas" => $sucursales,
                "vista" => "global"
            )
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al consultar historial de ventas global: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Construye una subconsulta para una sucursal especÃ­fica
 */
private function construirSubConsultaGlobal($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters)
{
    $this->db->select('
        \'' . $sucursal . '\' as sucursal,
        tipo,
        puntoventa,
        letra,
        numero_fac,
        emitido,
        vencimiento,
        exento,
        basico,
        iva1,
        iva2,
        iva3,
        (exento + basico + iva1 + iva2 + iva3) as importe,
        saldo,
        usuario,
        id_num as id,
        cliente
    ');
    $this->db->from($tabla);
    $this->db->where('cliente', $idcli);

    // Aplicar filtro de rango de fechas si se proporciona
    if ($fecha_desde && $fecha_hasta) {
        if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
            $this->db->where('emitido >=', $fecha_desde);
            $this->db->where('emitido <=', $fecha_hasta);
        }
    }

    // Aplicar bÃºsqueda global si existe
    if ($search && trim($search) !== '') {
        $searchTerm = $this->db->escape_like_str($search);
        $this->db->group_start();
        $this->db->like('tipo', $searchTerm);
        $this->db->or_like('letra', $searchTerm);
        $this->db->or_like('numero_fac', $searchTerm);
        $this->db->or_like('usuario', $searchTerm);
        $this->db->group_end();
    }

    // Aplicar filtros de columna si existen
    if ($filters && trim($filters) !== '') {
        $filtersArray = json_decode($filters, true);
        if ($filtersArray && is_array($filtersArray)) {
            foreach ($filtersArray as $field => $filter) {
                if (isset($filter['value']) && $filter['value'] !== '') {
                    $value = $filter['value'];
                    $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $this->db->like($field, $value, 'after');
                            break;
                        case 'contains':
                            $this->db->like($field, $value);
                            break;
                        case 'equals':
                            $this->db->where($field, $value);
                            break;
                        case 'gt':
                            $this->db->where($field . ' >', $value);
                            break;
                        case 'gte':
                            $this->db->where($field . ' >=', $value);
                            break;
                        case 'lt':
                            $this->db->where($field . ' <', $value);
                            break;
                        case 'lte':
                            $this->db->where($field . ' <=', $value);
                            break;
                        case 'dateIs':
                            $this->db->where($field, $value);
                            break;
                        case 'dateAfter':
                            $this->db->where($field . ' >', $value);
                            break;
                        case 'dateBefore':
                            $this->db->where($field . ' <', $value);
                            break;
                        default:
                            $this->db->like($field, $value);
                            break;
                    }
                }
            }
        }
    }

    return $this->db->get_compiled_select();
}

/**
 * Construye una subconsulta manual para una sucursal especÃ­fica (evita problemas con CodeIgniter)
 */
private function construirSubConsultaGlobalManual($tabla, $sucursal, $idcli, $fecha_desde, $fecha_hasta, $search, $filters)
{
    // Escapar valores
    $idcli_escaped = $this->db->escape($idcli);
    $sucursal_escaped = $this->db->escape($sucursal);
    $tabla_escaped = $this->db->escape_identifiers($tabla);
    
    // Log para debug
    error_log("Construyendo subconsulta para tabla: {$tabla}, sucursal: {$sucursal}, cliente: {$idcli}");
    
    // Construir SELECT base - CORREGIDO: Agregado filtro por cliente en el JOIN
    $select = "SELECT {$sucursal_escaped} as sucursal, f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, (f.exento + f.basico + f.iva1 + f.iva2 + f.iva3) as importe, COALESCE(MAX(r.bonifica), f.bonifica) as bonifica, COALESCE(MAX(r.bonifica_tipo), f.bonifica_tipo) as bonifica_tipo, COALESCE(MAX(r.interes), f.interes) as interes, COALESCE(MAX(r.interes_tipo), f.interes_tipo) as interes_tipo, f.saldo, f.usuario, f.id_num as id, f.cliente FROM {$tabla_escaped} f LEFT JOIN {$tabla_escaped} rc ON f.numero_fac = rc.numero_fac AND rc.tipo = 'RC' AND f.cliente = rc.cliente LEFT JOIN recibos" . substr($tabla, -1) . " r ON rc.id_num = r.id_fac GROUP BY f.tipo, f.puntoventa, f.letra, f.numero_int, f.numero_fac, f.emitido, f.vencimiento, f.exento, f.basico, f.iva1, f.iva2, f.iva3, f.saldo, f.usuario, f.id_num, f.cliente, f.bonifica, f.bonifica_tipo, f.interes, f.interes_tipo";
    
    // Construir WHERE
    $where = "WHERE f.cliente = {$idcli_escaped} AND f.tipo != 'RC'";
    
    // Log de la consulta base
    error_log("Consulta base para {$tabla}: {$select} {$where}");
    
    // Aplicar filtro de rango de fechas si se proporciona
    if ($fecha_desde && $fecha_hasta) {
        if ($this->validarFormatoFecha($fecha_desde) && $this->validarFormatoFecha($fecha_hasta)) {
            $fecha_desde_escaped = $this->db->escape($fecha_desde);
            $fecha_hasta_escaped = $this->db->escape($fecha_hasta);
            $where .= " AND f.emitido >= {$fecha_desde_escaped} AND f.emitido <= {$fecha_hasta_escaped}";
        }
    }
    
    // Aplicar bÃºsqueda global si existe
    if ($search && trim($search) !== '') {
        $search_escaped = $this->db->escape('%' . $search . '%');
        $where .= " AND (f.tipo LIKE {$search_escaped} OR f.letra LIKE {$search_escaped} OR f.numero_fac::text LIKE {$search_escaped} OR f.usuario LIKE {$search_escaped})";
    }
    
    // Aplicar filtros de columna si existen (EXCLUYENDO el filtro de sucursal)
    if ($filters && trim($filters) !== '') {
        $filtersArray = json_decode($filters, true);
        if ($filtersArray && is_array($filtersArray)) {
            foreach ($filtersArray as $field => $filter) {
                // EXCLUIR el filtro de sucursal ya que es una columna virtual
                if ($field === 'sucursal') {
                    error_log("Filtro de sucursal excluido de subconsulta - se aplicarÃ¡ despuÃ©s del UNION");
                    continue;
                }
                
                if (isset($filter['value']) && $filter['value'] !== '') {
                    $value = $filter['value'];
                    $matchMode = isset($filter['matchMode']) ? $filter['matchMode'] : 'contains';
                    $value_escaped = $this->db->escape($value);
                    
                    switch ($matchMode) {
                        case 'startsWith':
                            $where .= " AND f.{$field} LIKE " . $this->db->escape($value . '%');
                            break;
                        case 'contains':
                            $where .= " AND f.{$field} LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                        case 'equals':
                            $where .= " AND f.{$field} = {$value_escaped}";
                            break;
                        case 'gt':
                            $where .= " AND f.{$field} > {$value_escaped}";
                            break;
                        case 'gte':
                            $where .= " AND f.{$field} >= {$value_escaped}";
                            break;
                        case 'lt':
                            $where .= " AND f.{$field} < {$value_escaped}";
                            break;
                        case 'lte':
                            $where .= " AND f.{$field} <= {$value_escaped}";
                            break;
                        case 'dateIs':
                            $where .= " AND f.{$field} = {$value_escaped}";
                            break;
                        case 'dateAfter':
                            $where .= " AND f.{$field} > {$value_escaped}";
                            break;
                        case 'dateBefore':
                            $where .= " AND f.{$field} < {$value_escaped}";
                            break;
                        default:
                            $where .= " AND f.{$field} LIKE " . $this->db->escape('%' . $value . '%');
                            break;
                    }
                }
            }
        }
    }
    
    return $select . ' ' . $where;
}

/**
 * Obtiene lista de sucursales disponibles
 */
private function obtenerSucursalesDisponibles()
{
    // Buscar tablas factcab* en la base de datos
    $tables = $this->db->list_tables();
    $sucursales = array();
    
    error_log("Todas las tablas en la base de datos: " . print_r($tables, true));
    
    foreach ($tables as $table) {
        if (strpos($table, 'factcab') === 0 && strlen($table) > 7) {
            $sucursal = substr($table, 7); // Extraer nÃºmero de sucursal
            if (is_numeric($sucursal)) {
                $sucursales[] = $sucursal;
                error_log("Sucursal detectada: " . $sucursal . " de tabla: " . $table);
            }
        }
    }
    
    // TambiÃ©n intentar con un rango fijo para asegurar cobertura
    for ($i = 1; $i <= 10; $i++) {
        $tabla = "factcab" . $i;
        if ($this->db->table_exists($tabla) && !in_array($i, $sucursales)) {
            $sucursales[] = $i;
            error_log("Sucursal adicional detectada: " . $i);
        }
    }
    
    sort($sucursales); // Ordenar sucursales
    error_log("Sucursales finales: " . print_r($sucursales, true));
    return $sucursales;
}

/**
 * Endpoint de prueba para verificar sucursales disponibles
 */
public function test_sucursales_disponibles_get()
{
    $sucursales = $this->obtenerSucursalesDisponibles();
    
    $respuesta = array(
        "error" => false,
        "mensaje" => array(
            "sucursales_detectadas" => $sucursales,
            "total_sucursales" => count($sucursales)
        )
    );
    
    $this->response($respuesta);
}

/**
 * Endpoint de prueba para verificar datos por sucursal
 */
public function test_datos_por_sucursal_get()
{
    $idcli = $this->get('idcli');
    $fecha_desde = $this->get('fecha_desde');
    $fecha_hasta = $this->get('fecha_hasta');
    
    if (!$idcli || !$fecha_desde || !$fecha_hasta) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros: idcli, fecha_desde, fecha_hasta"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }
    
    $sucursales = $this->obtenerSucursalesDisponibles();
    $resultados = array();
    
    foreach ($sucursales as $sucursal) {
        $tabla = "factcab" . $sucursal;
        
        if ($this->db->table_exists($tabla)) {
            $query = "SELECT COUNT(*) as total FROM {$tabla} WHERE cliente = {$this->db->escape($idcli)} AND emitido >= {$this->db->escape($fecha_desde)} AND emitido <= {$this->db->escape($fecha_hasta)}";
            $result = $this->db->query($query)->row_array();
            
            $resultados[] = array(
                "sucursal" => $sucursal,
                "tabla" => $tabla,
                "registros" => $result['total']
            );
        }
    }
    
    $respuesta = array(
        "error" => false,
        "mensaje" => array(
            "cliente" => $idcli,
            "fecha_desde" => $fecha_desde,
            "fecha_hasta" => $fecha_hasta,
            "resultados_por_sucursal" => $resultados
        )
    );
    
    $this->response($respuesta);
}

/**
 * Obtiene los datos completos del recibo basÃ¡ndose en el id de factcabx
 * para historialventas2
 */
public function obtenerDatosRecibo2_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $id = $this->get('id');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$id) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e id"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaFactcab = "factcab" . $sucursal;

    // Verificar si la tabla existe
    if (!$this->db->table_exists($tablaFactcab)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "La tabla $tablaFactcab no existe"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Consultar datos completos de factcabx
        $this->db->select('*');
        $this->db->from($tablaFactcab);
        $this->db->where('id', $id);
        $query = $this->db->get();
        
        if ($query->num_rows() > 0) {
            $datos = $query->row_array();
            
            // Calcular importe total
            $excento = floatval($datos['excento']) ?: 0;
            $basico = floatval($datos['basico']) ?: 0;
            $iva1 = floatval($datos['iva1']) ?: 0;
            $iva2 = floatval($datos['iva2']) ?: 0;
            $iva3 = floatval($datos['iva3']) ?: 0;
            $datos['importe_total'] = $excento + $basico + $iva1 + $iva2 + $iva3;
            
            $respuesta = array(
                "error" => false,
                "mensaje" => "Datos del recibo obtenidos exitosamente",
                "data" => $datos
            );
        } else {
            $respuesta = array(
                "error" => true,
                "mensaje" => "No se encontraron datos para el recibo con ID: $id"
            );
        }

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos del recibo2: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Obtiene datos expandidos (recibos y psucursal) para una factura especÃ­fica
 * segÃºn las relaciones definidas en el diagrama DBML
 */
public function obtenerDatosExpandidos_get()
{
    // Obtener parÃ¡metros de la URL
    $sucursal = $this->get('sucursal');
    $id_factura = $this->get('id_factura');

    // Validaciones bÃ¡sicas
    if (!$sucursal || !$id_factura) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Faltan parÃ¡metros requeridos: sucursal e id_factura"
        );
        $this->response($respuesta, REST_Controller::HTTP_BAD_REQUEST);
        return;
    }

    // Construir nombres de tablas
    $tablaFactcab = "factcab" . $sucursal;
    $tablaRecibos = "recibos" . $sucursal;
    $tablaPsucursal = "psucursal" . $sucursal;

    // Verificar si las tablas existen
    if (!$this->db->table_exists($tablaFactcab) || !$this->db->table_exists($tablaRecibos) || !$this->db->table_exists($tablaPsucursal)) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Una o mÃ¡s tablas no existen para la sucursal: $sucursal"
        );
        $this->response($respuesta, REST_Controller::HTTP_NOT_FOUND);
        return;
    }

    try {
        // Obtener datos de recibos asociados a la factura
        // CORREGIDO: Usar cliente en lugar de numero_fac para evitar mezcla de datos
        
        // Primero obtener la factura para conseguir cliente y numero_fac
        $this->db->select('numero_fac, cliente');
        $this->db->from($tablaFactcab);
        $this->db->where('id_num', $id_factura);
        $queryFactura = $this->db->get();
        $factura = $queryFactura->row_array();
        
        if (!$factura) {
            throw new Exception("Factura no encontrada con id_num: $id_factura");
        }
        
        $numero_fac = $factura['numero_fac'];
        $cliente_id = $factura['cliente'];
        
        // Consulta UNION CORREGIDA para obtener recibos directos + recibos RC relacionados
        // CAMBIO CRÃTICO: Agregado filtro por cliente para evitar mezcla de datos entre clientes
        $query = "
            (
                SELECT 
                    r.recibo, r.c_tipo, r.c_numero, r.c_cuota, r.fecha, r.importe, 
                    r.usuario, r.observacion, r.cod_lugar, r.sesion, r.c_tipf, 
                    r.c_puntoventa, r.recibo_asoc, r.recibo_saldo, r.cod_sucursal,
                    r.fec_proceso, r.bonifica, r.bonifica_tipo, r.interes, r.interes_tipo, 
                    r.id_fac, 'DIRECTO' as origen
                FROM {$tablaRecibos} r
                WHERE r.id_fac = {$id_factura}
            )
            UNION ALL
            (
                SELECT 
                    r.recibo, r.c_tipo, r.c_numero, r.c_cuota, r.fecha, r.importe, 
                    r.usuario, r.observacion, r.cod_lugar, r.sesion, r.c_tipf, 
                    r.c_puntoventa, r.recibo_asoc, r.recibo_saldo, r.cod_sucursal,
                    r.fec_proceso, r.bonifica, r.bonifica_tipo, r.interes, r.interes_tipo, 
                    r.id_fac, 'RC' as origen
                FROM {$tablaRecibos} r
                INNER JOIN {$tablaFactcab} f ON r.id_fac = f.id_num
                WHERE r.recibo_asoc = {$id_factura} AND f.tipo = 'RC'
            )
            ORDER BY fecha DESC
        ";
        
        $queryRecibos = $this->db->query($query);
        $recibos = $queryRecibos->result_array();

        // NUEVO: Obtener historial de pagos de la factura (solo pagos reales RC)
        // CORREGIDO: Agregado filtro por cliente para evitar mezcla de datos
        $this->db->select('
            r.recibo,
            r.c_tipo,
            r.c_numero,
            r.fecha,
            r.importe,
            r.usuario,
            r.c_puntoventa,
            f.tipo as tipo_documento
        ');
        $this->db->from($tablaRecibos . ' r');
        $this->db->join($tablaFactcab . ' f', 'r.id_fac = f.id_num', 'left');
        $this->db->where('r.recibo_asoc', $id_factura);
        $this->db->where('f.tipo', 'RC');  // Filtrar solo pagos reales (Recibos de Cobro)
        $this->db->where('f.cliente', $cliente_id);  // CRÃTICO: Filtrar por cliente del documento original
        $this->db->order_by('r.fecha', 'ASC');
        $queryPagos = $this->db->get();
        $pagos = $queryPagos->result_array();

        // Calcular total pagado
        $total_pagado = 0;
        foreach ($pagos as $pago) {
            $total_pagado += (float)$pago['importe'];
        }

        // ELIMINADO: Consulta duplicada ya no necesaria - el cliente_id se obtiene al principio

        // Para cada recibo, obtener sus productos especÃ­ficos
        foreach ($recibos as $index => $recibo) {
            // Debug: log de los valores que estamos buscando
            error_log("Buscando productos para recibo: " . $recibo['recibo'] . 
                     " - recibo_asoc: " . $recibo['recibo_asoc'] . 
                     " - cliente_id: " . $cliente_id);
            $this->db->select('
                p.idart,
                p.cantidad,
                p.precio,
                p.idcli,
                p.idven,
                p.fecha,
                p.hora,
                p.tipoprecio,
                p.cod_tar,
                t.tarjeta,
                p.titulartar,
                p.numerotar,
                p.cod_mov,
                p.suc_destino,
                p.nomart,
                p.nautotar,
                p.dni_tar,
                p.banco,
                p.ncuenta,
                p.ncheque,
                p.nombre,
                p.plaza,
                p.importeimputar,
                p.importecheque,
                p.fechacheque,
                p.emailop,
                p.tipodoc,
                p.puntoventa,
                p.numerocomprobante,
                p.estado,
                p.id_num
            ');
            $this->db->from($tablaPsucursal . ' p');
            $this->db->join('tarjcredito t', 'p.cod_tar = t.cod_tarj', 'left');
            $this->db->where('p.id_num', $recibo['recibo_asoc']);
            if ($cliente_id) {
                $this->db->where('p.idcli', trim($cliente_id));
            }
            $this->db->order_by('p.fecha', 'DESC');
            $this->db->order_by('p.hora', 'DESC');
            
            $queryProductos = $this->db->get();
            $productos = $queryProductos->result_array();
            
            // Debug: log del resultado
            error_log("Productos encontrados para recibo " . $recibo['recibo'] . ": " . count($productos));
            if (count($productos) > 0) {
                error_log("Primer producto: " . json_encode($productos[0]));
            }
            
            // Agregar productos al recibo
            $recibos[$index]['productos'] = $productos;
        }

        // Preparar respuesta con datos expandidos incluyendo historial de pagos
        $datosExpandidos = array(
            'recibos' => $recibos,
            'historialPagos' => $pagos,
            'totalPagado' => $total_pagado
        );

        $respuesta = array(
            "error" => false,
            "mensaje" => "Datos expandidos obtenidos exitosamente",
            "data" => $datosExpandidos
        );

        $this->response($respuesta);

    } catch (Exception $e) {
        $respuesta = array(
            "error" => true,
            "mensaje" => "Error al obtener datos expandidos: " . $e->getMessage()
        );
        $this->response($respuesta, REST_Controller::HTTP_INTERNAL_SERVER_ERROR);
    }
}

/**
 * Genera una descripciÃ³n automÃ¡tica para movimientos de caja tipo 'A'
 * basada en el patrÃ³n: tipo_comprobante + numero_comprobante + Rec. NÂº + numero_recibo
 */
private function generarDescripcionAutomatica($data) {
    $tipo_comprobante = isset($data['tipo_comprobante']) ? $data['tipo_comprobante'] : '';
    $numero_comprobante = isset($data['numero_comprobante']) ? $data['numero_comprobante'] : '';
    $num_operacion = isset($data['num_operacion']) ? $data['num_operacion'] : '';
    
    // Si no hay datos suficientes, usar descripciÃ³n por defecto
    if (empty($tipo_comprobante) && empty($numero_comprobante)) {
        return 'Movimiento automÃ¡tico';
    }
    
    // Formato: "FC     21 Rec. NÂº 100000"
    $descripcion = '';
    
    if (!empty($tipo_comprobante)) {
        $descripcion .= $tipo_comprobante;
    }
    
    if (!empty($numero_comprobante)) {
        // Agregar espacios para formato consistente (ajustar segÃºn necesidad)
        $descripcion .= str_repeat(' ', max(1, 6 - strlen($tipo_comprobante))) . $numero_comprobante;
    }
    
    if (!empty($num_operacion)) {
        $descripcion .= ' Rec. NÂº ' . $num_operacion;
    }
    
    // Asegurar que la descripciÃ³n no exceda 80 caracteres (lÃ­mite del campo)
    return substr($descripcion, 0, 80);
}

/**
 * Valida que una fecha tenga el formato YYYY-MM-DD
 */
private function validarFormatoFecha($fecha) {
    // Verificar formato bÃ¡sico con regex
    if (!preg_match('/^\d{4}-\d{2}-\d{2}$/', $fecha)) {
        return false;
    }
    
    // Verificar que sea una fecha vÃ¡lida
    $parts = explode('-', $fecha);
    return checkdate((int)$parts[1], (int)$parts[2], (int)$parts[0]);
}

// ==================== MÃ‰TODO PARA CAMBIO MASIVO DE PRECIOS ====================

public function PriceUpdate_post()
{
    try {
        $data = $this->post();
        
        // Validar datos requeridos
        if (!isset($data['tipo_modificacion']) || !isset($data['porcentaje'])) {
            $this->response([
                'error' => true,
                'mensaje' => 'Faltan parÃ¡metros requeridos: tipo_modificacion, porcentaje'
            ], 400);
            return;
        }
        
        // Preparar parÃ¡metros
        $marca = isset($data['marca']) ? $data['marca'] : null;
        $cd_proveedor = isset($data['cd_proveedor']) ? intval($data['cd_proveedor']) : null;
        $rubro = isset($data['rubro']) ? $data['rubro'] : null;
        $cod_iva = isset($data['cod_iva']) ? intval($data['cod_iva']) : null;
        $tipo_modificacion = $data['tipo_modificacion'];
        $porcentaje = floatval($data['porcentaje']);
        $sucursal = isset($data['sucursal']) ? intval($data['sucursal']) : 1;
        $observacion = isset($data['observacion']) ? $data['observacion'] : 'Cambio masivo desde aplicaciÃ³n web';
        $usuario = isset($data['usuario']) && !empty($data['usuario']) 
            ? $data['usuario'] 
            : 'usuario_desconocido';
        
        // Construir descripciÃ³n inteligente para auditorÃ­a
        $tipo_descriptivo = "ACTUALIZACIÃ“N POR ";
        
        if (!empty($marca)) {
            $tipo_descriptivo .= "MARCA (" . trim($marca) . ") Y ";
        } elseif (!empty($rubro)) {
            $tipo_descriptivo .= "RUBRO (" . trim($rubro) . ") Y ";
        } elseif (!empty($cd_proveedor)) {
            $tipo_descriptivo .= "PROVEEDOR (" . $cd_proveedor . ") Y ";
        } elseif (!empty($cod_iva)) {
            $tipo_descriptivo .= "TIPO IVA (" . $cod_iva . ") Y ";
        } else {
            $tipo_descriptivo .= "FILTRO MÃšLTIPLE Y ";
        }
        
        $tipo_descriptivo .= strtoupper($tipo_modificacion);
        
        // Iniciar transacciÃ³n
        $this->db->trans_begin();
        
        // âœ… NUEVO: Detectar si usar funciÃ³n atÃ³mica o clÃ¡sica
        $use_atomic = isset($data['atomic']) && $data['atomic'] === true;
        
        if ($use_atomic) {
            // Llamar a la funciÃ³n ATÃ“MICA que actualiza precios Y conflistas
            $sql = "SELECT update_precios_masivo_atomico(?, ?, ?, ?, ?, ?, ?, ?) as result";
            $params = array(
                $marca, 
                $cd_proveedor, 
                $rubro, 
                $cod_iva, 
                $tipo_descriptivo,  // DescripciÃ³n inteligente incluyendo "ATOMICO"
                $porcentaje, 
                $sucursal, 
                $usuario
            );
        } else {
            // Llamar a la funciÃ³n CLÃSICA (compatibilidad legacy)
            $sql = "SELECT update_precios_masivo(?, ?, ?, ?, ?, ?, ?, ?) as result";
            $params = array(
                $marca, 
                $cd_proveedor, 
                $rubro, 
                $cod_iva, 
                $tipo_descriptivo,  // DescripciÃ³n inteligente en lugar de tipo_modificacion
                $porcentaje, 
                $sucursal, 
                $usuario            // Sin observacion - ahora posiciÃ³n 8
            );
        }
        
        $query = $this->db->query($sql, $params);
        
        if ($query && $query->num_rows() > 0) {
            $row = $query->row();
            $result_json = $row->result;
            $result = json_decode($result_json, true);
            
            if ($result && $result['success']) {
                // Commit la transacciÃ³n
                $this->db->trans_commit();
                
                // âœ… MEJORADO: Agregar informaciÃ³n especÃ­fica de operaciÃ³n atÃ³mica
                $response_data = [
                    'error' => false,
                    'result' => $result_json,
                    'atomic_operation' => $use_atomic,  // Indicar si fue operaciÃ³n atÃ³mica
                    'function_used' => $use_atomic ? 'update_precios_masivo_atomico' : 'update_precios_masivo'
                ];
                
                // Si fue operaciÃ³n atÃ³mica, agregar detalles adicionales
                if ($use_atomic && isset($result['conflistas_actualizadas'])) {
                    $response_data['conflistas_actualizadas'] = $result['conflistas_actualizadas'];
                }
                
                $this->response($response_data);
            } else {
                // Rollback en caso de error
                $this->db->trans_rollback();
                
                $error_message = isset($result['message']) ? $result['message'] : 'Error desconocido en la actualizaciÃ³n';
                
                // âœ… MEJORADO: Respuesta de error con contexto atÃ³mico
                $error_response = [
                    'error' => true,
                    'mensaje' => $error_message,
                    'atomic_operation' => $use_atomic,
                    'rollback_executed' => true
                ];
                
                // Si fue error atÃ³mico, incluir informaciÃ³n especÃ­fica
                if ($use_atomic && isset($result['rollback_completo'])) {
                    $error_response['rollback_completo'] = $result['rollback_completo'];
                    $error_response['sqlstate'] = $result['sqlstate'] ?? null;
                }
                
                $this->response($error_response, 500);
            }
        } else {
            // Rollback en caso de error
            $this->db->trans_rollback();
            
            $this->response([
                'error' => true,
                'mensaje' => 'No se pudo ejecutar la actualizaciÃ³n masiva de precios'
            ], 500);
        }
        
    } catch (Exception $e) {
        // Rollback en caso de excepciÃ³n
        $this->db->trans_rollback();
        
        $this->response([
            'error' => true,
            'mensaje' => 'Error interno: ' . $e->getMessage()
        ], 500);
    }
}

// ============================================================================
// ============================================================================
//
//        ALTERNATIVA C - GRANULARIDAD CAJAMOVI (HÃBRIDA)
//        ImplementaciÃ³n: 14 de Octubre de 2025
//
//        Estas funciones implementan el enfoque hÃ­brido donde:
//        1. Frontend calcula y envÃ­a subtotales por mÃ©todo de pago
//        2. Backend valida recalculando desde productos
//        3. Si coinciden â†’ usa frontend (eficiente)
//        4. Si difieren â†’ usa recalculados (seguro) + log warning
//
// ============================================================================
// ============================================================================

/**
 * ============================================================================
 * FUNCIÃ“N PRINCIPAL: procesarSubtotalesHibrido()
 * ============================================================================
 *
 * NÃºcleo de la Alternativa C - ValidaciÃ³n HÃ­brida
 *
 * Procesa subtotales usando enfoque hÃ­brido: valida frontend con recÃ¡lculo backend
 *
 * @param array|null $subtotales_frontend Subtotales recibidos del frontend
 *        Formato: [{cod_tarj: 11, importe_detalle: 10000}, {cod_tarj: 1, importe_detalle: 5000}]
 *
 * @param array $productos Array de productos insertados con cod_tar
 *        Formato: [{cod_tar: 11, precio: 100, cantidad: 100}, ...]
 *
 * @param float $total_movimiento Total del movimiento para validaciÃ³n
 *
 * @param int $id_movimiento ID del movimiento (para logs)
 *
 * @return array Subtotales validados listos para insertar
 *         Formato: [cod_tarj => importe_detalle]
 *         Ejemplo: [11 => 10000.00, 1 => 5000.00]
 *
 * FLUJO DE DECISIÃ“N:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ Â¿Frontend enviÃ³ subtotales vÃ¡lidos? â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                â”‚
 *       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
 *       â”‚ NO              â”‚ SÃ
 *       v                 v
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ Recalcularâ”‚    â”‚ Recalcular para  â”‚
 *   â”‚ desde     â”‚    â”‚ validar          â”‚
 *   â”‚ productos â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜             â”‚
 *         â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
 *         â”‚            â”‚ Â¿Coinciden? â”‚
 *         â”‚            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
 *         â”‚                   â”‚
 *         â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
 *         â”‚          â”‚ SÃ              â”‚ NO
 *         â”‚          v                 v
 *         â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *         â”‚     â”‚ Usar   â”‚      â”‚ Usar     â”‚
 *         â”‚     â”‚Frontendâ”‚      â”‚Recalc +  â”‚
 *         â”‚     â”‚        â”‚      â”‚Warning   â”‚
 *         â”‚     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
 *         â”‚          â”‚               â”‚
 *         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                    â”‚
 *                    v
 *         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *         â”‚ Subtotales listos  â”‚
 *         â”‚ para insertar en   â”‚
 *         â”‚ caja_movi_detalle  â”‚
 *         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */
private function procesarSubtotalesHibrido(
    $subtotales_frontend,
    $productos,
    $total_movimiento,
    $id_movimiento
) {
    // ğŸ” LOG: Entrada de la funciÃ³n
    log_message('info', "ğŸ” procesarSubtotalesHibrido - Movimiento {$id_movimiento}, Total: {$total_movimiento}");
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - Subtotales frontend: ' . json_encode($subtotales_frontend));
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - Cantidad productos: ' . count($productos));

    // ========================================================================
    // 1ï¸âƒ£ VALIDACIÃ“N: Â¿Vienen subtotales del frontend?
    // ========================================================================
    $frontend_valido = is_array($subtotales_frontend) && !empty($subtotales_frontend);
    log_message('info', "ğŸ” procesarSubtotalesHibrido - Frontend vÃ¡lido: " . ($frontend_valido ? 'SÃ' : 'NO'));

    // ========================================================================
    // 2ï¸âƒ£ RECALCULAR desde productos (para validaciÃ³n)
    // ========================================================================
    $subtotales_recalculados = $this->calcularSubtotalesPorMetodoPago(
        $productos,
        $total_movimiento
    );
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - Subtotales recalculados: ' . json_encode($subtotales_recalculados));

    // ========================================================================
    // 3ï¸âƒ£ DECISIÃ“N HÃBRIDA
    // ========================================================================

    // CASO A: Frontend NO enviÃ³ subtotales â†’ Usar recalculados
    if (!$frontend_valido) {
        log_message('info', "ğŸ” CASO A - Movimiento {$id_movimiento}: Usando subtotales recalculados (frontend no enviÃ³ datos)");
        return $subtotales_recalculados;
    }

    // CASO B: No se pudo recalcular â†’ Usar frontend (confiamos)
    if (empty($subtotales_recalculados)) {
        log_message('warning', "ğŸ” CASO B - Movimiento {$id_movimiento}: No se pudo recalcular. Usando subtotales de frontend sin validaciÃ³n");
        $resultado_frontend = $this->formatearSubtotalesFrontend($subtotales_frontend);
        log_message('info', 'ğŸ” CASO B - Resultado frontend formateado: ' . json_encode($resultado_frontend));
        return $resultado_frontend;
    }

    // CASO C: Comparar frontend vs recalculados
    $comparacion = $this->compararSubtotales(
        $subtotales_frontend,
        $subtotales_recalculados
    );
    log_message('info', 'ğŸ” procesarSubtotalesHibrido - ComparaciÃ³n: ' . json_encode($comparacion));

    if ($comparacion['coinciden']) {
        // âœ… COINCIDEN â†’ Usar frontend (mÃ¡s eficiente)
        log_message('info', "ğŸ” CASO C (COINCIDEN) - Movimiento {$id_movimiento}: Subtotales frontend validados âœ“ " .
                    "Coinciden con recÃ¡lculo backend (diff mÃ¡x: {$comparacion['diferencia_max']})");
        $resultado_frontend = $this->formatearSubtotalesFrontend($subtotales_frontend);
        log_message('info', 'ğŸ” CASO C (COINCIDEN) - Resultado frontend formateado: ' . json_encode($resultado_frontend));
        return $resultado_frontend;
    } else {
        // âš ï¸ DISCREPANCIA â†’ Usar recalculados (mÃ¡s seguro)
        log_message('warning', "ğŸ” CASO C (DISCREPANCIA) - Movimiento {$id_movimiento}: DISCREPANCIA detectada. " .
                    "Diferencia mÃ¡xima: {$comparacion['diferencia_max']}. " .
                    "Usando subtotales recalculados por seguridad");

        // Notificar discrepancia al administrador (opcional)
        $this->notificarDiscrepancia($id_movimiento, $comparacion);

        log_message('info', 'ğŸ” CASO C (DISCREPANCIA) - Retornando subtotales recalculados: ' . json_encode($subtotales_recalculados));
        return $subtotales_recalculados;
    }
}

/**
 * ============================================================================
 * FUNCIÃ“N: calcularSubtotalesPorMetodoPago()
 * ============================================================================
 *
 * Recalcula subtotales por mÃ©todo de pago desde array de productos
 * Usado para validaciÃ³n en el enfoque hÃ­brido
 *
 * @param array $productos Array de productos con cod_tar, precio, cantidad
 * @param float $total_movimiento Total del movimiento para validaciÃ³n
 *
 * @return array Subtotales por mÃ©todo de pago
 *         Formato: [cod_tarj => importe_total]
 *         Ejemplo: [11 => 10000.00, 1 => 5000.00]
 */
private function calcularSubtotalesPorMetodoPago($productos, $total_movimiento) {
    // ğŸ” LOG: Entrada
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Total movimiento: ' . $total_movimiento);
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Cantidad productos: ' . count($productos));

    $subtotales_map = array();

    if (empty($productos)) {
        log_message('error', 'ğŸ” calcularSubtotalesPorMetodoPago: Array de productos vacÃ­o');
        return $subtotales_map;
    }

    // Agrupar productos por cod_tar y sumar importes
    foreach ($productos as $index => $producto) {
        $cod_tar = isset($producto['cod_tar']) ? intval($producto['cod_tar']) : null;

        // ğŸ” LOG: Cada producto
        log_message('info', "ğŸ” calcularSubtotalesPorMetodoPago - Producto #{$index}: " . json_encode($producto));

        if ($cod_tar === null || $cod_tar === 0) {
            log_message('warning', 'ğŸ” calcularSubtotalesPorMetodoPago - Producto sin cod_tar: ' .
                        json_encode($producto));
            continue;
        }

        $cantidad = isset($producto['cantidad']) ? floatval($producto['cantidad']) : 0;
        $precio = isset($producto['precio']) ? floatval($producto['precio']) : 0;
        $importe_producto = round($cantidad * $precio, 2);

        // ğŸ” LOG: CÃ¡lculo
        log_message('info', "ğŸ” calcularSubtotalesPorMetodoPago - cod_tar={$cod_tar}, cant={$cantidad}, precio={$precio}, importe={$importe_producto}");

        if (!isset($subtotales_map[$cod_tar])) {
            $subtotales_map[$cod_tar] = 0;
        }
        $subtotales_map[$cod_tar] += $importe_producto;
    }

    // ğŸ” LOG: Mapa antes de validar
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Mapa acumulado: ' . json_encode($subtotales_map));

    // Validar que la suma de subtotales = total del movimiento
    $suma_subtotales = array_sum($subtotales_map);
    $diferencia = abs($suma_subtotales - $total_movimiento);

    // ğŸ” LOG: ValidaciÃ³n
    log_message('info', "ğŸ” calcularSubtotalesPorMetodoPago - Suma subtotales: {$suma_subtotales}, Total: {$total_movimiento}, Diferencia: {$diferencia}");

    if ($diferencia > 0.01) {
        log_message('error', "ğŸ” calcularSubtotalesPorMetodoPago - ERROR: Diferencia > 0.01. " .
                    "Suma: {$suma_subtotales}, Total: {$total_movimiento}, Dif: {$diferencia}");
        return array();
    }

    // Redondear todos los importes a 2 decimales
    foreach ($subtotales_map as $cod_tar => $importe) {
        $subtotales_map[$cod_tar] = round($importe, 2);
    }

    // ğŸ” LOG: Resultado final
    log_message('info', 'ğŸ” calcularSubtotalesPorMetodoPago - Resultado final: ' . json_encode($subtotales_map));

    return $subtotales_map;
}

/**
 * ============================================================================
 * FUNCIÃ“N: compararSubtotales()
 * ============================================================================
 *
 * Compara subtotales del frontend con los recalculados por el backend
 *
 * @param array $subtotales_frontend [{cod_tarj: 11, importe_detalle: 10000}, ...]
 * @param array $subtotales_recalc [11 => 10000, 1 => 5000, ...]
 *
 * @return array Resultado de la comparaciÃ³n
 *         [
 *           'coinciden' => bool,           // TRUE si diferencia <= tolerancia
 *           'diferencia_max' => float,     // Diferencia mÃ¡xima encontrada
 *           'diferencias' => array         // Detalles de cada diferencia
 *         ]
 */
private function compararSubtotales($subtotales_frontend, $subtotales_recalc) {
    $tolerancia = 0.01; // 1 centavo de tolerancia por redondeos
    $diferencia_max = 0;
    $diferencias = array();

    // Convertir arrays a mapas por cod_tarj para comparaciÃ³n fÃ¡cil
    $map_frontend = array();
    foreach ($subtotales_frontend as $sub) {
        $cod_tarj = intval($sub['cod_tarj']);
        $importe = floatval($sub['importe_detalle']);
        $map_frontend[$cod_tarj] = $importe;
    }

    // $subtotales_recalc ya viene como [cod_tar => importe]
    $map_backend = $subtotales_recalc;

    // Obtener todos los cÃ³digos de tarjeta Ãºnicos de ambos arrays
    $cod_tarj_todos = array_unique(
        array_merge(
            array_keys($map_frontend),
            array_keys($map_backend)
        )
    );

    // Comparar cada mÃ©todo de pago
    foreach ($cod_tarj_todos as $cod_tarj) {
        $importe_frontend = isset($map_frontend[$cod_tarj]) ? $map_frontend[$cod_tarj] : 0;
        $importe_backend = isset($map_backend[$cod_tarj]) ? $map_backend[$cod_tarj] : 0;
        $diferencia = abs($importe_frontend - $importe_backend);

        // Actualizar diferencia mÃ¡xima
        if ($diferencia > $diferencia_max) {
            $diferencia_max = $diferencia;
        }

        // Registrar diferencias significativas
        if ($diferencia > $tolerancia) {
            $diferencias[] = array(
                'cod_tarj' => $cod_tarj,
                'frontend' => $importe_frontend,
                'backend' => $importe_backend,
                'diferencia' => $diferencia
            );
        }
    }

    return array(
        'coinciden' => ($diferencia_max <= $tolerancia),
        'diferencia_max' => round($diferencia_max, 2),
        'diferencias' => $diferencias
    );
}

/**
 * ============================================================================
 * FUNCIÃ“N: formatearSubtotalesFrontend()
 * ============================================================================
 *
 * Formatea subtotales del frontend a array asociativo [cod_tarj => importe]
 *
 * @param array $subtotales_frontend [{cod_tarj: 11, importe_detalle: 10000}, ...]
 *
 * @return array [cod_tarj => importe_detalle]
 */
private function formatearSubtotalesFrontend($subtotales_frontend) {
    // ğŸ” LOG: Entrada de la funciÃ³n
    log_message('info', 'ğŸ” formatearSubtotalesFrontend - Entrada: ' . json_encode($subtotales_frontend));

    $resultado = array();

    foreach ($subtotales_frontend as $item) {
        $cod_tarj = intval($item['cod_tarj']);
        $importe = round(floatval($item['importe_detalle']), 2);
        $resultado[$cod_tarj] = $importe;

        // ğŸ” LOG: Cada elemento procesado
        log_message('info', "ğŸ” formatearSubtotalesFrontend - Procesado: cod_tarj={$cod_tarj}, importe={$importe}");
    }

    // ğŸ” LOG: Resultado final
    log_message('info', 'ğŸ” formatearSubtotalesFrontend - Resultado: ' . json_encode($resultado));

    return $resultado;
}

/**
 * ============================================================================
 * FUNCIÃ“N: insertarDetallesMetodosPago()
 * ============================================================================
 *
 * Inserta detalles de mÃ©todos de pago en caja_movi_detalle
 *
 * @param int $id_movimiento ID del movimiento padre
 * @param array $subtotales Array asociativo [cod_tarj => importe]
 * @param float $total_movimiento Total para calcular porcentaje
 *
 * @throws Exception Si falla alguna inserciÃ³n
 */
private function insertarDetallesMetodosPago($id_movimiento, $subtotales, $total_movimiento) {
    // ğŸ” LOG: Entrada de la funciÃ³n
    log_message('info', "ğŸ” insertarDetallesMetodosPago - ID Movimiento: {$id_movimiento}, Total: {$total_movimiento}");
    log_message('info', 'ğŸ” insertarDetallesMetodosPago - Subtotales recibidos: ' . json_encode($subtotales));
    log_message('info', 'ğŸ” insertarDetallesMetodosPago - Cantidad de subtotales: ' . count($subtotales));

    if (empty($subtotales)) {
        log_message('warning', "insertarDetallesMetodosPago: Array de subtotales vacÃ­o para movimiento {$id_movimiento}");
        return;
    }

    $contador = 0;
    foreach ($subtotales as $cod_tarj => $importe_detalle) {
        $contador++;

        // ğŸ” LOG: Cada iteraciÃ³n
        log_message('info', "ğŸ” insertarDetallesMetodosPago - IteraciÃ³n #{$contador}: cod_tarj={$cod_tarj}, importe={$importe_detalle}");

        // Calcular porcentaje
        $porcentaje = ($total_movimiento > 0)
            ? round(($importe_detalle / $total_movimiento) * 100, 2)
            : 0;

        $detalle = array(
            'id_movimiento' => $id_movimiento,
            'cod_tarj' => $cod_tarj,
            'importe_detalle' => round($importe_detalle, 2),
            'porcentaje' => $porcentaje
        );

        // ğŸ” LOG: Datos a insertar
        log_message('info', 'ğŸ” insertarDetallesMetodosPago - Datos a insertar: ' . json_encode($detalle));

        $this->db->insert('caja_movi_detalle', $detalle);

        // ğŸ” LOG: Resultado de inserciÃ³n
        $affected = $this->db->affected_rows();
        log_message('info', "ğŸ” insertarDetallesMetodosPago - Filas afectadas: {$affected}");

        if ($affected === 0) {
            log_message('error', "ğŸ” insertarDetallesMetodosPago - ERROR: No se insertÃ³ el registro para cod_tarj {$cod_tarj}");
            throw new Exception("Error al insertar detalle para cod_tarj {$cod_tarj} en movimiento {$id_movimiento}");
        }
    }

    log_message('info', "ğŸ” insertarDetallesMetodosPago - COMPLETADO: {$contador} de " . count($subtotales) . " detalles insertados en caja_movi_detalle");
}

/**
 * ============================================================================
 * FUNCIÃ“N: notificarDiscrepancia() (OPCIONAL)
 * ============================================================================
 *
 * Notifica discrepancia al administrador cuando hay diferencias entre
 * los subtotales del frontend y los recalculados por el backend
 *
 * Implementar segÃºn necesidades:
 * - Email al administrador
 * - Log en tabla de auditorÃ­a
 * - Alerta en dashboard
 *
 * @param int $id_movimiento ID del movimiento con discrepancia
 * @param array $comparacion Resultado de compararSubtotales()
 */
private function notificarDiscrepancia($id_movimiento, $comparacion) {
    // Por ahora, solo log detallado
    // TODO: Implementar notificaciÃ³n por email/dashboard segÃºn requerimientos

    log_message('error', "AUDITORÃA: Discrepancia en movimiento {$id_movimiento}. " .
                "Diferencia mÃ¡xima: {$comparacion['diferencia_max']}. " .
                "Detalles: " . json_encode($comparacion['diferencias']));

    // Ejemplo de implementaciÃ³n futura:
    // $this->enviarEmailAdministrador(
    //     'Discrepancia en Cajamovi',
    //     "Se detectÃ³ una discrepancia en el movimiento {$id_movimiento}..."
    // );

    // O insertar en tabla de auditorÃ­a:
    // $this->db->insert('auditoria_discrepancias', [
    //     'id_movimiento' => $id_movimiento,
    //     'diferencia_max' => $comparacion['diferencia_max'],
    //     'detalles_json' => json_encode($comparacion['diferencias']),
    //     'fecha_deteccion' => date('Y-m-d H:i:s')
    // ]);
}

// ============================================================================
//                     FIN ALTERNATIVA C - GRANULARIDAD CAJAMOVI
// ============================================================================

}

