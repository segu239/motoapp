import { Component, OnInit, OnDestroy } from '@angular/core';
//agregar importacion de router para navegacion
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { CarritoService } from 'src/app/services/carrito.service';
import { SubirdataService } from 'src/app/services/subirdata.service';
import { CargardataService } from 'src/app/services/cargardata.service';
import Swal from 'sweetalert2';
import { first, take } from 'rxjs/operators';
import { CrudService } from '../../services/crud.service';
import { set } from '@angular/fire/database';
import { MotomatchBotService } from 'src/app/services/motomatch-bot.service';
import * as pdfMake from 'pdfmake/build/pdfmake';
import * as pdfFonts from 'pdfmake/build/vfs_fonts';
pdfMake.vfs = pdfFonts.pdfMake.vfs;
import { DialogService, DynamicDialogRef } from 'primeng/dynamicdialog';
import { formatDate } from '@angular/common';
import { TarjCredito } from 'src/app/interfaces/tarjcredito';
import { getEmpresaConfig } from '../../config/empresa-config';
interface Cliente {
  nombre: string;
  direccion: string;
  dni: string;
  cuit: string;
  tipoiva: string;
}

@Component({
  selector: 'app-carrito',
  templateUrl: './carrito.component.html',
  styleUrls: ['./carrito.component.css']
})
export class CarritoComponent implements OnDestroy {
  ref: DynamicDialogRef | undefined;
  public FechaCalend: any;
  public itemsEnCarrito: any[] = [];
  public tarjetas: TarjCredito[] = [];
  public suma: number = 0;
  public tipoDoc: string = "FC";
  public numerocomprobante: string;
  public numerocomprobanteImpresion: string;
  public puntoventa: number = 0; // Se asignar√° din√°micamente seg√∫n la sucursal
  private myRegex = new RegExp('^[0-9]+$');
  public sucursal: string = '';
  public sucursalNombre: string = '';
  private indiceTipoDoc: string;
  public inputOPFlag: boolean = true;
  public puntoVenta_flag: boolean = true;
  public letras_flag: boolean = true;
  public letras: any = ["A", "B", "C"];
  public letraValue: string = "A";
  public vendedores: any[] = [];
  public vendedoresV: any;
  public cliente: any;
  public usuario: any;
  itemsConTipoPago: any[] = [];
  public subtotalesPorTipoPago: Array<{tipoPago: string, subtotal: number}> = [];

  private subscriptions: Subscription[] = [];
  constructor(private _cargardata: CargardataService, private bot: MotomatchBotService, private _crud: CrudService, private _subirdata: SubirdataService, private _carrito: CarritoService, private router: Router) {
    // Verificar autenticaci√≥n antes de inicializar
    if (!sessionStorage.getItem('usernameOp')) {
      this.router.navigate(['/login2']);
      return;
    }

    this.FechaCalend = new Date();
    this.getItemsCarrito();
    this.calculoTotal();
    this.getNombreSucursal();
    this.getVendedores();
    this.usuario = sessionStorage.getItem('usernameOp');
    this.initializePuntoVenta(); // Inicializar punto de venta seg√∫n sucursal
    
    // Validaci√≥n defensiva para datos del cliente
    const clienteData = sessionStorage.getItem('datoscliente');
    if (clienteData) {
      try {
        this.cliente = JSON.parse(clienteData);
        this.initLetraValue();
      } catch (error) {
        console.error('Error al parsear datos del cliente:', error);
        // Establecer cliente por defecto en lugar de redirigir
        this.cliente = { cod_iva: 2 }; // Consumidor final por defecto
        this.initLetraValue();
      }
    } else {
      // Si no hay datos del cliente, establecer valores por defecto
      this.cliente = { cod_iva: 2 }; // Consumidor final por defecto
      this.initLetraValue();
    }
  }
  ngOnInit() {
    this.cargarTarjetas();
  }
  cargarTarjetas() {
    const tarjetasSubscription = this._cargardata.tarjcredito().subscribe((data: any) => {
      this.tarjetas = data.mensaje;
      console.log('Tarjetas obtenidas:', this.tarjetas);
     // this.agregarTipoPago();
     this.actualizarItemsConTipoPago();

     // Inicializar subtotales despu√©s de cargar tarjetas
     if (this.itemsEnCarrito.length > 0) {
       this.subtotalesPorTipoPago = this.calcularSubtotalesPorTipoPago();
       console.log('Subtotales inicializados:', this.subtotalesPorTipoPago);
     }

      console.log('Items en carrito despu√©s de agregar tipoPago:', this.itemsEnCarrito);
    });
    this.subscriptions.push(tarjetasSubscription);
  }
 /*  agregarTipoPago() {
    const tarjetaMap = new Map();
    this.tarjetas.forEach(tarjeta => {
      tarjetaMap.set(tarjeta.cod_tarj, tarjeta.tarjeta);
    });
    console.log('Mapa de tarjetas:', tarjetaMap);
    this.itemsEnCarrito = this.itemsEnCarrito.map(item => {
      const tipoPago = tarjetaMap.get(item.cod_tar);
    console.log(`Item: ${item.cod_tar}, TipoPago: ${tipoPago}`);
      return {
        ...item,
        tipoPago: tarjetaMap.get(item.cod_tar.toString())
      };
    });
  } */
    actualizarItemsConTipoPago() {
      const tarjetaMap = new Map();
      this.tarjetas.forEach(tarjeta => {
        tarjetaMap.set(tarjeta.cod_tarj, tarjeta.tarjeta);
      });
  
      console.log('Mapa de tarjetas:', tarjetaMap);
  
      this.itemsConTipoPago = this.itemsEnCarrito.map(item => {
        const tipoPago = tarjetaMap.get(item.cod_tar.toString());
        console.log(`Item: ${item.cod_tar}, TipoPago: ${tipoPago}`);
        return {
          ...item,
          tipoPago: tipoPago
        };
      });
    }
  getItemsCarrito() {
    const items = sessionStorage.getItem('carrito');
    if (items) {
      try {
        this.itemsEnCarrito = JSON.parse(items);
        // Validar que sea un array v√°lido
        if (!Array.isArray(this.itemsEnCarrito)) {
          this.itemsEnCarrito = [];
        }
      } catch (error) {
        console.error('Error al parsear items del carrito:', error);
        this.itemsEnCarrito = [];
        sessionStorage.removeItem('carrito');
      }
    } else {
      this.itemsEnCarrito = [];
    }
  }
  getVendedores() {
    const vendedoresSubscription = this._cargardata.vendedores().subscribe((res: any) => {
      this.vendedores = res.mensaje;
      console.log(this.vendedores);
    });
    this.subscriptions.push(vendedoresSubscription);
  }
  getNombreSucursal() {
    this.sucursal = sessionStorage.getItem('sucursal');
    console.log(this.sucursal);

    const sucursalesSubscription = this._crud.getListSnap('sucursales').subscribe(
      data => {
        const sucursales = data.map(item => {
          const payload = item.payload.val() as any;
          return {
            nombre: payload.nombre,
            value: payload.value
          };
        });
        
        // Buscar la sucursal correspondiente en los datos cargados
        const sucursalEncontrada = sucursales.find(suc => suc.value.toString() === this.sucursal);
        if (sucursalEncontrada) {
          this.sucursalNombre = sucursalEncontrada.nombre;
        } else {
          // Guardar ID de sucursal para debugging
          console.warn('No se encontr√≥ la sucursal con ID:', this.sucursal);
          this.sucursalNombre = 'Sucursal ' + this.sucursal;
        }
      },
      error => {
        console.error('Error al cargar sucursales:', error);
        this.showNotification('Error al cargar las sucursales');
        
        // En caso de error, usamos un valor gen√©rico como fallback
        this.sucursalNombre = 'Sucursal ' + this.sucursal;
      }
    );
    this.subscriptions.push(sucursalesSubscription);
  }

  initLetraValue() {
    if (!this.cliente) {
      this.letraValue = "B"; // Valor por defecto
      return;
    }
    
    if (this.cliente.cod_iva == 2)//consumidor final
    { this.letraValue = "B"; }
    else if (this.cliente.cod_iva == 1)//excento
    {
      this.letraValue = "A";
    }
    else if (this.cliente.cod_iva == 3)//monotributo
    {
      this.letraValue = "A";
    }
    else {
      this.letraValue = "B";
    }
  }

  /**
   * Inicializa el punto de venta con el n√∫mero de sucursal actual
   * Se ejecuta al cargar el componente para asegurar consistencia
   */
  private initializePuntoVenta(): void {
    const sucursal = sessionStorage.getItem('sucursal');
    if (sucursal) {
      this.puntoventa = parseInt(sucursal);
      console.log('Punto de venta inicializado correctamente:', this.puntoventa, 'para sucursal:', sucursal);
    } else {
      console.warn('No se encontr√≥ sucursal en sessionStorage - usando puntoventa = 0');
      this.puntoventa = 0;
    }
  }

  tipoDocChange(event) {
    console.log(event.target.value);
    this.tipoDoc = event.target.value;
    if (this.tipoDoc == "FC") {
      this.inputOPFlag = true;
      // se cambio esto para sacar el punto de venta y ponerle el valor de la sucursal----
      this.puntoVenta_flag = false;//this.puntoVenta_flag = true;
      //se agreg√≥ esto para que el punto de venta sea igual a la sucursal-------------------
      // Asegurar que siempre use la sucursal actual de forma segura
      this.puntoventa = parseInt(this.sucursal) || parseInt(sessionStorage.getItem('sucursal') || '0');
      console.log('PUNTO DE VENTA FC:', this.puntoventa);
      this.letras_flag = true;
    }
    else if (this.tipoDoc == "NC") {
      this.inputOPFlag = true;
      this.puntoVenta_flag = false;
      // Para notas de cr√©dito, mantener el punto de venta de la sucursal
      this.puntoventa = parseInt(this.sucursal) || parseInt(sessionStorage.getItem('sucursal') || '0');
      this.letras_flag = false;
    }
    else if (this.tipoDoc == "NV") {
      this.inputOPFlag = true;
      this.puntoVenta_flag = false;
      // Para notas de venta, mantener el punto de venta de la sucursal
      this.puntoventa = parseInt(this.sucursal) || parseInt(sessionStorage.getItem('sucursal') || '0');
      this.letras_flag = false;
    }
    else if (this.tipoDoc == "ND") {
      this.inputOPFlag = true;
      this.puntoVenta_flag = false;
      // Para notas de d√©bito, mantener el punto de venta de la sucursal
      this.puntoventa = parseInt(this.sucursal) || parseInt(sessionStorage.getItem('sucursal') || '0');
      this.letras_flag = false;
    }
    else if (this.tipoDoc == "PR") {
      this.inputOPFlag = false;
      this.puntoVenta_flag = false;
      // Para presupuestos, tambi√©n usar el punto de venta de la sucursal
      this.puntoventa = parseInt(this.sucursal) || parseInt(sessionStorage.getItem('sucursal') || '0');
      this.letras_flag = false;
    }
    else if (this.tipoDoc == "CS") {
      this.inputOPFlag = false;
      this.puntoVenta_flag = false;
      // Para consultas, tambi√©n usar el punto de venta de la sucursal
      this.puntoventa = parseInt(this.sucursal) || parseInt(sessionStorage.getItem('sucursal') || '0');
      this.letras_flag = false;
    }
  }
  eliminarItem(item: any) {
    // Validaci√≥n defensiva: verificar que el item sea v√°lido
    if (!item || !item.id_articulo) {
      console.error('Item inv√°lido para eliminar:', item);
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: 'No se puede eliminar este item. Datos inv√°lidos.'
      });
      return;
    }

    // Confirmar eliminaci√≥n
    Swal.fire({
      title: 'Estas seguro?',
      text: "Vas a eliminar un item del carrito!",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Si, eliminar!'
    }).then((result) => {
      if (result.isConfirmed) {
        try {
          // ‚úÖ FIX: Usar findIndex con identificador compuesto (id_articulo + cod_tar)
          // Esto maneja correctamente el caso de productos duplicados con diferentes tipos de pago
          const index = this.itemsEnCarrito.findIndex(i =>
            i.id_articulo === item.id_articulo &&
            i.cod_tar === item.cod_tar
          );

          // Validar que el item fue encontrado
          if (index === -1) {
            console.error('Item no encontrado en carrito:', item);
            Swal.fire({
              icon: 'error',
              title: 'Error',
              text: 'No se pudo encontrar el item en el carrito.'
            });
            return;
          }

          // Eliminar el item del array
          this.itemsEnCarrito.splice(index, 1);

          // Guardar en sessionStorage con manejo de errores
          try {
            sessionStorage.setItem('carrito', JSON.stringify(this.itemsEnCarrito));
          } catch (storageError) {
            console.error('Error al guardar en sessionStorage:', storageError);
            Swal.fire({
              icon: 'warning',
              title: 'Advertencia',
              text: 'El item se elimin√≥ pero no se pudo guardar. Recargue la p√°gina.'
            });
          }

          // Actualizar el resto del sistema
          this._carrito.actualizarCarrito(); // Refrescar el n√∫mero del carrito del header
          this.calculoTotal();
          this.actualizarItemsConTipoPago();

          // Confirmar eliminaci√≥n exitosa
          Swal.fire('Eliminado!', 'El item fue eliminado.', 'success');

        } catch (error) {
          console.error('Error inesperado al eliminar item:', error);
          Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Ocurri√≥ un error inesperado. Recargue la p√°gina.'
          });
        }
      }
    });
  }

  calculoTotal() {
    this.suma = 0;
    for (let item of this.itemsEnCarrito) {
      this.suma += parseFloat((item.precio * item.cantidad).toFixed(2));
    }
    this.suma = parseFloat(this.suma.toFixed(2));

    // Recalcular subtotales por tipo de pago si las tarjetas ya est√°n cargadas
    if (this.tarjetas && this.tarjetas.length > 0) {
      this.subtotalesPorTipoPago = this.calcularSubtotalesPorTipoPago();
    }
  }

  /**
   * Actualiza la cantidad de un item en ambos arrays y sincroniza con sessionStorage
   * @param item - Item del carrito a actualizar
   * @param nuevaCantidad - Nueva cantidad del producto
   */
  actualizarCantidad(item: any, nuevaCantidad: number) {
    // Validar que la cantidad sea v√°lida
    if (nuevaCantidad < 1) {
      nuevaCantidad = 1;
    }

    // Actualizar en itemsConTipoPago
    item.cantidad = nuevaCantidad;

    // Encontrar y actualizar el mismo item en itemsEnCarrito
    const itemEnCarrito = this.itemsEnCarrito.find(i => i.id_articulo === item.id_articulo);
    if (itemEnCarrito) {
      itemEnCarrito.cantidad = nuevaCantidad;
    }

    // Guardar en sessionStorage para mantener persistencia
    sessionStorage.setItem('carrito', JSON.stringify(this.itemsEnCarrito));

    // Recalcular total
    this.calculoTotal();
  }

  /**
   * Convierte subtotales con nombres al formato esperado por el backend
   * @param subtotales Array con tipoPago (nombre) y subtotal
   * @returns Array con cod_tarj e importe_detalle para el backend
   */
  private formatearSubtotalesParaBackend(subtotales: Array<{tipoPago: string, subtotal: number}>): Array<{cod_tarj: number, importe_detalle: number}> {
    // Validaci√≥n defensiva
    if (!subtotales || subtotales.length === 0 || !this.tarjetas || this.tarjetas.length === 0) {
      return [];
    }

    // Crear mapa inverso: nombre de tarjeta -> cod_tarj
    const nombreATarjetaMap = new Map<string, number>();
    this.tarjetas.forEach((t: TarjCredito) => {
      nombreATarjetaMap.set(t.tarjeta, t.cod_tarj);
    });

    // Convertir al formato del backend
    const subtotalesBackend: Array<{cod_tarj: number, importe_detalle: number}> = [];

    for (const subtotal of subtotales) {
      const cod_tarj = nombreATarjetaMap.get(subtotal.tipoPago);

      if (cod_tarj !== undefined) {
        subtotalesBackend.push({
          cod_tarj: cod_tarj,
          importe_detalle: parseFloat(subtotal.subtotal.toFixed(2))
        });
      } else {
        // üîç LOG DETALLADO para debugging
        console.error('‚ùå MAPEO FALLIDO - Detalles:', {
          tipoPago: subtotal.tipoPago,
          tipoPagoLength: subtotal.tipoPago.length,
          tipoPagoTrimmed: subtotal.tipoPago.trim(),
          tipoPagoBytes: Array.from(subtotal.tipoPago).map(c => c.charCodeAt(0)).join(','),
          subtotalImporte: subtotal.subtotal,
          tarjetasDisponibles: Array.from(nombreATarjetaMap.keys()),
          nombresSimilares: Array.from(nombreATarjetaMap.keys()).filter(k =>
            k.toLowerCase().includes(subtotal.tipoPago.toLowerCase().trim().substring(0, 5))
          )
        });
      }
    }

    return subtotalesBackend;
  }

  /**
   * Calcula subtotales agrupados por tipo de pago
   * @returns Array de objetos con tipoPago y subtotal ordenados alfab√©ticamente
   */
  calcularSubtotalesPorTipoPago(): Array<{tipoPago: string, subtotal: number}> {
    // Validaci√≥n defensiva: verificar que el array de tarjetas est√© cargado
    if (!this.tarjetas || this.tarjetas.length === 0) {
      console.warn('calcularSubtotalesPorTipoPago: Array de tarjetas vac√≠o o no cargado');
      return [];
    }

    // Pre-computar mapa de tarjetas para optimizaci√≥n O(m+n) en lugar de O(n*m)
    const tarjetaMap = new Map<string, string>();
    this.tarjetas.forEach((t: TarjCredito) => {
      tarjetaMap.set(t.cod_tarj.toString(), t.tarjeta);
    });

    // Acumular subtotales por tipo de pago
    const subtotales = new Map<string, number>();

    for (let item of this.itemsEnCarrito) {
      // Resolver tipo de pago usando el mapa pre-computado
      const tipoPago = tarjetaMap.get(item.cod_tar?.toString() || '') || 'Indefinido';

      // Calcular monto del item (precio * cantidad) con precisi√≥n de 2 decimales
      const montoItem = parseFloat((item.precio * item.cantidad).toFixed(2));

      // Acumular en el subtotal correspondiente
      if (subtotales.has(tipoPago)) {
        subtotales.set(tipoPago, subtotales.get(tipoPago)! + montoItem);
      } else {
        subtotales.set(tipoPago, montoItem);
      }
    }

    // Convertir Map a Array y ordenar alfab√©ticamente (Indefinido al final)
    const resultado = Array.from(subtotales.entries())
      .map(([tipoPago, subtotal]) => ({
        tipoPago,
        subtotal: parseFloat(subtotal.toFixed(2))
      }))
      .sort((a, b) => {
        if (a.tipoPago === 'Indefinido') return 1;
        if (b.tipoPago === 'Indefinido') return -1;
        return a.tipoPago.localeCompare(b.tipoPago);
      });

    // Advertencia de rendimiento si hay demasiados tipos de pago
    if (resultado.length > 50) {
      console.warn(`Advertencia: ${resultado.length} tipos de pago diferentes detectados. Esto podr√≠a afectar el rendimiento de la interfaz.`);
    }

    return resultado;
  }

  async finalizar() {
    if (this.itemsEnCarrito.length > 0) {//hacer si 
      console.log(this.puntoventa);
      if (this.pendientes()) {
        Swal.fire({
          title: 'Enviando...',
          allowOutsideClick: false,
        });
        this.indiceTipoDoc = "";
        console.log('TIPO DOC:' + this.tipoDoc);
        console.log('PUNTO VENTA:' + this.puntoventa);
        
        // Validaci√≥n adicional: asegurar que puntoventa siempre coincida con sucursal
        const sucursalActual = parseInt(sessionStorage.getItem('sucursal') || '0');
        if (this.puntoventa !== sucursalActual) {
          console.warn('Corrigiendo puntoventa:', this.puntoventa, '-> ', sucursalActual);
          this.puntoventa = sucursalActual;
        }
        if (this.tipoDoc == undefined || this.tipoDoc == "" || this.puntoventa == undefined)//if (this.tipoDoc == undefined || this.tipoDoc == "" || this.numerocomprobante == undefined || this.numerocomprobante == "" || this.puntoventa == undefined || this.puntoventa == "") 
        {
          Swal.fire({
            icon: 'error',
            title: 'Error..',
            text: 'Faltan datos!',
            footer: 'Completar todos los campos'
          })
          return;
        }
        else {
          if (this.tipoDoc == "ND") {
            this.indiceTipoDoc = "notadebito";
            this.numerocomprobante = this.numerocomprobante; //numero.toString();
          }
          else if (this.tipoDoc == "FC") {
            this.indiceTipoDoc = "factura";
            this.numerocomprobante = this.numerocomprobante; //numero.toString();
          }
          else if (this.tipoDoc == "NC") {
            this.indiceTipoDoc = "notacredito";
            this.numerocomprobante = this.numerocomprobante;//numero.toString();
          }
          else if (this.tipoDoc == "NV") {
            this.indiceTipoDoc = "devolucion";

            this.numerocomprobante = this.numerocomprobante;//numero.toString();
          }
          else if (this.tipoDoc == "PR") {
            this.indiceTipoDoc = "presupuesto";
            let numero = await this._crud.getNumeroSecuencial('presupuesto').pipe(take(1)).toPromise();
            console.log('NUMERO SECUENCIAL:' + numero);
            this.numerocomprobante = numero.toString();
          }
          else if (this.tipoDoc == "CS") {
            this.indiceTipoDoc = "consulta";
            let numero = await this._crud.getNumeroSecuencial('consulta').pipe(take(1)).toPromise();
            console.log('NUMERO SECUENCIAL:' + numero);
            this.numerocomprobante = numero.toString();
          }
          let emailOp = sessionStorage.getItem('emailOp');
          // Crear datos para descuento de stock (con id_articulo)
          let stockData = this.itemsEnCarrito.map(obj => {
            return {
              id_articulo: obj.id_articulo,
              cantidad: obj.cantidad,
              tipodoc: this.tipoDoc
            };
          });

          // Crear datos para guardar en psucursal (sin id_articulo)
          let result = this.itemsEnCarrito.map(obj => {
            const { id_articulo, ...objSinIdArticulo } = obj;
            return {
              ...objSinIdArticulo,
              emailop: emailOp,
              tipodoc: this.tipoDoc,
              puntoventa: this.puntoventa,
              numerocomprobante: this.numerocomprobante,
              estado: "NP",
              idven: this.vendedoresV,
              idart: obj.id_articulo || 0 // Usar id_articulo en el campo idart para psucursal
            };
          });
          this.numerocomprobanteImpresion = this.numerocomprobante;
          sessionStorage.setItem('carrito', JSON.stringify(result));
          console.log(result);
          let sucursal = sessionStorage.getItem('sucursal');
          // Mapeado de sucursal a exi - Lo mantenemos hasta que se pueda cambiar en la base de datos
          let exi = 0;
          // Usando un objeto de mapeo en lugar de condicionales
        /*   const mappedValues = {
            "2": 3,  // Suc. Valle Viejo
            "3": 4,  // Suc. Guemes
            "4": 1   // Deposito
          }; */
           const mappedValues = {
    "1": 2,  // Casa Central ‚Üí exi2
    "2": 3,  // Suc. Valle Viejo ‚Üí exi3
    "3": 4,  // Suc. Guemes ‚Üí exi4
    "4": 1,   // Deposito ‚Üí exi1
    "5": 5,   // Mayorista ‚Üí exi5
  };
          
          // Usamos el objeto de mapeo, con fallback a 0 si no existe
          exi = mappedValues[sucursal] || 0;
          this._subirdata.editarStockArtSucxManagedPHP(stockData, exi).pipe(take(1)).subscribe({
            next: (data: any) => {
              console.log('Stock actualizado:', data);
              if (!data.error) {
                // Solo si el descuento fue exitoso, proceder con el pedido
                this.agregarPedido(result, sucursal);
              } else {
                Swal.fire({
                  icon: 'error',
                  title: 'Error',
                  text: 'No se pudo actualizar el stock: ' + data.mensaje
                });
              }
            },
            error: (error) => {
              console.error('Error al actualizar stock:', error);
              Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'Error de conexi√≥n al actualizar stock'
              });
            }
          });
        }
      }
    }
    else {
      Swal.fire({
        icon: 'error',
        title: 'Error..',
        text: 'No hay items en el carrito!',
        footer: 'Agregue items al carrito'
      })
    }
  }
  cabecera(fecha: any, fechasinformato: any) {
    let year = fechasinformato.getFullYear();
    let month = fechasinformato.getMonth() + 1;
    let formattedMonth = month < 10 ? '0' + month : month;
    let numero_fac: number = 0
    if (this.tipoDoc != "FC") {
      numero_fac = 0;
    }
    else {
      numero_fac = Number(this.numerocomprobante);
      // Limitar n√∫mero de factura al m√°ximo permitido
      if (numero_fac > 999999) {
        numero_fac = 999999;
      }
    }
    
    // Funci√≥n auxiliar para limitar valores num√©ricos
    const limitNumericValue = (value: any, limit: number) => {
      if (value === null || value === undefined || value === '') return null;
      const numValue = parseInt(value);
      return !isNaN(numValue) ? Math.min(numValue, limit) : null;
    };
    
    let codvent = this.getCodVta();
    let saldo = this.sumarCuentaCorriente();
    
    // Asegurarse de que cliente.idcli no exceda el l√≠mite
    let clienteId;
    if (this.cliente && this.cliente.idcli) {
      clienteId = this.cliente.idcli;
      if (parseInt(clienteId) > 999999) {
        clienteId = '999999';
      }
    } else {
      Swal.fire({
        icon: 'warning',
        title: 'Cliente no encontrado',
        text: 'Debe seleccionar un cliente antes de continuar. Dir√≠jase a Art√≠culos para seleccionar un cliente.',
        confirmButtonText: 'Entendido'
      });
      return void 0;
    }
    
    // Verificar datos del cliente antes de crear cabecera
    if (!this.cliente || !this.cliente.cod_iva) {
      Swal.fire({
        icon: 'warning',
        title: 'Datos de cliente incompletos',
        text: 'Faltan datos del cliente. Dir√≠jase a Art√≠culos para seleccionar un cliente v√°lido.',
        confirmButtonText: 'Ir a Art√≠culos',
        showCancelButton: true,
        cancelButtonText: 'Cancelar'
      }).then((result) => {
        if (result.isConfirmed) {
          this.router.navigate(['/articulos']);
        }
      });
      return void 0;
    }

    // MODIFICACI√ìN CR√çTICA: Redondear suma ANTES de calcular IVA
    const totalRedondeado = parseFloat(this.suma.toFixed(2));

    let cabecera = {
      tipo: this.tipoDoc,
      numero_int: limitNumericValue(this.numerocomprobante, 999999),
      puntoventa: limitNumericValue(this.puntoventa, 9999),
      letra: this.letraValue,
      numero_fac: numero_fac,
      atipo: this.tipoDoc,
      anumero_com: numero_fac,
      cliente: clienteId,
      cod_sucursal: limitNumericValue(this.sucursal, 999999),
      emitido: fecha,
      vencimiento: fecha,
      exento: 0,
      basico: parseFloat((totalRedondeado / 1.21).toFixed(4)),//this.suma/1.21,
      iva1: parseFloat((totalRedondeado - totalRedondeado / 1.21).toFixed(4)),
      iva2: 0,
      iva3: 0,
      bonifica: 0,
      bonifica_tipo: 'P', // Por defecto porcentaje
      interes: 0,
      interes_tipo: 'P', // Por defecto porcentaje
      saldo: saldo,//this.suma,
      dorigen: true,
      cod_condvta: limitNumericValue(codvent, 999),
      cod_iva: limitNumericValue(this.cliente.cod_iva, 999),
      cod_vendedor: limitNumericValue(this.vendedoresV, 999),//// aca hay que ver si se agrega un campo para elegir el nombre del vendedor
      anulado: false,
      cuit: this.cliente.cuit,
      usuario: sessionStorage.getItem('emailOp') ? sessionStorage.getItem('emailOp').substring(0, 12) : (() => {
        Swal.fire({
          icon: 'error',
          title: 'Error de sesi√≥n',
          text: 'No se encontr√≥ informaci√≥n del usuario logueado. Por favor, inicie sesi√≥n nuevamente.',
          confirmButtonText: 'Entendido'
        });
        throw new Error('Usuario no encontrado en sessionStorage');
      })(), // Limitado a 12 caracteres para evitar error PostgreSQL
      turno: 0,
      pfiscal: `${year}${formattedMonth}`,
      mperc: 0,
      imp_int: 0,
      fec_proceso: formatDate(this.FechaCalend, 'dd/MM/yy', 'en-US'),//fecha de cierre con caja puede ser otro dia   ?
      fec_ultpago: null,
      estado: "",
      id_aso: 0,
      //id_num:1,
    }
    console.log(cabecera);
    return cabecera;
  }
  sumarCuentaCorriente(): number {
    console.log(this.itemsEnCarrito);
    let acumulado = 0;
    for (let item of this.itemsEnCarrito) {
      console.log(item);
      if (item.cod_tar === 111) {
        acumulado += parseFloat((item.precio * item.cantidad).toFixed(2)); // Asumiendo que cada item tiene un campo 'valor' que queremos sumar
      }
    }
    return parseFloat(acumulado.toFixed(2));
  }

  getCodVta() {
    if (this.itemsEnCarrito.length === 0) {
      return 99;
    }
    const firstCodTar = this.itemsEnCarrito[0].cod_tar;
    for (let item of this.itemsEnCarrito) {
      if (item.cod_tar !== firstCodTar) {
        return 99;
      }
    }
    return firstCodTar;
  }

  agregarProductos() {
    window.history.back();
  }
  validateValue(value: string): boolean {
    return this.myRegex.test(value);
  }
  agregarPedido(pedido: any, sucursal: any) {
    let fecha = new Date();
    let fechaFormateada = fecha.toLocaleDateString('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });

    // ‚úÖ NUEVO: Recalcular subtotales justo antes de imprimir
    // Esto garantiza que las tarjetas est√©n cargadas (mitiga race condition)
    const subtotalesActualizados = (this.tarjetas && this.tarjetas.length > 0)
      ? this.calcularSubtotalesPorTipoPago()
      : [];

    // Advertencia si no se pudieron calcular subtotales
    if (subtotalesActualizados.length === 0 && this.itemsEnCarrito.length > 0) {
      console.warn('‚ö†Ô∏è ADVERTENCIA: No se pudieron calcular subtotales por tipo de pago. PDF sin desglose.');
    }

    let cabecera = this.cabecera(fechaFormateada, fecha);

    // ====================================================================
    // SOLUCI√ìN M√öLTIPLES CAJAS: Crear array de movimientos (uno por m√©todo)
    // ====================================================================
    const cajaMoviPromise = this.crearCajasMovi(pedido, cabecera, fecha, subtotalesActualizados);

    // Manejar la promesa para obtener el array de caja_movi
    if (cajaMoviPromise && cajaMoviPromise.then) {
      // Es una promesa, esperamos a que se resuelva
      cajaMoviPromise.then(movimientos_caja => {
        console.log('‚úÖ Movimientos de caja creados:', movimientos_caja);
        console.log('üìä Cantidad de movimientos:', movimientos_caja.length);

        // ====================================================================
        // ALTERNATIVA C: Formatear subtotales para enviar al backend
        // ====================================================================

        // üîç LOGS DE DEPURACI√ìN - INICIO
        console.log('üîç ========== DEPURACI√ìN SUBTOTALES ==========');
        console.log('1Ô∏è‚É£ Subtotales calculados:', JSON.stringify(subtotalesActualizados, null, 2));
        console.log('2Ô∏è‚É£ Tarjetas cargadas:', JSON.stringify(this.tarjetas, null, 2));
        console.log('3Ô∏è‚É£ Mapa de nombres ‚Üí c√≥digos:',
          this.tarjetas.map(t => ({
            nombre: t.tarjeta,
            cod: t.cod_tarj,
            length: t.tarjeta.length,
            hex: Array.from(t.tarjeta).map(c => c.charCodeAt(0).toString(16)).join(' ')
          }))
        );

        const subtotalesParaBackend = this.formatearSubtotalesParaBackend(subtotalesActualizados);

        console.log('4Ô∏è‚É£ Subtotales enviados al backend:', JSON.stringify(subtotalesParaBackend, null, 2));
        console.log('5Ô∏è‚É£ Validaci√≥n de cantidad:',
          subtotalesActualizados.length === subtotalesParaBackend.length
            ? `‚úÖ CORRECTO (${subtotalesParaBackend.length}/${subtotalesActualizados.length})`
            : `‚ùå ERROR: Se perdieron ${subtotalesActualizados.length - subtotalesParaBackend.length} subtotales`
        );

        // Validar suma total
        const sumaMapeada = subtotalesParaBackend.reduce((acc, sub) => acc + sub.importe_detalle, 0);
        const diferencia = Math.abs(sumaMapeada - this.suma);
        console.log('6Ô∏è‚É£ Validaci√≥n de suma:',
          diferencia < 0.01
            ? `‚úÖ CORRECTO (Suma mapeada: ${sumaMapeada.toFixed(2)}, Total: ${this.suma.toFixed(2)})`
            : `‚ùå ERROR: Diferencia de $${diferencia.toFixed(2)} (Suma: ${sumaMapeada.toFixed(2)}, Total: ${this.suma.toFixed(2)})`
        );
        console.log('üîç ========== FIN DEPURACI√ìN ==========');
        // üîç LOGS DE DEPURACI√ìN - FIN

        console.log('üìä Subtotales formateados para backend:', subtotalesParaBackend);

        // Enviar array de movimientos al backend
        this._subirdata.subirDatosPedidos(pedido, cabecera, sucursal, movimientos_caja, subtotalesParaBackend).pipe(take(1)).subscribe((data: any) => {
          console.log(data.mensaje);
          // ‚úÖ LLAMADA ACTUALIZADA (pasar subtotales recalculados):
          this.imprimir(
            this.itemsEnCarrito,
            this.numerocomprobante,
            fechaFormateada,
            this.suma,
            subtotalesActualizados
          );
          //actualizar indices
          if (this.indiceTipoDoc != "") {
            this._crud.incrementarNumeroSecuencial(this.indiceTipoDoc, parseInt(this.numerocomprobante) + 1).then(() => {
              console.log('Numero secuencial incrementado');
              this.numerocomprobante = "";
            });
          }
          Swal.fire({
            icon: 'success',
            title: 'Pedido enviado',
            text: 'El pedido se envio correctamente!',
            footer: 'Se envio el pedido a la sucursal ' + sessionStorage.getItem('sucursal')
          })
          this.itemsEnCarrito = [];
          this.itemsConTipoPago = [];
          sessionStorage.setItem('carrito', JSON.stringify(this.itemsEnCarrito));
          this._carrito.actualizarCarrito(); // es para refrescar el numero del carrito del header
          this.calculoTotal();
        });
      }).catch(error => {
        console.error('‚ùå Error al crear los movimientos de caja:', error);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Ocurri√≥ un error al crear los movimientos de caja. Por favor, int√©ntelo de nuevo.'
        });
      });
    } else {
      // Si no hay items en el carrito, movimientos_caja puede estar vac√≠o
      console.warn('‚ö†Ô∏è No se pudieron crear los movimientos de caja');
      Swal.fire({
        icon: 'warning',
        title: 'Advertencia',
        text: 'No hay suficiente informaci√≥n para procesar el pedido.'
      });
    }
  }
  pendientes() {
    let missingFields = [];
    if (this.tipoDoc == "FC") {
      if (!this.FechaCalend) {
        missingFields.push('Fecha');
      }
      if (!this.vendedoresV) {
        missingFields.push('Vendedor');
      }
      if (!this.puntoventa) {
        missingFields.push('Punto de venta');
      }
      if (!this.numerocomprobante) {
        missingFields.push('Numero de Comprobante');
      }
    }
    else if (this.tipoDoc == "NC" || this.tipoDoc == "ND" || this.tipoDoc == "NV") {
      if (!this.numerocomprobante) {
        missingFields.push('N√∫mero de comprobante');
      }
      if (!this.vendedoresV) {
        missingFields.push('Vendedor');
      }
    }
    else if (this.tipoDoc == "PR" || this.tipoDoc == "CS") {
      if (!this.vendedoresV) {
        missingFields.push('Vendedor');
      }
    }
    if (missingFields.length > 0) {
      Swal.fire({
        icon: 'error',
        title: 'Error..',
        text: 'Faltan datos!',
        footer: 'Completar: ' + missingFields.join(', ')
      })
      return false;
    }
    else {
      return true;
    }
    // Resto del c√≥digo...
  }
  //-----------------------------------
  imprimir(
    items: any,
    numerocomprobante: string,
    fecha: any,
    total: any,
    subtotalesTipoPago?: Array<{tipoPago: string, subtotal: number}>
  ) {
    //let cliente = JSON.parse(sessionStorage.getItem('datoscliente'));
let cliente: Cliente;

try {
  const datosCliente = sessionStorage.getItem('datoscliente');
  if (datosCliente) {
    cliente = JSON.parse(datosCliente);
  } else {
    cliente = {
      nombre: '',
      direccion: '',
      dni: '',
      cuit: '',
      tipoiva: ''
    };
  }
} catch (error) {
 this.showNotification('Error al leer cliente'); // console.error('Error parsing datoscliente from sessionStorage', error);
  cliente = {
    nombre: '',
    direccion: '',
    dni: '',
    cuit: '',
    tipoiva: ''
  };
}

    // ‚úÖ NUEVO: Validar si se proporcionaron subtotales
    const mostrarDesgloseTipoPago = subtotalesTipoPago && subtotalesTipoPago.length > 0;
    console.log('üéØ Desglose por tipo de pago:', mostrarDesgloseTipoPago ? 'S√ç' : 'NO', subtotalesTipoPago);

    let titulo: string = "";
    if (this.tipoDoc == "FC") {
      titulo = "FACTURA";
    }
    else if (this.tipoDoc == "NC") {
      titulo = "NOTA DE CREDITO";
    }
    else if (this.tipoDoc == "NV") {
      titulo = "DEVOLUCION";
    }
    else if (this.tipoDoc == "ND") {
      titulo = "NOTA DE DEBITO";
    }
    else if (this.tipoDoc == "PR") {
      titulo = "PRESUPUESTO";
    }
    else if (this.tipoDoc == "CS") {
      titulo = "CONSULTA";
    }
    let fechaActual = new Date();
    let fechaFormateada = fechaActual.toISOString().split('T')[0];
    console.log(fechaFormateada);
    const tableBody = items.map(item => [item.cantidad, item.nomart, parseFloat(item.precio.toFixed(2)), parseFloat((item.cantidad * item.precio).toFixed(2))]);
    
    // Obtener configuraci√≥n de empresa seg√∫n sucursal
    const empresaConfig = getEmpresaConfig();
    
    // Definir el contenido del documento
    const documentDefinition = {
      background: {
        canvas: [
          {
            type: 'rect',
            x: 10, // Posici√≥n X del recuadro
            y: 10, // Posici√≥n Y del recuadro
            w: 580, // Ancho del recuadro
            h: 750, // Alto del recuadro
            r: 3, // Radio de las esquinas (para redondearlas)
            lineWidth: 1, // Grosor de la l√≠nea
            lineColor: '#000000', // Color de la l√≠nea (ejemplo: azul)
            fillColor: 'transparent', // Color de relleno transparente
          },
        ],
      },
      content: [
        // Logo o texto seg√∫n configuraci√≥n
        ...(empresaConfig.logo ? [
          {
            image: empresaConfig.logo,
            width: 100,
            margin: [0, 0, 80, 0],
          }
        ] : [
          {
            text: empresaConfig.texto,
            fontSize: 24,
            bold: true,
            margin: [0, 20, 80, 20],
            style: 'mayorista'
          }
        ]),
        {
          columns: [
            {
              text: [
                { text: empresaConfig.direccion + '\n' },
                { text: empresaConfig.ciudad + '\n' },
                { text: this.sucursalNombre + '\n' },
                { text: empresaConfig.telefono + '\n' },
                { text: empresaConfig.email },
              ],
              fontSize: 10,
              margin: [10, 0, 0, 0],
            },
            {
              text: [
                { canvas: [{ type: 'rect', x: 0, y: 0, w: 100, h: 100, r: 3, lineWidth: 2, lineColor: '#000000' }], text: this.letraValue + '\n', style: { fontSize: 40 }, margin: [10, 5, 0, 0] },//{ text: this.letraValue + '\n', style: { border: '2px solid black', fontSize: 60 }  }, // Aseg√∫rate de que 'this.letra' represente la letra seleccionada en el campo 'letra'
                { text: 'DOCUMENTO\n' },
                { text: 'NO VALIDO\n' },
                { text: 'COMO FACTURA' }
              ],
              alignment: 'center',
              fontSize: 12,
            },
            {
              text: [
                { text: titulo + '\n' },
                { text: 'N¬∞ 0000 -' + numerocomprobante + '\n', alignment: 'right' },
                { text: 'Punto de venta: ' + this.puntoventa + '\n' },
              ],
              alignment: 'right',
              fontSize: 10,
            },
          ],
        },
        {
          text: 'Fecha: ' + fecha,
          alignment: 'right',
          margin: [25, 0, 5, 30],
          fontSize: 10,
        },
        //separador 
        {
          canvas: [
            {
              type: 'line',
              x1: 0, y1: 0,
              x2: 380, y2: 0,
              lineWidth: 2,
              lineColor: '#cccccc' // Color gris claro para la l√≠nea
            }
          ],
          margin: [0, 0, 30, 0] // Agregar un margen inferior a la l√≠nea
        },
        {
          columns: [
            {
              text: [
                { text: 'Sres: ' + cliente.nombre + '\n' },
                { text: 'Direccion: ' + cliente.direccion + '\n' },
                { text: 'DNI: ' + cliente.dni + '\n' },
                { text: 'CUIT: ' + cliente.cuit + '\n' },
                { text: 'Condicion de Venta: ' + cliente.tipoiva + '\n' },
              ],
              fontSize: 10,
              margin: [0, 10, 0, 10],
            },
          ],
        },
        {
          canvas: [
            {
              type: 'line',
              x1: 0, y1: 0,
              x2: 380, y2: 0,
              lineWidth: 2,
              lineColor: '#cccccc' // Color gris claro para la l√≠nea
            }
          ],
          margin: [0, 0, 30, 20] // Agregar un margen inferior a la l√≠nea
        },
        // ... Aqu√≠ puedes seguir a√±adiendo m√°s elementos al documento ...
        {
          style: 'tableExample',
          table: {
            widths: ['10%', '60%', '15%', '15%'],
            body: [
              ['Cant./Lts.', 'DETALLE', 'P.Unitario', 'Total'],
              ...tableBody,
            ],
            bold: true,
          },
        },
        // ‚úÖ NUEVO: Tabla de subtotales por tipo de pago
        ...(mostrarDesgloseTipoPago ? [{
          text: '\nDETALLE POR M√âTODO DE PAGO:',
          style: 'subheader',
          margin: [0, 10, 0, 5],
          fontSize: 10,
          bold: true
        }] : []),
        ...(mostrarDesgloseTipoPago ? [{
          style: 'tableExample',
          table: {
            widths: ['70%', '30%'],
            body: [
              ['M√©todo de Pago', 'Subtotal'],
              ...subtotalesTipoPago.map(item => [
                item.tipoPago.length > 50 ? item.tipoPago.substring(0, 47) + '...' : item.tipoPago,
                '$' + item.subtotal.toFixed(2)
              ])
            ],
            bold: false,
          },
          margin: [0, 0, 0, 10]
        }] : []),
        // Tabla de TOTAL
        {
          style: 'tableExample',
          table: {
            widths: ['*'],
            body: [
              ['TOTAL $' + parseFloat(total.toFixed(2))],
              // ... A√±ade m√°s filas seg√∫n sea necesario ...
            ],
            bold: true,
            fontSize: 16,
          },
        },
      ],
      styles: {
        header: {
          fontSize: 10,
          bold: true,
          margin: [2, 0, 0, 10],
        },
        tableExample: {
          margin: [0, 5, 0, 5],
          fontSize: 8,
        },
        total: {
          bold: true,
          fontSize: 8,
          margin: [0, 10, 0, 0],
        },
        mayorista: {
          bold: true,
          fontSize: 24,
          alignment: 'left',
          color: '#000000',
        },
      },
      defaultStyle: {
      },
    };
    // cerrar el loading 
    Swal.close();
    // Crear el PDF
    pdfMake.createPdf(documentDefinition).download(this.sucursalNombre + '_' + titulo + '_' + fechaFormateada + '.pdf');
    pdfMake.createPdf(documentDefinition).getBlob((blob) => {
      this.bot.sendToTelegram(blob, this.sucursalNombre + '_' + this.numerocomprobanteImpresion + '_' + titulo + '_' + fechaFormateada + '.pdf');
    }, (error: any) => {
      console.error(error);
    });
  }

  showNotification(message: string) {
    Swal.fire({
      icon: 'error',
      title: 'Error',
      text: message,
      confirmButtonText: 'Aceptar'
    });
  }
  
  // ====================================================================
  // SOLUCI√ìN M√öLTIPLES CAJAS: Crear un movimiento por cada m√©todo de pago
  // ====================================================================

  /**
   * Crea m√∫ltiples movimientos de caja, uno por cada m√©todo de pago
   * @param pedido Array de productos del pedido
   * @param cabecera Datos de la cabecera
   * @param fecha Fecha del pedido
   * @param subtotales Array de subtotales por tipo de pago
   * @returns Promise<Array> Array de objetos caja_movi
   */
  crearCajasMovi(pedido: any, cabecera: any, fecha: Date, subtotales: any[]): Promise<any[]> {
    // Validaciones
    if (!pedido || pedido.length === 0) {
      return Promise.resolve([]);
    }

    if (!subtotales || subtotales.length === 0) {
      console.warn('‚ö†Ô∏è No hay subtotales, creando movimiento √∫nico con comportamiento legacy');
      return this.crearCajaMoviLegacy(pedido, cabecera, fecha);
    }

    console.log(`üîß Creando ${subtotales.length} movimientos de caja (uno por m√©todo de pago)`);

    // Tomamos el primer item del pedido para datos comunes
    const primerItem = pedido[0];

    // Asegurarse de que fecha sea un objeto Date v√°lido
    const fechaObj = fecha instanceof Date ? fecha : new Date();
    const fechaFormateada = fechaObj.toISOString().split('T')[0];

    // Funci√≥n auxiliar para limitar valores num√©ricos
    const limitNumericValue = (value: any, limit: number) => {
      if (value === null || value === undefined || value === '') return null;
      const numValue = parseInt(value);
      return !isNaN(numValue) ? Math.min(numValue, limit) : null;
    };

    // Crear promesas para cada movimiento
    const promesas = subtotales.map((subtotal, index) => {
      // Buscar informaci√≥n de la tarjeta para este m√©todo de pago
      const tarjetaInfo = this.tarjetas.find(t => t.tarjeta === subtotal.tipoPago);

      if (!tarjetaInfo) {
        console.error(`‚ùå No se encontr√≥ tarjeta para: ${subtotal.tipoPago}`);
        return Promise.resolve(null);
      }

      console.log(`üîç M√©todo ${index + 1}/${subtotales.length}: ${subtotal.tipoPago} - $${subtotal.subtotal}`);

      // Obtener id_caja para este m√©todo de pago
      return this._cargardata.getIdCajaFromConcepto(tarjetaInfo.idcp_ingreso)
        .pipe(take(1))
        .toPromise()
        .then((response: any) => {
          if (response && response.mensaje && response.mensaje.length > 0) {
            const idCaja = response.mensaje[0].id_caja;

            console.log(`‚úÖ Caja obtenida: ID ${idCaja} para ${subtotal.tipoPago} (concepto: ${tarjetaInfo.idcp_ingreso})`);

            // Crear el movimiento para este m√©todo de pago
            return {
              sucursal: limitNumericValue(this.sucursal, 999999),
              codigo_mov: limitNumericValue(tarjetaInfo.idcp_ingreso, 9999999999),
              num_operacion: 0, // Se asignar√° en el backend
              fecha_mov: fechaFormateada,
              importe_mov: subtotal.subtotal, // ‚úÖ Importe espec√≠fico de este m√©todo
              descripcion_mov: '', // Se generar√° autom√°ticamente en el backend
              fecha_emibco: primerItem.fechacheque || null,
              banco: limitNumericValue(primerItem.codigobanco, 9999999999),
              num_cheque: limitNumericValue(primerItem.ncheque, 9999999999),
              cuenta_mov: limitNumericValue(primerItem.ncuenta, 999999),
              cliente: limitNumericValue(primerItem.idcli || cabecera.cliente, 9999999999),
              proveedor: null,
              plaza_cheque: primerItem.plaza || '',
              codigo_mbco: null,
              desc_bancaria: null,
              filler: null,
              fecha_cobro_bco: null,
              fecha_vto_bco: null,
              tipo_movi: 'A',
              caja: idCaja, // ‚úÖ Caja espec√≠fica de este m√©todo de pago
              letra: cabecera.letra || '',
              punto_venta: limitNumericValue(this.puntoventa, 9999),
              tipo_comprobante: primerItem.tipodoc || this.tipoDoc,
              numero_comprobante: limitNumericValue(this.numerocomprobante, 99999999),
              marca_cerrado: null,
              usuario: primerItem.emailop || sessionStorage.getItem('emailOp') || '',
              fecha_proceso: fechaFormateada
            };
          } else {
            console.error(`‚ùå No se pudo obtener id_caja para ${subtotal.tipoPago} (concepto: ${tarjetaInfo.idcp_ingreso})`);
            return null;
          }
        })
        .catch(error => {
          console.error(`‚ùå Error al obtener id_caja para ${subtotal.tipoPago}:`, error);
          return null;
        });
    });

    // Esperar todas las promesas y filtrar nulls
    return Promise.all(promesas).then(movimientos => {
      const movimientosValidos = movimientos.filter(m => m !== null);

      console.log(`‚úÖ ${movimientosValidos.length} movimientos creados exitosamente`);

      if (movimientosValidos.length === 0) {
        console.error('‚ùå No se pudo crear ning√∫n movimiento de caja');
      }

      return movimientosValidos;
    });
  }

  /**
   * M√©todo legacy para compatibilidad hacia atr√°s (movimiento √∫nico)
   * Se usa cuando no hay subtotales o para ventas con un solo m√©todo de pago
   */
  crearCajaMoviLegacy(pedido: any, cabecera: any, fecha: Date): Promise<any[]> {
    const primerItem = pedido[0];
    let tarjetaInfo: any = null;

    if (primerItem.cod_tar) {
      tarjetaInfo = this.tarjetas.find(t => t.cod_tarj.toString() === primerItem.cod_tar.toString());
    }

    const fechaObj = fecha instanceof Date ? fecha : new Date();
    const fechaFormateada = fechaObj.toISOString().split('T')[0];

    const limitNumericValue = (value: any, limit: number) => {
      if (value === null || value === undefined || value === '') return null;
      const numValue = parseInt(value);
      return !isNaN(numValue) ? Math.min(numValue, limit) : null;
    };

    const obtenerIdCaja = new Promise<number | null>((resolve) => {
      if (tarjetaInfo && tarjetaInfo.idcp_ingreso) {
        this._cargardata.getIdCajaFromConcepto(tarjetaInfo.idcp_ingreso).pipe(take(1)).subscribe(
          (response: any) => {
            if (response && response.mensaje && response.mensaje.length > 0) {
              resolve(response.mensaje[0].id_caja);
            } else {
              console.error('No se pudo obtener el id_caja');
              resolve(null);
            }
          },
          error => {
            console.error('Error al obtener id_caja:', error);
            resolve(null);
          }
        );
      } else {
        resolve(null);
      }
    });

    return obtenerIdCaja.then(idCajaObtenido => {
      const cajaMovi = {
        sucursal: limitNumericValue(this.sucursal, 999999),
        codigo_mov: tarjetaInfo ? limitNumericValue(tarjetaInfo.idcp_ingreso, 9999999999) : null,
        num_operacion: 0,
        fecha_mov: fechaFormateada,
        importe_mov: this.suma,
        descripcion_mov: '',
        fecha_emibco: primerItem.fechacheque || null,
        banco: limitNumericValue(primerItem.codigobanco, 9999999999),
        num_cheque: limitNumericValue(primerItem.ncheque, 9999999999),
        cuenta_mov: limitNumericValue(primerItem.ncuenta, 999999),
        cliente: limitNumericValue(primerItem.idcli || cabecera.cliente, 9999999999),
        proveedor: null,
        plaza_cheque: primerItem.plaza || '',
        codigo_mbco: null,
        desc_bancaria: null,
        filler: null,
        fecha_cobro_bco: null,
        fecha_vto_bco: null,
        tipo_movi: 'A',
        caja: idCajaObtenido,
        letra: cabecera.letra || '',
        punto_venta: limitNumericValue(this.puntoventa, 9999),
        tipo_comprobante: primerItem.tipodoc || this.tipoDoc,
        numero_comprobante: limitNumericValue(this.numerocomprobante, 99999999),
        marca_cerrado: null,
        usuario: primerItem.emailop || sessionStorage.getItem('emailOp') || '',
        fecha_proceso: fechaFormateada
      };

      // Retornar como array para mantener consistencia con crearCajasMovi
      return [cajaMovi];
    });
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(subscription => subscription.unsubscribe());
    this.subscriptions = [];
  }
}
